(function (global) {
  const compatibility = { ArrayBuffer: typeof ArrayBuffer !== 'undefined', DataView: typeof DataView !== 'undefined' && ('getFloat64' in DataView.prototype || 'getFloat64' in new DataView(new ArrayBuffer(1))), NodeBuffer: typeof Buffer !== 'undefined' && 'readInt16LE' in Buffer.prototype }; const dataTypes = {
    Int8: 1, Int16: 2, Int32: 4, Uint8: 1, Uint16: 2, Uint32: 4, Float32: 4, Float64: 8,
  }; const nodeNaming = {
    Int8: 'Int8', Int16: 'Int16', Int32: 'Int32', Uint8: 'UInt8', Uint16: 'UInt16', Uint32: 'UInt32', Float32: 'Float', Float64: 'Double',
  }; var jDataView = function (buffer, byteOffset, byteLength, littleEndian) {
    if (!(this instanceof jDataView)) { throw new Error('jDataView constructor may not be called as a function'); }
    this.buffer = buffer; if (!(compatibility.NodeBuffer && buffer instanceof Buffer) && !(compatibility.ArrayBuffer && buffer instanceof ArrayBuffer) && typeof buffer !== 'string') { throw new TypeError('jDataView buffer has an incompatible type'); }
    this._isArrayBuffer = compatibility.ArrayBuffer && buffer instanceof ArrayBuffer; this._isDataView = compatibility.DataView && this._isArrayBuffer; this._isNodeBuffer = compatibility.NodeBuffer && buffer instanceof Buffer; this._littleEndian = littleEndian === undefined ? false : littleEndian; const bufferLength = this._isArrayBuffer ? buffer.byteLength : buffer.length; if (byteOffset === undefined) { byteOffset = 0; }
    this.byteOffset = byteOffset; if (byteLength === undefined) { byteLength = bufferLength - byteOffset; }
    this.byteLength = byteLength; if (!this._isDataView) {
      if (typeof byteOffset !== 'number') { throw new TypeError('jDataView byteOffset is not a number'); }
      if (typeof byteLength !== 'number') { throw new TypeError('jDataView byteLength is not a number'); }
      if (byteOffset < 0) { throw new Error('jDataView byteOffset is negative'); }
      if (byteLength < 0) { throw new Error('jDataView byteLength is negative'); }
    }
    if (this._isDataView) { this._view = new DataView(buffer, byteOffset, byteLength); this._start = 0; }
    this._start = byteOffset; if (byteOffset + byteLength > bufferLength) { throw new Error('jDataView (byteOffset + byteLength) value is out of bounds'); }
    this._offset = 0; if (this._isDataView) {
      for (var type in dataTypes) {
        if (!dataTypes.hasOwnProperty(type)) { continue; }
        (function (type, view) {
          const size = dataTypes[type]; view[`get${type}`] = function (byteOffset, littleEndian) {
            if (littleEndian === undefined) { littleEndian = view._littleEndian; }
            if (byteOffset === undefined) { byteOffset = view._offset; }
            view._offset = byteOffset + size; return view._view[`get${type}`](byteOffset, littleEndian);
          };
        }(type, this));
      }
    } else if (this._isNodeBuffer && compatibility.NodeBuffer) {
      for (var type in dataTypes) {
        if (!dataTypes.hasOwnProperty(type)) { continue; }
        var name; if (type === 'Int8' || type === 'Uint8') { name = `read${nodeNaming[type]}`; } else if (littleEndian) { name = `read${nodeNaming[type]}LE`; } else { name = `read${nodeNaming[type]}BE`; }
        (function (type, view, name) {
          const size = dataTypes[type]; view[`get${type}`] = function (byteOffset, littleEndian) {
            if (littleEndian === undefined) { littleEndian = view._littleEndian; }
            if (byteOffset === undefined) { byteOffset = view._offset; }
            view._offset = byteOffset + size; return view.buffer[name](view._start + byteOffset);
          };
        }(type, this, name));
      }
    } else {
      for (var type in dataTypes) {
        if (!dataTypes.hasOwnProperty(type)) { continue; }
        (function (type, view) {
          const size = dataTypes[type]; view[`get${type}`] = function (byteOffset, littleEndian) {
            if (littleEndian === undefined) { littleEndian = view._littleEndian; }
            if (byteOffset === undefined) { byteOffset = view._offset; }
            view._offset = byteOffset + size; if (view._isArrayBuffer && (view._start + byteOffset) % size === 0 && (size === 1 || littleEndian)) { return new global[`${type}Array`](view.buffer, view._start + byteOffset, 1)[0]; } if (typeof byteOffset !== 'number') { throw new TypeError('jDataView byteOffset is not a number'); }
            if (byteOffset + size > view.byteLength) { throw new Error('jDataView (byteOffset + size) value is out of bounds'); }
            return view[`_get${type}`](view._start + byteOffset, littleEndian);
          };
        }(type, this));
      }
    }
  }; if (compatibility.NodeBuffer) {
    jDataView.createBuffer = function () {
      const buffer = new Buffer(arguments.length); for (let i = 0; i < arguments.length; ++i) { buffer[i] = arguments[i]; }
      return buffer;
    };
  } else if (compatibility.ArrayBuffer) {
    jDataView.createBuffer = function () {
      const buffer = new ArrayBuffer(arguments.length); const view = new Int8Array(buffer); for (let i = 0; i < arguments.length; ++i) { view[i] = arguments[i]; }
      return buffer;
    };
  } else { jDataView.createBuffer = function () { return String.fromCharCode.apply(null, arguments); }; }
  jDataView.prototype = {
    compatibility,
    getString(length, byteOffset) {
      let value; if (byteOffset === undefined) { byteOffset = this._offset; }
      if (typeof byteOffset !== 'number') { throw new TypeError('jDataView byteOffset is not a number'); }
      if (length < 0 || byteOffset + length > this.byteLength) { throw new Error('jDataView length or (byteOffset+length) value is out of bounds'); }
      if (this._isNodeBuffer) { value = this.buffer.toString('ascii', this._start + byteOffset, this._start + byteOffset + length); } else { value = ''; for (let i = 0; i < length; ++i) { const char = this.getUint8(byteOffset + i); value += String.fromCharCode(char > 127 ? 65533 : char); } }
      this._offset = byteOffset + length; return value;
    },
    getChar(byteOffset) { return this.getString(1, byteOffset); },
    tell() { return this._offset; },
    seek(byteOffset) {
      if (typeof byteOffset !== 'number') { throw new TypeError('jDataView byteOffset is not a number'); }
      if (byteOffset < 0 || byteOffset > this.byteLength) { throw new Error('jDataView byteOffset value is out of bounds'); }
      return this._offset = byteOffset;
    },
    _endianness(byteOffset, pos, max, littleEndian) { return byteOffset + (littleEndian ? max - pos - 1 : pos); },
    _getFloat64(byteOffset, littleEndian) {
      const b0 = this._getUint8(this._endianness(byteOffset, 0, 8, littleEndian)); const b1 = this._getUint8(this._endianness(byteOffset, 1, 8, littleEndian)); const b2 = this._getUint8(this._endianness(byteOffset, 2, 8, littleEndian)); const b3 = this._getUint8(this._endianness(byteOffset, 3, 8, littleEndian)); const b4 = this._getUint8(this._endianness(byteOffset, 4, 8, littleEndian)); const b5 = this._getUint8(this._endianness(byteOffset, 5, 8, littleEndian)); const b6 = this._getUint8(this._endianness(byteOffset, 6, 8, littleEndian)); const b7 = this._getUint8(this._endianness(byteOffset, 7, 8, littleEndian)); const sign = 1 - (2 * (b0 >> 7)); const exponent = ((((b0 << 1) & 0xff) << 3) | (b1 >> 4)) - (2 ** 10 - 1); const mantissa = ((b1 & 0x0f) * 2 ** 48) + (b2 * 2 ** 40) + (b3 * 2 ** 32)
+ (b4 * 2 ** 24) + (b5 * 2 ** 16) + (b6 * 2 ** 8) + b7; if (exponent === 1024) { if (mantissa !== 0) { return NaN; } return sign * Infinity; }
      if (exponent === -1023) { return sign * mantissa * 2 ** (-1022 - 52); }
      return sign * (1 + mantissa * 2 ** -52) * 2 ** exponent;
    },
    _getFloat32(byteOffset, littleEndian) {
      const b0 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)); const b1 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)); const b2 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)); const b3 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian)); const sign = 1 - (2 * (b0 >> 7)); const exponent = (((b0 << 1) & 0xff) | (b1 >> 7)) - 127; const mantissa = ((b1 & 0x7f) << 16) | (b2 << 8) | b3; if (exponent === 128) { if (mantissa !== 0) { return NaN; } return sign * Infinity; }
      if (exponent === -127) { return sign * mantissa * 2 ** (-126 - 23); }
      return sign * (1 + mantissa * 2 ** -23) * 2 ** exponent;
    },
    _getInt32(byteOffset, littleEndian) { const b = this._getUint32(byteOffset, littleEndian); return b > 2 ** 31 - 1 ? b - 2 ** 32 : b; },
    _getUint32(byteOffset, littleEndian) { const b3 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)); const b2 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)); const b1 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)); const b0 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian)); return (b3 * 2 ** 24) + (b2 << 16) + (b1 << 8) + b0; },
    _getInt16(byteOffset, littleEndian) { const b = this._getUint16(byteOffset, littleEndian); return b > 2 ** 15 - 1 ? b - 2 ** 16 : b; },
    _getUint16(byteOffset, littleEndian) { const b1 = this._getUint8(this._endianness(byteOffset, 0, 2, littleEndian)); const b0 = this._getUint8(this._endianness(byteOffset, 1, 2, littleEndian)); return (b1 << 8) + b0; },
    _getInt8(byteOffset) { const b = this._getUint8(byteOffset); return b > 2 ** 7 - 1 ? b - 2 ** 8 : b; },
    _getUint8(byteOffset) { if (this._isArrayBuffer) { return new Uint8Array(this.buffer, byteOffset, 1)[0]; } if (this._isNodeBuffer) { return this.buffer[byteOffset]; } return this.buffer.charCodeAt(byteOffset) & 0xff; },
  }; if (typeof jQuery !== 'undefined' && jQuery.fn.jquery >= '1.6.2') {
    const convertResponseBodyToText = function (byteArray) {
      let scrambledStr; try { scrambledStr = IEBinaryToArray_ByteStr(byteArray); } catch (e) { const IEBinaryToArray_ByteStr_Script = 'Function IEBinaryToArray_ByteStr(Binary)\r\n' + ' IEBinaryToArray_ByteStr = CStr(Binary)\r\n' + 'End Function\r\n' + 'Function IEBinaryToArray_ByteStr_Last(Binary)\r\n' + ' Dim lastIndex\r\n' + ' lastIndex = LenB(Binary)\r\n' + ' if lastIndex mod 2 Then\r\n' + '  IEBinaryToArray_ByteStr_Last = AscB( MidB( Binary, lastIndex, 1 ) )\r\n' + ' Else\r\n' + '  IEBinaryToArray_ByteStr_Last = -1\r\n' + ' End If\r\n' + 'End Function\r\n'; window.execScript(IEBinaryToArray_ByteStr_Script, 'vbscript'); scrambledStr = IEBinaryToArray_ByteStr(byteArray); }
      const lastChr = IEBinaryToArray_ByteStr_Last(byteArray); let result = ''; let i = 0; let l = scrambledStr.length % 8; let thischar; while (i < l) { thischar = scrambledStr.charCodeAt(i++); result += String.fromCharCode(thischar & 0xff, thischar >> 8); }
      l = scrambledStr.length;
      while (i < l) { result += String.fromCharCode((thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8); }
      if (lastChr > -1) { result += String.fromCharCode(lastChr); }
      return result;
    }; jQuery.ajaxSetup({ converters: { '* dataview': function (data) { return new jDataView(data); } }, accepts: { dataview: 'text/plain; charset=x-user-defined' }, responseHandler: { dataview(responses, options, xhr) { if ('mozResponseArrayBuffer' in xhr) { responses.text = xhr.mozResponseArrayBuffer; } else if ('responseType' in xhr && xhr.responseType === 'arraybuffer' && xhr.response) { responses.text = xhr.response; } else if ('responseBody' in xhr) { responses.text = convertResponseBodyToText(xhr.responseBody); } else { responses.text = xhr.responseText; } } } }); jQuery.ajaxPrefilter('dataview', (options, originalOptions, jqXHR) => {
      if (jQuery.support.ajaxResponseType) {
        if (!options.hasOwnProperty('xhrFields')) { options.xhrFields = {}; }
        options.xhrFields.responseType = 'arraybuffer';
      }
      options.mimeType = 'text/plain; charset=x-user-defined';
    });
  }
  global.jDataView = (global.module || {}).exports = jDataView; if (typeof module !== 'undefined') { module.exports = jDataView; }
}(this));
