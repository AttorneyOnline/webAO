{"version":3,"file":"ui.57a5733351660e1c32f9.bundle.js","mappings":"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","sources":["webpack://webao/./node_modules/golden-layout/src/ts/errors/internal-error.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/config-minifier.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/style-constants.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/types.ts","webpack://webao/./node_modules/golden-layout/src/ts/config/resolved-config.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/i18n-strings.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/utils.ts","webpack://webao/./node_modules/golden-layout/src/ts/errors/external-error.ts","webpack://webao/./node_modules/golden-layout/src/ts/config/config.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/event-emitter.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/browser-popout.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/header-button.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/drag-listener.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/tab.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/tabs-container.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/header.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/jquery-legacy.ts","webpack://webao/./node_modules/golden-layout/src/ts/container/component-container.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/content-item.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/component-item.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/component-parentable-item.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/stack.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/drag-proxy.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/splitter.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/row-or-column.ts","webpack://webao/./node_modules/golden-layout/src/ts/items/ground-item.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/drag-source.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/drop-target-indicator.ts","webpack://webao/./node_modules/golden-layout/src/ts/controls/transition-indicator.ts","webpack://webao/./node_modules/golden-layout/src/ts/utils/event-hub.ts","webpack://webao/./node_modules/golden-layout/src/ts/layout-manager.ts","webpack://webao/./node_modules/golden-layout/src/ts/virtual-layout.ts","webpack://webao/./webAO/ui.js","webpack://webao/./node_modules/golden-layout/src/ts/golden-layout.ts"],"sourcesContent":["/** @internal */\nabstract class InternalError extends Error {\n    constructor(type: string, code: string, message?: string) {\n        super(`${type}: ${code}${message === undefined ? '' : ': ' + message}`)\n    }\n}\n\n/** @internal */\nexport class AssertError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('Assert', code, message)\n    }\n}\n\n/** @internal */\nexport class UnreachableCaseError extends InternalError {\n    constructor(code: string, variableValue: never, message?: string) {\n        super('UnreachableCase', code, `${variableValue}${message === undefined ? '' : ': ' + message}`)\n    }\n}\n\n/** @internal */\nexport class UnexpectedNullError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('UnexpectedNull', code, message)\n    }\n}\n\n/** @internal */\nexport class UnexpectedUndefinedError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('UnexpectedUndefined', code, message)\n    }\n}\n","/**\n * Minifies and unminifies configs by replacing frequent keys\n * and values with one letter substitutes. Config options must\n * retain array position/index, add new options at the end.\n * @internal\n*/\n\nexport namespace ConfigMinifier {\n\n    export type YY = 'id' | 'title';\n    export const enum XX {\n        id = 'id'\n    }\n    const keys: readonly string[] = [\n        'settings',\n        'hasHeaders',\n        'constrainDragToContainer',\n        'selectionEnabled',\n        'dimensions',\n        'borderWidth',\n        'minItemHeight',\n        'minItemWidth',\n        'headerHeight',\n        'dragProxyWidth',\n        'dragProxyHeight',\n        'labels',\n        'close',\n        'maximise',\n        'minimise',\n        'popout',\n        'content',\n        'componentType',\n        'componentState',\n        'id',\n        'width',\n        'type',\n        'height',\n        'isClosable',\n        'title',\n        'popoutWholeStack',\n        'openPopouts',\n        'parentId',\n        'activeItemIndex',\n        'reorderEnabled',\n        'borderGrabWidth',\n\n\n\n\n        //Maximum 36 entries, do not cross this line!\n    ];\n\n    const values: readonly (boolean | string)[] = [\n        true,\n        false,\n        'row',\n        'column',\n        'stack',\n        'component',\n        'close',\n        'maximise',\n        'minimise',\n        'open in new window'\n    ];\n\n    export function checkInitialise(): void {\n        if (keys.length > 36) {\n            throw new Error('Too many keys in config minifier map');\n        }\n    }\n\n    export function translateObject(from: Record<string, unknown>, minify: boolean): Record<string, unknown> {\n        const to: Record<string, unknown> = {};\n        for (const key in from) {\n            if (from.hasOwnProperty(key)) { // In case something has extended Object prototypes\n                let translatedKey: string;\n                if (minify) {\n                    translatedKey = minifyKey(key);\n                } else {\n                    translatedKey = unminifyKey(key);\n                }\n\n                const fromValue = from[key];\n                to[translatedKey] = translateValue(fromValue, minify);\n            }\n        }\n\n        return to;\n    }\n\n    function translateArray(from: unknown[], minify: boolean) {\n        const length = from.length;\n        const to = new Array<unknown>(length);\n        for (let i = 0; i < length; i++) {\n            // In original code, array indices were numbers and not translated\n            const fromValue = from[i];\n            to[i] = translateValue(fromValue, minify);\n        }\n        return to;\n    }\n\n    function translateValue(from: unknown, minify: boolean) {\n        if (typeof from === 'object') {\n            if (from === null) {\n                return null;\n            } else {\n                if (Array.isArray(from)) {\n                    return translateArray(from, minify);\n                } else {\n                    return translateObject(from as Record<string, unknown>, minify);\n                }\n            }\n        } else {\n            if (minify) {\n                return minifyValue(from);\n            } else {\n                return unminifyValue(from);\n            }\n        }\n    }\n\n    function minifyKey(value: string) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n    \n        const index = indexOfKey(value);\n    \n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n    \n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        } else {\n            return index.toString(36);\n        }\n    }\n\n    function unminifyKey(key: string) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (key.length === 1) {\n            return keys[parseInt(key, 36)];\n        }\n    \n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (key.substr(0, 3) === '___') {\n            return key[3];\n        }\n        /**\n         * value was not minified\n         */\n        return key;\n    }\n\n    function minifyValue(value: unknown) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n    \n        const index = indexOfValue(value);\n    \n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n    \n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        } else {\n            return index.toString(36);\n        }\n    }\n\n    function unminifyValue(value: unknown) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return values[parseInt(value, 36)];\n        }\n\n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (typeof value === 'string' && value.substr(0, 3) === '___') {\n            return value[3];\n        }\n        /**\n         * value was not minified\n         */\n        return value;\n    }\n\n    function indexOfKey(key: string) {\n        for (let i = 0; i < keys.length; i++) {\n            if (keys[i] === key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    function indexOfValue(value: unknown) {\n        for (let i = 0; i < values.length; i++) {\n            if (values[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n","/** @public */\nexport namespace StyleConstants {\n    export const defaultComponentBaseZIndex = 'auto';\n    export const defaultComponentDragZIndex = '32';\n    export const defaultComponentStackMaximisedZIndex = '41';\n}\n","import { StyleConstants } from './style-constants';\n\n/** @internal */\nexport type WidthOrHeightPropertyName = 'width' | 'height';\n\n/** @internal */\nexport namespace WidthOrHeightPropertyName {\n    export const width = 'width';\n    export const height = 'height';\n}\n\n/** @internal */\nexport interface WidthAndHeight {\n    width: number;\n    height: number;\n}\n\n/** @internal */\nexport interface LeftAndTop {\n    left: number;\n    top: number;\n}\n\n/** @public */\nexport type Side = 'top' | 'left' | 'right' | 'bottom';\n/** @public */\nexport namespace Side {\n    export const top = 'top';\n    export const left = 'left';\n    export const right = 'right';\n    export const bottom = 'bottom';\n}\n\n/** @public */\nexport type LogicalZIndex = 'base' | 'drag' | 'stackMaximised';\n/** @public */\nexport namespace LogicalZIndex {\n    export const base = 'base';\n    export const drag = 'drag';\n    export const stackMaximised = 'stackMaximised';\n}\n\n/** @public */\nexport const LogicalZIndexToDefaultMap = {\n    base: StyleConstants.defaultComponentBaseZIndex,\n    drag: StyleConstants.defaultComponentDragZIndex,\n    stackMaximised: StyleConstants.defaultComponentStackMaximisedZIndex,\n}\n\n/** @internal */\nexport interface Rect {\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n}\n\n/** @internal */\nexport interface AreaLinkedRect {\n    x1: number, // left\n    x2: number, // nextLeft\n    y1: number, // top\n    y2: number, // nextTop\n}\n\n/** @public */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type JsonValue = string | number | boolean | null | Json | object | JsonValueArray;\n/** @public */\nexport interface Json {\n    [name: string]: JsonValue;\n}\n/** @public */\nexport type JsonValueArray = Array<JsonValue>\n/** @public */\nexport namespace JsonValue {\n    export function isJson(value: JsonValue): value is Json {\n        return isJsonObject(value);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    export function isJsonObject(value: JsonValue): value is Json | object {\n        return !Array.isArray(value) && value !== null && typeof value === 'object';\n    }\n}\n\n/** @public */\nexport type ItemType = 'ground' | 'row' | 'column' | 'stack' | 'component';\n\n/** @public */\nexport namespace ItemType {\n    export const ground = 'ground';\n    export const row = 'row';\n    export const column = 'column';\n    export const stack = 'stack';\n    export const component = 'component';\n}\n\n/** @public */\nexport type ResponsiveMode = 'none' | 'always' | 'onload';\n/** @public */\nexport namespace ResponsiveMode {\n    export const none = 'none';\n    export const always = 'always';\n    export const onload = 'onload';\n}\n","import { AssertError, UnreachableCaseError } from '../errors/internal-error';\nimport { ConfigMinifier } from '../utils/config-minifier';\nimport { ItemType, JsonValue, ResponsiveMode, Side } from '../utils/types';\nimport { deepExtendValue } from '../utils/utils';\n\n/** @public */\nexport interface ResolvedItemConfig {\n    // see ItemConfig for comments\n    readonly type: ItemType;\n    readonly content: readonly ResolvedItemConfig[];\n    readonly width: number;\n    readonly minWidth: number;\n    readonly height: number;\n    readonly minHeight: number;\n    // id no longer specifies whether an Item is maximised.  This is now done by HeaderItemConfig.maximised\n    readonly id: string;\n    readonly isClosable: boolean;\n}\n\n/** @public */\nexport namespace ResolvedItemConfig {\n    export const defaults: ResolvedItemConfig = {\n        type: ItemType.ground, // not really default but need something\n        content: [],\n        width: 50,\n        minWidth: 0,\n        height: 50,\n        minHeight: 0,\n        id: '',\n        isClosable: true,\n    } as const;\n\n    /** Creates a copy of the original ResolvedItemConfig using an alternative content if specified */\n    export function createCopy(original: ResolvedItemConfig, content?: ResolvedItemConfig[]): ResolvedItemConfig {\n        switch (original.type) {\n            case ItemType.ground:\n            case ItemType.row:\n            case ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createCopy(original as ResolvedRowOrColumnItemConfig,\n                    content as ResolvedRowOrColumnItemConfig.ChildItemConfig[]);\n\n            case ItemType.stack:\n                return ResolvedStackItemConfig.createCopy(original as ResolvedStackItemConfig, content as ResolvedComponentItemConfig[]);\n\n            case ItemType.component:\n                return ResolvedComponentItemConfig.createCopy(original as ResolvedComponentItemConfig);\n\n            default:\n                throw new UnreachableCaseError('CICC91354', original.type, 'Invalid Config Item type specified');\n        }\n    }\n\n    export function createDefault(type: ItemType): ResolvedItemConfig {\n        switch (type) {\n            case ItemType.ground:\n                throw new AssertError('CICCDR91562'); // Get default root from LayoutConfig\n            case ItemType.row:\n            case ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createDefault(type);\n\n            case ItemType.stack:\n                return ResolvedStackItemConfig.createDefault();\n\n            case ItemType.component:\n                return ResolvedComponentItemConfig.createDefault();\n\n            default:\n                throw new UnreachableCaseError('CICCDD91563', type, 'Invalid Config Item type specified');\n        }\n    }\n\n    export function isComponentItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedComponentItemConfig {\n        return itemConfig.type === ItemType.component;\n    }\n\n    export function isStackItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedStackItemConfig {\n        return itemConfig.type === ItemType.stack;\n    }\n\n    /** @internal */\n    export function isGroundItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedGroundItemConfig {\n        return itemConfig.type === ItemType.ground;\n    }\n}\n\n// Stack or Component\n/** @public */\nexport interface ResolvedHeaderedItemConfig extends ResolvedItemConfig {\n    header: ResolvedHeaderedItemConfig.Header | undefined; // undefined means get header settings from LayoutConfig\n    readonly maximised: boolean;\n}\n\n/** @public */\nexport namespace ResolvedHeaderedItemConfig {\n    export const defaultMaximised = false;\n\n    export interface Header {\n        // undefined means get property value from LayoutConfig\n        readonly show: false | Side | undefined;\n        readonly popout: false | string | undefined;\n        readonly maximise: false | string | undefined;\n        readonly close: string | undefined;\n        readonly minimise: string | undefined;\n        readonly tabDropdown: false | string | undefined;\n    }\n\n    export namespace Header {\n        export function createCopy(original: Header | undefined, show?: false | Side): Header | undefined {\n            if (original === undefined) {\n                return undefined;\n            } else {\n                return {\n                    show: show ?? original.show,\n                    popout: original.popout,\n                    close: original.close,\n                    maximise: original.maximise,\n                    minimise: original.minimise,\n                    tabDropdown: original.tabDropdown,\n                }\n            }\n        }\n    }\n}\n\n/** @public */\nexport interface ResolvedStackItemConfig extends ResolvedHeaderedItemConfig {\n    readonly type: 'stack';\n    readonly content: ResolvedComponentItemConfig[];\n    /** The index of the active item in the Stack.  Only undefined if the Stack is empty. */\n    readonly activeItemIndex: number | undefined;\n}\n\n/** @public */\nexport namespace ResolvedStackItemConfig {\n    export const defaultActiveItemIndex = 0;\n\n    export function createCopy(original: ResolvedStackItemConfig, content?: ResolvedComponentItemConfig[]): ResolvedStackItemConfig {\n        const result: ResolvedStackItemConfig = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            width: original.width,\n            minWidth: original.minWidth,\n            height: original.height,\n            minHeight: original.minHeight,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            activeItemIndex: original.activeItemIndex,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n        }\n        return result;\n    }\n\n    export function copyContent(original: ResolvedComponentItemConfig[]): ResolvedComponentItemConfig[] {\n        const count = original.length;\n        const result = new Array<ResolvedComponentItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]) as ResolvedComponentItemConfig;\n        }\n        return result;\n    }\n\n    export function createDefault(): ResolvedStackItemConfig {\n        const result: ResolvedStackItemConfig = {\n            type: ItemType.stack,\n            content: [],\n            width: ResolvedItemConfig.defaults.width,\n            minWidth: ResolvedItemConfig.defaults.minWidth,\n            height: ResolvedItemConfig.defaults.height,\n            minHeight: ResolvedItemConfig.defaults.minHeight,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: defaultActiveItemIndex,\n            header: undefined,\n        }\n        return result;\n    }\n}\n\n/** @public */\nexport interface ResolvedComponentItemConfig extends ResolvedHeaderedItemConfig {\n    // see ComponentItemConfig for comments\n    readonly type: 'component';\n    readonly content: [];\n    readonly title: string;\n    readonly reorderEnabled: boolean; // Takes precedence over LayoutConfig.reorderEnabled.\n    /**\n     * The name of the component as specified in layout.registerComponent. Mandatory if type is 'component'.\n     */\n    readonly componentType: JsonValue;\n    readonly componentState?: JsonValue;\n}\n\n/** @public */\nexport namespace ResolvedComponentItemConfig {\n    export const defaultReorderEnabled = true;\n\n    export function resolveComponentTypeName(itemConfig: ResolvedComponentItemConfig): string | undefined {\n        const componentType = itemConfig.componentType;\n        if (typeof componentType === 'string') {\n            return componentType;\n        } else {\n            return undefined;\n        }\n    }\n\n    export function createCopy(original: ResolvedComponentItemConfig): ResolvedComponentItemConfig {\n        const result: ResolvedComponentItemConfig = {\n            type: original.type,\n            content: [],\n            width: original.width,\n            minWidth: original.minWidth,\n            height: original.height,\n            minHeight: original.minHeight,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            reorderEnabled: original.reorderEnabled,\n            title: original.title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n            componentType: original.componentType,\n            componentState: deepExtendValue(undefined, original.componentState) as JsonValue,\n        }\n        return result;\n    }\n\n    export function createDefault(componentType: JsonValue = '', componentState?: JsonValue, title = ''): ResolvedComponentItemConfig {\n        const result: ResolvedComponentItemConfig = {\n            type: ItemType.component,\n            content: [],\n            width: ResolvedItemConfig.defaults.width,\n            minWidth: ResolvedItemConfig.defaults.minWidth,\n            height: ResolvedItemConfig.defaults.height,\n            minHeight: ResolvedItemConfig.defaults.minHeight,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            reorderEnabled: ResolvedComponentItemConfig.defaultReorderEnabled,\n            title,\n            header: undefined,\n            componentType,\n            componentState,\n        }\n        return result;\n    }\n\n    export function copyComponentType(componentType: JsonValue): JsonValue {\n        return deepExtendValue({}, componentType) as JsonValue\n    }\n}\n\n/** Base for Root or RowOrColumn ItemConfigs\n * @public\n */\nexport interface ResolvedRowOrColumnItemConfig extends ResolvedItemConfig {\n    readonly type: 'row' | 'column';\n    /** Note that RowOrColumn ResolvedItemConfig contents, can contain ComponentItem itemConfigs.  However\n     * when ContentItems are created, these ComponentItem itemConfigs will create a Stack with a child ComponentItem.\n     */\n    readonly content: readonly (ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig)[];\n}\n\n/** @public */\nexport namespace ResolvedRowOrColumnItemConfig {\n    export type ChildItemConfig = ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig;\n\n    export function isChildItemConfig(itemConfig: ResolvedItemConfig): itemConfig is ChildItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n\n    export function createCopy(original: ResolvedRowOrColumnItemConfig, content?: ChildItemConfig[]): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            width: original.width,\n            minWidth: original.minWidth,\n            height: original.height,\n            minHeight: original.minHeight,\n            id: original.id,\n            isClosable: original.isClosable,\n        }\n        return result;\n    }\n\n    export function copyContent(original: readonly ChildItemConfig[]): ChildItemConfig[] {\n        const count = original.length;\n        const result = new Array<ChildItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]) as ChildItemConfig;\n        }\n        return result;\n    }\n\n    export function createDefault(type: 'row' | 'column'): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type,\n            content: [],\n            width: ResolvedItemConfig.defaults.width,\n            minWidth: ResolvedItemConfig.defaults.minWidth,\n            height: ResolvedItemConfig.defaults.height,\n            minHeight: ResolvedItemConfig.defaults.minHeight,\n            id: ResolvedItemConfig.defaults.id,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n        }\n        return result;\n    }\n}\n\n/**\n * RootItemConfig is the topmost ResolvedItemConfig specified by the user.\n * Note that it does not have a corresponding contentItem.  It specifies the one and only child of the Ground ContentItem\n * Note that RootItemConfig can be an ComponentItem itemConfig.  However when the Ground ContentItem's child is created\n * a ComponentItem itemConfig will create a Stack with a child ComponentItem.\n * @public\n*/\nexport type ResolvedRootItemConfig = ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig;\n\n/** @public */\nexport namespace ResolvedRootItemConfig {\n    export function createCopy(config: ResolvedRootItemConfig): ResolvedRootItemConfig {\n        return ResolvedItemConfig.createCopy(config) as ResolvedRootItemConfig;\n    }\n\n    export function isRootItemConfig(itemConfig: ResolvedItemConfig): itemConfig is ResolvedRootItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n}\n\n/** @internal */\nexport interface ResolvedGroundItemConfig extends ResolvedItemConfig {\n    readonly type: 'ground';\n    readonly width: 100,\n    readonly minWidth: 0,\n    readonly height: 100,\n    readonly minHeight: 0,\n    readonly id: '',\n    readonly isClosable: false,\n    readonly title: '',\n    readonly reorderEnabled: false,\n}\n\n/** @internal */\nexport namespace ResolvedGroundItemConfig {\n    export function create(rootItemConfig: ResolvedRootItemConfig | undefined):ResolvedGroundItemConfig {\n        const content = rootItemConfig === undefined ? [] : [rootItemConfig];\n        return {\n            type: ItemType.ground,\n            content,\n            width: 100,\n            minWidth: 0,\n            height: 100,\n            minHeight: 0,\n            id: '',\n            isClosable: false,\n            title: '',\n            reorderEnabled: false,\n        }\n    }\n}\n\n/** @public */\nexport interface ResolvedLayoutConfig {\n    readonly root: ResolvedRootItemConfig | undefined;\n    readonly openPopouts: ResolvedPopoutLayoutConfig[];\n    readonly dimensions: ResolvedLayoutConfig.Dimensions;\n    readonly settings: ResolvedLayoutConfig.Settings;\n    readonly header: ResolvedLayoutConfig.Header;\n    readonly resolved: true,\n}\n\n/** @public */\nexport namespace ResolvedLayoutConfig {\n    export interface Settings {\n        // see Config.Settings for comments\n        readonly constrainDragToContainer: boolean;\n        readonly reorderEnabled: boolean; // also in ResolvedItemConfig which takes precedence\n        readonly popoutWholeStack: boolean;\n        readonly blockedPopoutsThrowError: boolean;\n        readonly closePopoutsOnUnload: boolean;\n        readonly responsiveMode: ResponsiveMode;\n        readonly tabOverlapAllowance: number;\n        readonly reorderOnTabMenuClick: boolean;\n        readonly tabControlOffset: number;\n        readonly popInOnClose: boolean;\n    }\n\n    export namespace Settings {\n        export const defaults: ResolvedLayoutConfig.Settings = {\n            constrainDragToContainer: true,\n            reorderEnabled: true,\n            popoutWholeStack: false,\n            blockedPopoutsThrowError: true,\n            closePopoutsOnUnload: true,\n            responsiveMode: ResponsiveMode.none, // was onload\n            tabOverlapAllowance: 0,\n            reorderOnTabMenuClick: true,\n            tabControlOffset: 10,\n            popInOnClose: false,\n        } as const;\n\n        export function createCopy(original: Settings): Settings {\n            return {\n                constrainDragToContainer: original.constrainDragToContainer,\n                reorderEnabled: original.reorderEnabled,\n                popoutWholeStack: original.popoutWholeStack,\n                blockedPopoutsThrowError: original.blockedPopoutsThrowError,\n                closePopoutsOnUnload: original.closePopoutsOnUnload,\n                responsiveMode: original.responsiveMode,\n                tabOverlapAllowance: original.tabOverlapAllowance,\n                reorderOnTabMenuClick: original.reorderOnTabMenuClick,\n                tabControlOffset: original.tabControlOffset,\n                popInOnClose: original.popInOnClose,\n            }\n        }\n    }\n\n    export interface Dimensions {\n        // see LayoutConfig.Dimensions for comments\n        readonly borderWidth: number;\n        readonly borderGrabWidth: number,\n        readonly minItemHeight: number;\n        readonly minItemWidth: number;\n        readonly headerHeight: number;\n        readonly dragProxyWidth: number;\n        readonly dragProxyHeight: number;\n    }\n\n    export namespace Dimensions {\n        export function createCopy(original: Dimensions): Dimensions {\n            return {\n                borderWidth: original.borderWidth,\n                borderGrabWidth: original.borderGrabWidth,\n                minItemHeight: original.minItemHeight,\n                minItemWidth: original.minItemWidth,\n                headerHeight: original.headerHeight,\n                dragProxyWidth: original.dragProxyWidth,\n                dragProxyHeight: original.dragProxyHeight,\n            }\n        }\n\n        export const defaults: ResolvedLayoutConfig.Dimensions = {\n            borderWidth: 5,\n            borderGrabWidth: 5,\n            minItemHeight: 10,\n            minItemWidth: 10,\n            headerHeight: 20,\n            dragProxyWidth: 300,\n            dragProxyHeight: 200\n        } as const;\n    }\n\n    export interface Header {\n        readonly show: false | Side;\n        readonly popout: false | string;\n        readonly dock: string;\n        readonly maximise: false | string;\n        readonly minimise: string;\n        readonly close: false | string;\n        readonly tabDropdown: false | string;\n    }\n\n    export namespace Header {\n        export function createCopy(original: Header): Header {\n            return {\n                show: original.show,\n                popout: original.popout,\n                dock: original.dock,\n                close: original.close,\n                maximise: original.maximise,\n                minimise: original.minimise,\n                tabDropdown: original.tabDropdown,\n            }\n        }\n\n        export const defaults: ResolvedLayoutConfig.Header = {\n            show: Side.top,\n            popout: 'open in new window',\n            dock: 'dock',\n            maximise: 'maximise',\n            minimise: 'minimise',\n            close: 'close',\n            tabDropdown: 'additional tabs'\n        } as const;\n    }\n\n    export function isPopout(config: ResolvedLayoutConfig): config is ResolvedPopoutLayoutConfig {\n        return 'parentId' in config;\n    }\n\n    export function createDefault(): ResolvedLayoutConfig {\n        const result: ResolvedLayoutConfig = {\n            root: undefined,\n            openPopouts: [],\n            dimensions: ResolvedLayoutConfig.Dimensions.defaults,\n            settings: ResolvedLayoutConfig.Settings.defaults,\n            header: ResolvedLayoutConfig.Header.defaults,\n            resolved: true,\n        }\n        return result;\n    }\n\n    export function createCopy(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        if (isPopout(config)) {\n            return ResolvedPopoutLayoutConfig.createCopy(config);\n        } else {\n            const result: ResolvedLayoutConfig = {\n                root: config.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(config.root),\n                openPopouts: ResolvedLayoutConfig.copyOpenPopouts(config.openPopouts),\n                settings: ResolvedLayoutConfig.Settings.createCopy(config.settings),\n                dimensions: ResolvedLayoutConfig.Dimensions.createCopy(config.dimensions),\n                header: ResolvedLayoutConfig.Header.createCopy(config.header),\n                resolved: config.resolved,\n            }\n            return result;\n        }\n    }\n\n    export function copyOpenPopouts(original: ResolvedPopoutLayoutConfig[]): ResolvedPopoutLayoutConfig[] {\n        const count = original.length;\n        const result = new Array<ResolvedPopoutLayoutConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedPopoutLayoutConfig.createCopy(original[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter counterparts\n     */\n    export function minifyConfig(layoutConfig: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ConfigMinifier.translateObject(layoutConfig, true) as ResolvedLayoutConfig;\n    }\n\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     */\n    export function unminifyConfig(minifiedConfig: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ConfigMinifier.translateObject(minifiedConfig, false) as ResolvedLayoutConfig;\n    }\n}\n\n/** @public */\nexport interface ResolvedPopoutLayoutConfig extends ResolvedLayoutConfig {\n    readonly parentId: string | null;\n    readonly indexInParent: number | null;\n    readonly window: ResolvedPopoutLayoutConfig.Window;\n}\n\n/** @public */\nexport namespace ResolvedPopoutLayoutConfig {\n    export interface Window {\n        readonly width: number | null,\n        readonly height: number | null,\n        readonly left: number | null,\n        readonly top: number | null,\n    }\n\n    export namespace Window {\n        export function createCopy(original: Window): Window {\n            return {\n                width: original.width,\n                height: original.height,\n                left: original.left,\n                top: original.top,\n            }\n        }\n\n        export const defaults: ResolvedPopoutLayoutConfig.Window = {\n            width: null,\n            height: null,\n            left: null,\n            top: null,\n        } as const;\n    }\n\n    export function createCopy(original: ResolvedPopoutLayoutConfig): ResolvedPopoutLayoutConfig {\n        const result: ResolvedPopoutLayoutConfig = {\n            root: original.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(original.root),\n            openPopouts: ResolvedLayoutConfig.copyOpenPopouts(original.openPopouts),\n            settings: ResolvedLayoutConfig.Settings.createCopy(original.settings),\n            dimensions: ResolvedLayoutConfig.Dimensions.createCopy(original.dimensions),\n            header: ResolvedLayoutConfig.Header.createCopy(original.header),\n            parentId: original.parentId,\n            indexInParent: original.indexInParent,\n            window: ResolvedPopoutLayoutConfig.Window.createCopy(original.window),\n            resolved: original.resolved,\n        }\n        return result;\n    }\n}\n","import { AssertError } from '../errors/internal-error';\n\n/** @public */\nexport const enum I18nStringId {\n    PopoutCannotBeCreatedWithGroundItemConfig,\n    PleaseRegisterAConstructorFunction,\n    ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned,\n    ComponentIsAlreadyRegistered,\n    ComponentIsNotVirtuable,\n    VirtualComponentDoesNotHaveRootHtmlElement,\n    ItemConfigIsNotTypeComponent,\n}\n\n/** @public */\nexport namespace I18nStrings {\n    /** @internal */\n    let initialised = false;\n\n    /** @internal */\n    interface Info {\n        readonly id: I18nStringId;\n        readonly default: string;\n    }\n\n    /** @internal */\n    type InfosObject = { [id in keyof typeof I18nStringId]: Info };\n\n    /** @internal */\n    const infosObject: InfosObject = {\n        PopoutCannotBeCreatedWithGroundItemConfig: {\n            id: I18nStringId.PopoutCannotBeCreatedWithGroundItemConfig,\n            default: 'Popout cannot be created with ground ItemConfig'\n        },\n        PleaseRegisterAConstructorFunction: {\n            id: I18nStringId.PleaseRegisterAConstructorFunction,\n            default: 'Please register a constructor function'\n        },\n        ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned: {\n            id: I18nStringId.ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned,\n            default: 'Component type not registered and BindComponentEvent handler not assigned',\n        },\n        ComponentIsAlreadyRegistered: {\n            id: I18nStringId.ComponentIsAlreadyRegistered,\n            default: 'Component is already registered',\n        },\n        ComponentIsNotVirtuable: {\n            id: I18nStringId.ComponentIsNotVirtuable,\n            default: 'Component is not virtuable. Requires rootHtmlElement field/getter',\n        },\n        VirtualComponentDoesNotHaveRootHtmlElement: {\n            id: I18nStringId.VirtualComponentDoesNotHaveRootHtmlElement,\n            default: 'Virtual component does not have getter \"rootHtmlElement\"',\n        },\n        ItemConfigIsNotTypeComponent: {\n            id: I18nStringId.ItemConfigIsNotTypeComponent,\n            default: 'ItemConfig is not of type component',\n        },\n    }\n\n    export const idCount = Object.keys(infosObject).length;\n    /** @internal */\n    const infos = Object.values(infosObject);\n\n    export function checkInitialise(): void {\n        if (!initialised) {\n            for (let i = 0; i < idCount; i++) {\n                const info = infos[i];\n                if (info.id !== i) {\n                    throw new AssertError('INSI00110', `${i}: ${info.id}`);\n                } else {\n                    i18nStrings[i] = info.default;\n                }\n            }\n        }\n        initialised = true;\n    }\n}\n\n/** @public */\nexport const i18nStrings = new Array<string>(I18nStrings.idCount);\n","import { WidthAndHeight } from './types';\n\n/** @internal */\nexport function numberToPixels(value: number): string {\n    return value.toString(10) + 'px';\n}\n\n/** @internal */\nexport function pixelsToNumber(value: string): number {\n    const numberStr = value.replace(\"px\", \"\");\n    return parseFloat(numberStr);\n}\n\n/** @internal */\nexport function getElementWidth(element: HTMLElement): number {\n    return element.offsetWidth;\n}\n\n/** @internal */\nexport function setElementWidth(element: HTMLElement, width: number): void {\n    const widthAsPixels = numberToPixels(width);\n    element.style.width = widthAsPixels;\n}\n\n/** @internal */\nexport function getElementHeight(element: HTMLElement): number {\n    return element.offsetHeight;\n}\n\n/** @internal */\nexport function setElementHeight(element: HTMLElement, height: number): void {\n    const heightAsPixels = numberToPixels(height);\n    element.style.height = heightAsPixels;\n}\n\n/** @internal */\nexport function getElementWidthAndHeight(element: HTMLElement): WidthAndHeight {\n    return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n    };\n}\n\n/** @internal */\nexport function setElementDisplayVisibility(element: HTMLElement, visible: boolean): void {\n    if (visible) {\n        element.style.display = '';\n    } else {\n        element.style.display = 'none';\n    }\n}\n\n/** @internal */\nexport function ensureElementPositionAbsolute(element: HTMLElement): void {\n    const absolutePosition = 'absolute';\n    if (element.style.position !== absolutePosition) {\n        element.style.position = absolutePosition;\n    }\n}\n\n/**\n * Replacement for JQuery $.extend(target, obj)\n * @internal\n*/\nexport function extend(target: Record<string, unknown>, obj: Record<string, unknown>): Record<string, unknown> {\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            target[key] = obj[key];\n        }\n    }\n    return target;\n}\n\n/**\n * Replacement for JQuery $.extend(true, target, obj)\n * @internal\n*/\nexport function deepExtend(target: Record<string, unknown>, obj: Record<string, unknown> | undefined): Record<string, unknown> {\n    if (obj !== undefined) {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                const value = obj[key];\n                const existingTarget = target[key];\n                target[key] = deepExtendValue(existingTarget, value);\n            }\n        }\n    }\n\n    return target;\n}\n\n/** @internal */\nexport function deepExtendValue(existingTarget: unknown, value: unknown): unknown {\n    if (typeof value !== 'object') {\n        return value;\n    } else {\n        if (Array.isArray(value)) {\n            const length = value.length;\n            const targetArray = new Array<unknown>(length);\n            for (let i = 0; i < length; i++) {\n                const element = value[i];\n                targetArray[i] = deepExtendValue({}, element);\n            }\n            return targetArray;\n        } else {\n            if (value === null) {\n                return null;\n            } else {\n                const valueObj = value as Record<string, unknown>;\n                if (existingTarget === undefined) {\n                    return deepExtend({}, valueObj); // overwrite\n                } else {\n                    if (typeof existingTarget !== \"object\") {\n                        return deepExtend({}, valueObj); // overwrite\n                    } else {\n                        if (Array.isArray(existingTarget)) {\n                            return deepExtend({}, valueObj); // overwrite\n                        } else {\n                            if (existingTarget === null) {\n                                return deepExtend({}, valueObj); // overwrite\n                            } else {\n                                const existingTargetObj = existingTarget as Record<string, unknown>;\n                                return deepExtend(existingTargetObj, valueObj); // merge\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/** @internal */\nexport function removeFromArray<T>(item: T, array: T[]): void {\n    const index = array.indexOf(item);\n\n    if (index === -1) {\n        throw new Error('Can\\'t remove item from array. Item is not in the array');\n    }\n\n    array.splice(index, 1);\n}\n\n/** @internal */\nexport function getUniqueId(): string {\n    return (Math.random() * 1000000000000000)\n        .toString(36)\n        .replace('.', '');\n}\n","/** @public */\nexport abstract class ExternalError extends Error {\n    /** @internal */\n    constructor(public readonly type: string, message: string) {\n        super(message);\n    }\n}\n\n/** @public */\nexport class ConfigurationError extends ExternalError {\n    /** @internal */\n    constructor(message: string, public readonly node?: string) {\n        super('Configuration', message);\n    }\n}\n\n/** @public */\nexport class PopoutBlockedError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('PopoutBlocked', message);\n    }\n}\n\n/** @public */\nexport class ApiError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('API', message);\n    }\n}\n\n/** @public */\nexport class BindError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('Bind', message);\n    }\n}\n","import { ConfigurationError } from '../errors/external-error';\nimport { AssertError, UnreachableCaseError } from '../errors/internal-error';\nimport { ItemType, JsonValue, ResponsiveMode, Side } from '../utils/types';\nimport {\n    ResolvedComponentItemConfig,\n    ResolvedHeaderedItemConfig,\n    ResolvedItemConfig,\n    ResolvedLayoutConfig,\n    ResolvedPopoutLayoutConfig,\n    ResolvedRootItemConfig,\n    ResolvedRowOrColumnItemConfig,\n    ResolvedStackItemConfig\n} from \"./resolved-config\";\n\n/** @public */\nexport interface ItemConfig {\n    /**\n     * The type of the item. Possible values are 'row', 'column', 'stack', 'component'.\n     */\n    type: ItemType;\n\n    /**\n     * An array of configurations for items that will be created as children of this item.\n     */\n    content?: ItemConfig[];\n\n    /**\n     * The width of this item, relative to the other children of its parent in percent\n     */\n    width?: number;\n\n    /**\n     * The minimum width of this item in pixels\n     * CAUTION - Not tested - do not use\n     */\n    minWidth?: number;\n\n    /**\n     * The height of this item, relative to the other children of its parent in percent\n     */\n    height?: number;\n\n    /**\n     * The minimum height of this item in pixels\n     * CAUTION - Not tested - do not use\n     */\n    minHeight?: number;\n\n    /**\n     * A string that can be used to identify a ContentItem.\n     * Do NOT assign an array.  This only exists for legacy purposes.  If an array is assigned, the first element\n     * will become the id.\n     */\n    id?: string;\n\n    /**\n     * Determines if the item is closable. If false, the x on the items tab will be hidden and container.close()\n     * will return false\n     * Default: true\n     */\n    isClosable?: boolean;\n\n    /**\n     * The title of the item as displayed on its tab and on popout windows\n     * Default: componentType.toString() or ''\n     */\n    title?: string;\n}\n\n/** @public */\nexport namespace ItemConfig {\n    export function resolve(itemConfig: ItemConfig): ResolvedItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.ground:\n                throw new ConfigurationError('ItemConfig cannot specify type ground', JSON.stringify(itemConfig));\n            case ItemType.row:\n            case ItemType.column:\n                return RowOrColumnItemConfig.resolve(itemConfig as RowOrColumnItemConfig);\n\n            case ItemType.stack:\n                return StackItemConfig.resolve(itemConfig as StackItemConfig);\n\n            case ItemType.component:\n                return ComponentItemConfig.resolve(itemConfig as ComponentItemConfig);\n\n            default:\n                throw new UnreachableCaseError('UCUICR55499', itemConfig.type);\n        }\n    }\n\n    export function resolveContent(content: ItemConfig[] | undefined): ResolvedItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const result = new Array<ResolvedItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = ItemConfig.resolve(content[i]);\n            }\n            return result;\n        }\n    }\n\n    export function resolveId(id: string | string[] | undefined): string {\n        if (id === undefined) {\n            return ResolvedItemConfig.defaults.id;\n        } else {\n            if (Array.isArray(id)) {\n                if (id.length === 0) {\n                    return ResolvedItemConfig.defaults.id;\n                } else {\n                    return id[0];\n                }\n            } else {\n                return id;\n            }\n        }\n\n    }\n\n    export function isGround(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.ground;\n    }\n    export function isRow(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.row;\n    }\n    export function isColumn(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.column;\n    }\n    export function isStack(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.stack;\n    }\n    export function isComponent(config: ItemConfig): config is ComponentItemConfig {\n        return config.type === ItemType.component;\n    }\n}\n\n// Stack or Component\n/** @public */\nexport interface HeaderedItemConfig extends ItemConfig {\n    /** @deprecated use {@link (HeaderedItemConfig:namespace).(Header:interface).show} instead */\n    hasHeaders?: boolean;\n    header?: HeaderedItemConfig.Header;\n    maximised?: boolean;\n}\n\n/** @public */\nexport namespace HeaderedItemConfig {\n    const legacyMaximisedId = '__glMaximised';\n\n    export interface Header {\n        show?: false | Side;\n        popout?: false | string;\n        dock?: false | string;\n        maximise?: false | string;\n        close?: string;\n        minimise?: string;\n        tabDropdown?: false | string;\n    }\n\n    export namespace Header {\n        export function resolve(header: Header | undefined, hasHeaders: boolean | undefined): ResolvedHeaderedItemConfig.Header | undefined {\n            if (header === undefined && hasHeaders === undefined) {\n                return undefined;\n            } else {\n                const result: ResolvedHeaderedItemConfig.Header = {\n                    show: header?.show ?? (hasHeaders === undefined ? undefined : hasHeaders ? ResolvedLayoutConfig.Header.defaults.show : false),\n                    popout: header?.popout,\n                    maximise: header?.maximise,\n                    close: header?.close,\n                    minimise: header?.minimise,\n                    tabDropdown: header?.tabDropdown,\n                }\n                return result;\n            }\n        }\n    }\n\n    export function resolveIdAndMaximised(config: HeaderedItemConfig): { id: string, maximised: boolean} {\n        let id: string;\n        // To support legacy configs with Id saved as an array of string, assign config.id to a type which includes string array\n        let legacyId: string | string[] | undefined = config.id;\n        let legacyMaximised = false;\n        if (legacyId === undefined) {\n            id = ResolvedItemConfig.defaults.id;\n        } else {\n            if (Array.isArray(legacyId)) {\n                const idx = legacyId.findIndex((id) => id === legacyMaximisedId)\n                if (idx > 0) {\n                    legacyMaximised = true;\n                    legacyId = legacyId.splice(idx, 1);\n                }\n                if (legacyId.length > 0) {\n                    id = legacyId[0];\n                } else {\n                    id = ResolvedItemConfig.defaults.id;\n                }\n            } else {\n                id = legacyId;\n            }\n        }\n\n        let maximised: boolean;\n        if (config.maximised !== undefined) {\n            maximised = config.maximised;\n        } else {\n            maximised = legacyMaximised;\n        }\n\n        return { id, maximised }\n    }\n}\n\n/** @public */\nexport interface StackItemConfig extends HeaderedItemConfig {\n    type: 'stack';\n    content: ComponentItemConfig[];\n    /** The index of the item in content which is to be active*/\n    activeItemIndex?: number;\n}\n\n/** @public */\nexport namespace StackItemConfig {\n    export function resolve(itemConfig: StackItemConfig): ResolvedStackItemConfig {\n        const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n        const result: ResolvedStackItemConfig = {\n            type: ItemType.stack,\n            content: resolveContent(itemConfig.content),\n            width: itemConfig.width ?? ResolvedItemConfig.defaults.width,\n            minWidth: itemConfig.minWidth ?? ResolvedItemConfig.defaults.minWidth,\n            height: itemConfig.height ?? ResolvedItemConfig.defaults.height,\n            minHeight: itemConfig.minHeight ?? ResolvedItemConfig.defaults.minHeight,\n            id,\n            maximised,\n            isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: itemConfig.activeItemIndex ?? ResolvedStackItemConfig.defaultActiveItemIndex,\n            header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n        };\n        return result;\n    }\n\n    export function resolveContent(content: ComponentItemConfig[] | undefined): ResolvedComponentItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const result = new Array<ResolvedComponentItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                const itemConfig = ItemConfig.resolve(childItemConfig);\n                if (!ResolvedItemConfig.isComponentItem(itemConfig)) {\n                    throw new AssertError('UCUSICRC91114', JSON.stringify(itemConfig));\n                } else {\n                    result[i] = itemConfig;\n                }\n            }\n            return result;\n        }\n    }\n}\n\n/** @public */\nexport interface ComponentItemConfig extends HeaderedItemConfig {\n    type: 'component';\n    readonly content?: [];\n    /**\n     * The type of the component.\n     * @deprecated use {@link (ComponentItemConfig:interface).componentType} instead\n     */\n    componentName?: string;\n\n    /**\n     * The type of the component.\n     * `componentType` must be of type `string` if it is registered with any of the following functions:\n     * * {@link (GoldenLayout:class).registerComponent} (deprecated)\n     * * {@link (GoldenLayout:class).registerComponentConstructor}\n     * * {@link (GoldenLayout:class).registerComponentFactoryFunction}\n     */\n    componentType: JsonValue;\n    /**\n     * The state information with which a component will be initialised with.\n     * Will be passed to the component constructor function and will be the value returned by\n     * container.initialState.\n     */\n    componentState?: JsonValue;\n\n    /**\n     * Default: true\n     */\n    reorderEnabled?: boolean;  // Takes precedence over LayoutConfig.reorderEnabled.\n}\n\n/** @public */\nexport namespace ComponentItemConfig {\n    export function resolve(itemConfig: ComponentItemConfig): ResolvedComponentItemConfig {\n        let componentType: JsonValue | undefined = itemConfig.componentType;\n        if (componentType === undefined) {\n            componentType = itemConfig.componentName;\n        }\n        if (componentType === undefined) {\n            throw new Error('ComponentItemConfig.componentType is undefined');\n        } else {\n            const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n            let title: string;\n            if (itemConfig.title === undefined || itemConfig.title === '') {\n                title = ComponentItemConfig.componentTypeToTitle(componentType);\n            } else {\n                title = itemConfig.title;\n            }\n            const result: ResolvedComponentItemConfig = {\n                type: itemConfig.type,\n                content: [],\n                width: itemConfig.width ?? ResolvedItemConfig.defaults.width,\n                minWidth: itemConfig.minWidth ?? ResolvedItemConfig.defaults.minWidth,\n                height: itemConfig.height ?? ResolvedItemConfig.defaults.height,\n                minHeight: itemConfig.minHeight ?? ResolvedItemConfig.defaults.minHeight,\n                id,\n                maximised,\n                isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n                reorderEnabled: itemConfig.reorderEnabled ?? ResolvedComponentItemConfig.defaultReorderEnabled,\n                title,\n                header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n                componentType,\n                componentState: itemConfig.componentState ?? {},\n            };\n            return result;\n        }\n    }\n\n    export function componentTypeToTitle(componentType: JsonValue): string {\n        const componentTypeType = typeof componentType;\n        switch (componentTypeType) {\n            case 'string': return componentType as string;\n            case 'number': return (componentType as number).toString();\n            case 'boolean': return (componentType as boolean).toString();\n            default: return '';\n        }\n    }\n}\n\n// RowOrColumn\n/** @public */\nexport interface RowOrColumnItemConfig extends ItemConfig {\n    type: 'row' | 'column';\n    content: (RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig)[];\n}\n\n/** @public */\nexport namespace RowOrColumnItemConfig {\n    export type ChildItemConfig = RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig;\n\n    export function isChildItemConfig(itemConfig: ItemConfig): itemConfig is ChildItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('UROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n\n    export function resolve(itemConfig: RowOrColumnItemConfig): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: itemConfig.type,\n            content: RowOrColumnItemConfig.resolveContent(itemConfig.content),\n            width: itemConfig.width ?? ResolvedItemConfig.defaults.width,\n            minWidth: itemConfig.width ?? ResolvedItemConfig.defaults.minWidth,\n            height: itemConfig.height ?? ResolvedItemConfig.defaults.height,\n            minHeight: itemConfig.height ?? ResolvedItemConfig.defaults.minHeight,\n            id: ItemConfig.resolveId(itemConfig.id),\n            isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n        }\n        return result;\n    }\n    export function resolveContent(content: ChildItemConfig[] | undefined): ResolvedRowOrColumnItemConfig.ChildItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const result = new Array<ResolvedRowOrColumnItemConfig.ChildItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                if (!RowOrColumnItemConfig.isChildItemConfig(childItemConfig)) {\n                    throw new ConfigurationError('ItemConfig is not Row, Column or Stack', childItemConfig);\n                } else {\n                    const resolvedChildItemConfig = ItemConfig.resolve(childItemConfig);\n                    if (!ResolvedRowOrColumnItemConfig.isChildItemConfig(resolvedChildItemConfig)) {\n                        throw new AssertError('UROCOSPIC99512', JSON.stringify(resolvedChildItemConfig));\n                    } else {\n                        result[i] = resolvedChildItemConfig;\n                    }\n                }\n            }\n            return result;\n        }\n    }\n}\n\n/** @public */\nexport type RootItemConfig = RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig;\n\n/** @public */\nexport namespace RootItemConfig {\n    export function isRootItemConfig(itemConfig: ItemConfig): itemConfig is RootItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('URICIR23687', itemConfig.type);\n        }\n    }\n\n    export function resolve(itemConfig: RootItemConfig | undefined): ResolvedRootItemConfig | undefined {\n        if (itemConfig === undefined) {\n            return undefined;\n        } else {\n            const result = ItemConfig.resolve(itemConfig);\n            if (!ResolvedRootItemConfig.isRootItemConfig(result)) {\n                throw new ConfigurationError('ItemConfig is not Row, Column or Stack', JSON.stringify(itemConfig));\n            } else {\n                return result;\n            }\n        }\n    }\n}\n\n/** @public */\nexport interface LayoutConfig {\n    root: RootItemConfig;\n    /** @deprecated Use {@link (LayoutConfig:interface).root} */\n    content?: (RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig)[];\n    openPopouts?: PopoutLayoutConfig[];\n    dimensions?: LayoutConfig.Dimensions;\n    settings?: LayoutConfig.Settings;\n    /** @deprecated use {@link (LayoutConfig:interface).header} instead */\n    labels?: LayoutConfig.Labels;\n    header?: LayoutConfig.Header;\n}\n\n/** Use to specify LayoutConfig with defaults or deserialise a LayoutConfig.\n * Deserialisation will handle backwards compatibility.\n * Note that LayoutConfig should be used for serialisation (not LayoutConfig)\n * @public\n */\nexport namespace LayoutConfig {\n    export interface Settings {\n        /**\n         * @deprecated use ${@link (LayoutConfig:namespace).(Header:interface).show} instead\n         */\n        hasHeaders?: boolean;\n\n        /**\n         * Constrains the area in which items can be dragged to the layout's container. Will be set to false\n         * automatically when layout.createDragSource() is called.\n         * Default: true\n         */\n        constrainDragToContainer?: boolean;\n\n        /**\n         * If true, the user can re-arrange the layout by dragging items by their tabs to the desired location.\n         * Can be overridden by ItemConfig.reorderEnabled for specific ItemConfigs\n         * Default: true\n         */\n        reorderEnabled?: boolean;\n\n        /**\n         * Decides what will be opened in a new window if the user clicks the popout icon. If true the entire stack will\n         * be transferred to the new window, if false only the active component will be opened.\n         * Default: false\n         */\n        popoutWholeStack?: boolean;\n\n        /**\n         * Specifies if an error is thrown when a popout is blocked by the browser (e.g. by opening it programmatically).\n         * If false, the popout call will fail silently.\n         * Default: true\n         */\n        blockedPopoutsThrowError?: boolean;\n\n        /**\n         * Specifies if all popouts should be closed when the page that created them is closed. Popouts don't have a\n         * strong dependency on their parent and can exist on their own, but can be quite annoying to close by hand. In\n         * addition, any changes made to popouts won't be stored after the parent is closed.\n         * Default: true\n         */\n        closePopoutsOnUnload?: boolean;\n\n        /**\n         * Specifies if the popout icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popout} instead\n         */\n        showPopoutIcon?: boolean;\n\n        /**\n         * Specifies if the maximise icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).maximise} instead\n         */\n        showMaximiseIcon?: boolean;\n\n        /**\n         * Specifies if the close icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).close} instead\n         */\n        showCloseIcon?: boolean;\n\n        /**\n         * Specifies Responsive Mode (more info needed).\n         * Default: none\n         */\n        responsiveMode?: ResponsiveMode;\n\n        /**\n         * Specifies Maximum pixel overlap per tab.\n         * Default: 0\n         */\n        tabOverlapAllowance?: number;\n\n        /**\n         *\n         * Default: true\n         */\n        reorderOnTabMenuClick?: boolean;\n\n        /**\n         * Default: 10\n         */\n        tabControlOffset?: number;\n\n        /**\n         * Specifies whether to pop in elements when closing a popout window.\n         * Default: false\n         */\n        popInOnClose?: boolean;\n    }\n\n    export namespace Settings {\n        export function resolve(settings: Settings | undefined): ResolvedLayoutConfig.Settings {\n            const result: ResolvedLayoutConfig.Settings = {\n                constrainDragToContainer: settings?.constrainDragToContainer ?? ResolvedLayoutConfig.Settings.defaults.constrainDragToContainer,\n                reorderEnabled: settings?.reorderEnabled ?? ResolvedLayoutConfig.Settings.defaults.reorderEnabled,\n                popoutWholeStack: settings?.popoutWholeStack ?? ResolvedLayoutConfig.Settings.defaults.popoutWholeStack,\n                blockedPopoutsThrowError: settings?.blockedPopoutsThrowError ?? ResolvedLayoutConfig.Settings.defaults.blockedPopoutsThrowError,\n                closePopoutsOnUnload: settings?.closePopoutsOnUnload ?? ResolvedLayoutConfig.Settings.defaults.closePopoutsOnUnload,\n                responsiveMode: settings?.responsiveMode ?? ResolvedLayoutConfig.Settings.defaults.responsiveMode,\n                tabOverlapAllowance: settings?.tabOverlapAllowance ?? ResolvedLayoutConfig.Settings.defaults.tabOverlapAllowance,\n                reorderOnTabMenuClick: settings?.reorderOnTabMenuClick ?? ResolvedLayoutConfig.Settings.defaults.reorderOnTabMenuClick,\n                tabControlOffset: settings?.tabControlOffset ?? ResolvedLayoutConfig.Settings.defaults.tabControlOffset,\n                popInOnClose: settings?.popInOnClose ?? ResolvedLayoutConfig.Settings.defaults.popInOnClose,\n            }\n            return result;\n        }\n    }\n\n    export interface Dimensions {\n        /**\n         * The width of the borders between the layout items in pixel. Please note: The actual draggable area is wider\n         * than the visible one, making it safe to set this to small values without affecting usability.\n         * Default: 5\n         */\n        borderWidth?: number;\n\n        /**\n         * Default: 15\n         */\n        borderGrabWidth?: number,\n\n        /**\n         * The minimum height an item can be resized to (in pixel).\n         * Default: 10\n         */\n        minItemHeight?: number;\n\n        /**\n         * The minimum width an item can be resized to (in pixel).\n         * Default: 10\n         */\n        minItemWidth?: number;\n\n        /**\n         * The height of the header elements in pixel. This can be changed, but your theme's header css needs to be\n         * adjusted accordingly.\n         * Default: 20\n         */\n        headerHeight?: number;\n\n        /**\n         * The width of the element that appears when an item is dragged (in pixel).\n         * Default: 300\n         */\n        dragProxyWidth?: number;\n\n        /**\n         * The height of the element that appears when an item is dragged (in pixel).\n         * Default: 200\n         */\n        dragProxyHeight?: number;\n    }\n\n    export namespace Dimensions {\n        export function resolve(dimensions: Dimensions | undefined): ResolvedLayoutConfig.Dimensions {\n            const result: ResolvedLayoutConfig.Dimensions = {\n                borderWidth: dimensions?.borderWidth ?? ResolvedLayoutConfig.Dimensions.defaults.borderWidth,\n                borderGrabWidth: dimensions?.borderGrabWidth ?? ResolvedLayoutConfig.Dimensions.defaults.borderGrabWidth,\n                minItemHeight: dimensions?.minItemHeight ?? ResolvedLayoutConfig.Dimensions.defaults.minItemHeight,\n                minItemWidth: dimensions?.minItemWidth ?? ResolvedLayoutConfig.Dimensions.defaults.minItemWidth,\n                headerHeight: dimensions?.headerHeight ?? ResolvedLayoutConfig.Dimensions.defaults.headerHeight,\n                dragProxyWidth: dimensions?.dragProxyWidth ?? ResolvedLayoutConfig.Dimensions.defaults.dragProxyWidth,\n                dragProxyHeight: dimensions?.dragProxyHeight ?? ResolvedLayoutConfig.Dimensions.defaults.dragProxyHeight,\n            }\n            return result;\n        }\n    }\n\n    export interface Labels {\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).close} instead\n         */\n        close?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).maximise} instead\n         */\n        maximise?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).minimise} instead\n         */\n        minimise?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popin} instead\n         */\n        popin?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popout} instead\n         */\n        popout?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).tabDropdown} instead\n         */\n        tabDropdown?: string;\n    }\n\n    export interface Header {\n        /**\n         * Specifies whether header should be displayed, and if so, on which side.\n         * If false, the layout will be displayed with splitters only.\n         * Default: 'top'\n         */\n        show?: false | Side;\n        /**\n         * The tooltip text that appears when hovering over the popout icon or false if popout button not displayed.\n         * Default: 'open in new window'\n         */\n        popout?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the popin icon.\n         * Default: 'pop in'\n         */\n        popin?: string;\n        /**\n         * The tooltip text that appears when hovering over the maximise icon or false if maximised button not displayed.\n         * Default: 'maximise'\n         */\n        maximise?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the close icon.\n         * Default: 'close'\n         */\n        close?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the minimise icon.\n         * Default: 'minimise'\n         */\n        minimise?: string;\n        /**\n         *\n         * Default: 'additional tabs'\n         */\n        tabDropdown?: false | string;\n    }\n\n    export namespace Header {\n        export function resolve(header: Header | undefined,\n            settings: LayoutConfig.Settings | undefined, labels: LayoutConfig.Labels | undefined\n        ): ResolvedLayoutConfig.Header {\n            let show: false | Side;\n            if (header?.show !== undefined) {\n                show = header.show;\n            } else {\n                if (settings !== undefined && settings.hasHeaders !== undefined) {\n                    show = settings.hasHeaders ? ResolvedLayoutConfig.Header.defaults.show : false;\n                } else {\n                    show = ResolvedLayoutConfig.Header.defaults.show;\n                }\n            }\n            const result: ResolvedLayoutConfig.Header = {\n                show,\n                popout: header?.popout ?? labels?.popout ??\n                    (settings?.showPopoutIcon === false ? false : ResolvedLayoutConfig.Header.defaults.popout),\n                dock: header?.popin ?? labels?.popin ?? ResolvedLayoutConfig.Header.defaults.dock,\n                maximise: header?.maximise ?? labels?.maximise ??\n                    (settings?.showMaximiseIcon === false ? false : ResolvedLayoutConfig.Header.defaults.maximise),\n                close: header?.close ?? labels?.close ??\n                    (settings?.showCloseIcon === false ? false : ResolvedLayoutConfig.Header.defaults.close),\n                minimise: header?.minimise ?? labels?.minimise ?? ResolvedLayoutConfig.Header.defaults.minimise,\n                tabDropdown: header?.tabDropdown ?? labels?.tabDropdown ?? ResolvedLayoutConfig.Header.defaults.tabDropdown,\n            }\n            return result;\n        }\n    }\n\n    export function isPopout(config: LayoutConfig): config is PopoutLayoutConfig {\n        return 'parentId' in config || 'indexInParent' in config || 'window' in config;\n    }\n\n    export function resolve(layoutConfig: LayoutConfig): ResolvedLayoutConfig {\n        if (isPopout(layoutConfig)) {\n            return PopoutLayoutConfig.resolve(layoutConfig);\n        } else {\n            let root: RootItemConfig | undefined;\n            if (layoutConfig.root !== undefined) {\n                root = layoutConfig.root;\n            } else {\n                if (layoutConfig.content !== undefined && layoutConfig.content.length > 0) {\n                    root = layoutConfig.content[0];\n                } else {\n                    root = undefined;\n                }\n            }\n            const config: ResolvedLayoutConfig = {\n                resolved: true,\n                root: RootItemConfig.resolve(root),\n                openPopouts: LayoutConfig.resolveOpenPopouts(layoutConfig.openPopouts),\n                dimensions: LayoutConfig.Dimensions.resolve(layoutConfig.dimensions),\n                settings: LayoutConfig.Settings.resolve(layoutConfig.settings),\n                header: LayoutConfig.Header.resolve(layoutConfig.header, layoutConfig.settings, layoutConfig.labels),\n            }\n            return config;\n        }\n    }\n\n    export function fromResolved(config: ResolvedLayoutConfig): LayoutConfig {\n        const copiedConfig = ResolvedLayoutConfig.createCopy(config);\n        const result: LayoutConfig = {\n            root: copiedConfig.root as RootItemConfig,\n            openPopouts: copiedConfig.openPopouts as unknown as PopoutLayoutConfig[],\n            dimensions: copiedConfig.dimensions,\n            settings: copiedConfig.settings,\n            header: copiedConfig.header,\n        };\n        return result;\n    }\n\n    export function isResolved(configOrResolvedConfig: ResolvedLayoutConfig | LayoutConfig): configOrResolvedConfig is ResolvedLayoutConfig {\n        const config = configOrResolvedConfig as ResolvedLayoutConfig;\n        return config.resolved !== undefined && (config.resolved === true);\n    }\n\n    export function resolveOpenPopouts(popoutConfigs: PopoutLayoutConfig[] | undefined): ResolvedPopoutLayoutConfig[] {\n        if (popoutConfigs === undefined) {\n            return [];\n        } else {\n            const count = popoutConfigs.length;\n            const result = new Array<ResolvedPopoutLayoutConfig>(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = PopoutLayoutConfig.resolve(popoutConfigs[i]);\n            }\n            return result;\n        }\n    }\n}\n\n/** @public */\nexport interface PopoutLayoutConfig extends LayoutConfig {\n    /** The id of the element the item will be appended to on popIn\n    * If null, append to topmost layout element\n    */\n    parentId: string | null | undefined;\n    /** The position of this element within its parent\n    * If null, position is last\n    */\n    indexInParent: number | null | undefined;\n    /** @deprecated use {@link (PopoutLayoutConfig:interface).window} */\n    dimensions: PopoutLayoutConfig.Dimensions | undefined; // for backwards compatibility\n    window: PopoutLayoutConfig.Window | undefined;\n}\n\n/** @public */\nexport namespace PopoutLayoutConfig {\n    // Previous versions kept window information in Dimensions key.  Only use for backwards compatibility\n    /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface)} */\n    export interface Dimensions extends LayoutConfig.Dimensions {\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).width} */\n        width: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).height} */\n        height: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).left} */\n        left: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).top} */\n        top: number | null,\n    }\n\n    export interface Window {\n        width?: number,\n        height?: number,\n        left?: number,\n        top?: number,\n    }\n\n    export namespace Window {\n        export function resolve(window: Window | undefined,\n            dimensions: Dimensions | undefined): ResolvedPopoutLayoutConfig.Window\n        {\n            let result: ResolvedPopoutLayoutConfig.Window;\n            const defaults = ResolvedPopoutLayoutConfig.Window.defaults;\n            if (window !== undefined) {\n                result = {\n                    width: window.width ?? defaults.width,\n                    height: window.height ?? defaults.height,\n                    left: window.left ?? defaults.left,\n                    top: window.top ?? defaults.top,\n                }\n            } else {\n                result = {\n                    width: dimensions?.width ?? defaults.width,\n                    height: dimensions?.height ?? defaults.height,\n                    left: dimensions?.left ?? defaults.left,\n                    top: dimensions?.top ?? defaults.top,\n                }\n            }\n            return result;\n        }\n    }\n\n    export function resolve(popoutConfig: PopoutLayoutConfig): ResolvedPopoutLayoutConfig {\n        let root: RootItemConfig | undefined;\n        if (popoutConfig.root !== undefined) {\n            root = popoutConfig.root;\n        } else {\n            if (popoutConfig.content !== undefined && popoutConfig.content.length > 0) {\n                root = popoutConfig.content[0];\n            } else {\n                root = undefined;\n            }\n        }\n\n        const config: ResolvedPopoutLayoutConfig = {\n            root: RootItemConfig.resolve(root),\n            openPopouts: LayoutConfig.resolveOpenPopouts(popoutConfig.openPopouts),\n            settings: LayoutConfig.Settings.resolve(popoutConfig.settings),\n            dimensions: LayoutConfig.Dimensions.resolve(popoutConfig.dimensions),\n            header: LayoutConfig.Header.resolve(popoutConfig.header, popoutConfig.settings, popoutConfig.labels),\n            parentId: popoutConfig.parentId ?? null,\n            indexInParent: popoutConfig.indexInParent ?? null,\n            window: PopoutLayoutConfig.Window.resolve(popoutConfig.window, popoutConfig.dimensions),\n            resolved: true,\n        }\n        return config;\n    }\n}\n\n/** @public @deprecated - use {@link (LayoutConfig:interface)} */\nexport type Config = LayoutConfig;\n","import { BrowserPopout } from '../controls/browser-popout';\nimport { Tab } from '../controls/tab';\nimport { ComponentItem } from '../items/component-item';\n\n/**\n * A generic and very fast EventEmitter implementation. On top of emitting the actual event it emits an\n * {@link (EventEmitter:namespace).ALL_EVENT} event for every event triggered. This allows to hook into it and proxy events forwards\n * @public\n */\nexport class EventEmitter {\n    /** @internal */\n    private _allEventSubscriptions: EventEmitter.UnknownCallback[] = [];\n    /** @internal */\n    private _subscriptionsMap = new Map<string, EventEmitter.UnknownCallback[]>();\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tryBubbleEvent(name: string, args: unknown[]): void {\n        // overridden by ContentItem\n    }\n\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     */\n    emit<K extends keyof EventEmitter.EventParamsMap>(eventName: K, ...args: EventEmitter.EventParamsMap[K]): void {\n        let subcriptions = this._subscriptionsMap.get(eventName);\n\n        if (subcriptions !== undefined) {\n            subcriptions = subcriptions.slice();\n            for (let i = 0; i < subcriptions.length; i++) {\n                const subscription = subcriptions[i];\n                subscription(...args);\n            }\n        }\n\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n\n    /** @internal */\n    emitUnknown(eventName: string, ...args: EventEmitter.UnknownParams): void {\n        let subs = this._subscriptionsMap.get(eventName);\n\n        if (subs !== undefined) {\n            subs = subs.slice();\n            for (let i = 0; i < subs.length; i++) {\n                subs[i](...args);\n            }\n        }\n\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n\n    /* @internal **/\n    emitBaseBubblingEvent<K extends keyof EventEmitter.EventParamsMap>(eventName: K): void {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n\n    /** @internal */\n    emitUnknownBubblingEvent(eventName: string): void {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n\n    /**\n     * Removes a listener for an event.\n     * @param eventName - The name of the event\n     * @param callback - The previously registered callback method (optional)\n     */\n    removeEventListener<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        const unknownCallback = callback as EventEmitter.UnknownCallback;\n        this.removeUnknownEventListener(eventName, unknownCallback);\n    }\n\n    off<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this.removeEventListener(eventName, callback);\n    }\n\n    /**\n     * Alias for off\n     */\n    unbind = this.removeEventListener;\n\n    /**\n     * Alias for emit\n     */\n    trigger = this.emit;\n\n    /**\n     * Listen for events\n     *\n     * @param eventName - The name of the event to listen to\n     * @param callback - The callback to execute when the event occurs\n     */\n    addEventListener<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        const unknownCallback = callback as EventEmitter.UnknownCallback;\n        this.addUnknownEventListener(eventName, unknownCallback);\n    }\n\n    on<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this.addEventListener(eventName, callback);\n    }\n\n    /** @internal */\n    private addUnknownEventListener(eventName: string, callback: EventEmitter.UnknownCallback): void {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this._allEventSubscriptions.push(callback);\n        } else {\n            let subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions !== undefined) {\n                subscriptions.push(callback);\n            } else {\n                subscriptions = [callback];\n                this._subscriptionsMap.set(eventName, subscriptions);\n            }\n        }\n    }\n\n    /** @internal */\n    private removeUnknownEventListener(eventName: string, callback: EventEmitter.UnknownCallback): void {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this.removeSubscription(eventName, this._allEventSubscriptions, callback);\n        } else {\n            const subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions === undefined) {\n                throw new Error('No subscribtions to unsubscribe for event ' + eventName);\n            } else {\n                this.removeSubscription(eventName, subscriptions, callback);\n            }\n        }\n    }\n\n    /** @internal */\n    private removeSubscription(eventName: string, subscriptions: EventEmitter.UnknownCallback[], callback: EventEmitter.UnknownCallback) {\n        const idx = subscriptions.indexOf(callback);\n        if (idx < 0) {\n            throw new Error('Nothing to unbind for ' + eventName);\n        } else {\n            subscriptions.splice(idx, 1);\n        }\n    }\n\n    /** @internal */\n    private emitAllEvent(eventName: string, args: unknown[]) {\n        const allEventSubscriptionsCount = this._allEventSubscriptions.length;\n        if (allEventSubscriptionsCount > 0) {\n            const unknownArgs = args.slice() as EventEmitter.UnknownParams;\n            unknownArgs.unshift(eventName);\n\n            const allEventSubcriptions = this._allEventSubscriptions.slice();\n\n            for (let i = 0; i < allEventSubscriptionsCount; i++) {\n                allEventSubcriptions[i](...unknownArgs);\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace EventEmitter {\n    /**\n     * The name of the event that's triggered for every event\n     */\n    export const ALL_EVENT = '__all';\n\n    export const headerClickEventName = 'stackHeaderClick';\n    export const headerTouchStartEventName = 'stackHeaderTouchStart';\n\n    /** @internal */\n    export type UnknownCallback = (this: void, ...args: UnknownParams) => void;\n    export type Callback<K extends keyof EventEmitter.EventParamsMap> = (this: void, ...args: EventParamsMap[K]) => void;\n\n    export interface EventParamsMap {\n        \"__all\": UnknownParams;\n        \"activeContentItemChanged\": ComponentItemParam;\n        \"close\": NoParams;\n        \"closed\": NoParams;\n        \"destroy\": NoParams;\n        \"drag\": DragParams;\n        \"dragStart\": DragStartParams;\n        \"dragStop\": DragStopParams;\n        \"hide\": NoParams;\n        \"initialised\": NoParams;\n        \"itemDropped\": ComponentItemParam;\n        \"maximised\": NoParams;\n        \"minimised\": NoParams;\n        \"open\": NoParams;\n        \"popIn\": NoParams;\n        \"resize\": NoParams;\n        \"show\": NoParams;\n        /** @deprecated - use show instead */\n        \"shown\": NoParams;\n        \"stateChanged\": NoParams;\n        \"tab\": TabParam;\n        \"tabCreated\": TabParam;\n        \"titleChanged\": StringParam;\n        \"windowClosed\": PopoutParam;\n        \"windowOpened\": PopoutParam;\n        \"beforeComponentRelease\": BeforeComponentReleaseParams;\n        \"beforeItemDestroyed\": BubblingEventParam;\n        \"itemCreated\": BubblingEventParam;\n        \"itemDestroyed\": BubblingEventParam;\n        \"focus\": BubblingEventParam;\n        \"blur\": BubblingEventParam;\n        \"stackHeaderClick\": ClickBubblingEventParam;\n        \"stackHeaderTouchStart\": TouchStartBubblingEventParam;\n        \"userBroadcast\": UnknownParams;\n    }\n\n    export type UnknownParams = unknown[];\n    export type NoParams = [];\n    export type UnknownParam = [unknown];\n    export type PopoutParam = [BrowserPopout];\n    export type ComponentItemParam = [ComponentItem];\n    export type TabParam = [Tab];\n    export type BubblingEventParam = [EventEmitter.BubblingEvent]\n    export type StringParam = [string];\n    export type DragStartParams = [originalX: number, originalY: number];\n    export type DragStopParams = [event: PointerEvent | undefined];\n    export type DragParams = [offsetX: number, offsetY: number, event: PointerEvent];\n    export type BeforeComponentReleaseParams = [component: unknown];\n    export type ClickBubblingEventParam = [ClickBubblingEvent];\n    export type TouchStartBubblingEventParam = [TouchStartBubblingEvent];\n\n    export class BubblingEvent {\n        /** @internal */\n        private _isPropagationStopped = false;\n\n        get name(): string { return this._name; }\n        get target(): EventEmitter { return this._target; }\n        /** @deprecated Use {@link (EventEmitter:namespace).(BubblingEvent:class).target} instead */\n        get origin(): EventEmitter { return this._target; }\n        get isPropagationStopped(): boolean { return this._isPropagationStopped; }\n\n        /** @internal */\n        constructor(\n            /** @internal */\n            private readonly _name: string,\n            /** @internal */\n            private readonly _target: EventEmitter) {\n        }\n\n        stopPropagation(): void {\n            this._isPropagationStopped = true;\n        }\n    }\n\n    export class ClickBubblingEvent extends BubblingEvent {\n        get mouseEvent(): MouseEvent { return this._mouseEvent; }\n\n        /** @internal */\n        constructor(name: string, target: EventEmitter,\n            /** @internal */\n            private readonly _mouseEvent: MouseEvent\n        ) {\n            super(name, target);\n        }\n    }\n\n    export class TouchStartBubblingEvent extends BubblingEvent {\n        get touchEvent(): TouchEvent { return this._touchEvent; }\n\n        /** @internal */\n        constructor(name: string, target: EventEmitter,\n            /** @internal */\n            private readonly _touchEvent: TouchEvent\n        ) {\n            super(name, target);\n        }\n    }\n}\n","import { ResolvedLayoutConfig, ResolvedPopoutLayoutConfig } from '../config/resolved-config';\nimport { PopoutBlockedError } from '../errors/external-error';\nimport { UnexpectedNullError, UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ContentItem } from '../items/content-item';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Rect } from '../utils/types';\nimport { deepExtend, getUniqueId } from '../utils/utils';\n\n/**\n * Pops a content item out into a new browser window.\n * This is achieved by\n *\n *    - Creating a new configuration with the content item as root element\n *    - Serializing and minifying the configuration\n *    - Opening the current window's URL with the configuration as a GET parameter\n *    - GoldenLayout when opened in the new window will look for the GET parameter\n *      and use it instead of the provided configuration\n * @public\n */\n\nexport class BrowserPopout extends EventEmitter {\n    /** @internal */\n    private _popoutWindow: Window | null;\n    /** @internal */\n    private _isInitialised;\n    /** @internal */\n    private _checkReadyInterval: ReturnType<typeof setTimeout> | undefined;\n\n    /**\n     * @param _config - GoldenLayout item config\n     * @param _initialWindowSize - A map with width, height, top and left\n     * @internal\n     */\n    constructor(\n        /** @internal */\n        private _config: ResolvedPopoutLayoutConfig,\n        /** @internal */\n        private _initialWindowSize: Rect,\n        /** @internal */\n        private _layoutManager: LayoutManager,\n    ) {\n        super();\n\n        this._isInitialised = false;\n        this._popoutWindow = null;\n        this.createWindow();\n    }\n\n    toConfig(): ResolvedPopoutLayoutConfig {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        }\n\n        const glInstance = this.getGlInstance();\n        const glInstanceConfig = glInstance.saveLayout();\n\n        let left: number | null;\n        let top: number | null;\n        if (this._popoutWindow === null) {\n            left = null;\n            top = null;\n        } else {\n            left = this._popoutWindow.screenX ?? this._popoutWindow.screenLeft;\n            top = this._popoutWindow.screenY ?? this._popoutWindow.screenTop;\n        }\n\n        const window: ResolvedPopoutLayoutConfig.Window = {\n            width: this.getGlInstance().width,\n            height: this.getGlInstance().height,\n            left,\n            top,\n        };\n\n        const config: ResolvedPopoutLayoutConfig = {\n            root: glInstanceConfig.root,\n            openPopouts: glInstanceConfig.openPopouts,\n            settings: glInstanceConfig.settings,\n            dimensions: glInstanceConfig.dimensions,\n            header: glInstanceConfig.header,\n            window,\n            parentId: this._config.parentId,\n            indexInParent: this._config.indexInParent,\n            resolved: true,\n        };\n\n        return config;\n    }\n\n    getGlInstance(): LayoutManager {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPGGI24693');\n        }\n        return this._popoutWindow.__glInstance;\n    }\n\n    /**\n     * Retrieves the native BrowserWindow backing this popout.\n     * Might throw an UnexpectedNullError exception when the window is not initialized yet.\n     * @public\n     */\n    getWindow(): Window {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPGW087215');\n        }\n        return this._popoutWindow;\n    }\n\n    close(): void {\n        if (this.getGlInstance()) {\n            this.getGlInstance().closeWindow();\n        } else {\n            try {\n                this.getWindow().close();\n            } catch (e) {\n                //\n            }\n        }\n    }\n\n    /**\n     * Returns the popped out item to its original position. If the original\n     * parent isn't available anymore it falls back to the layout's topmost element\n     */\n    popIn(): void {\n        let parentItem: ContentItem;\n        let index = this._config.indexInParent;\n\n        if (!this._config.parentId) {\n            return;\n        }\n\n        /*\n        * The deepExtend call seems a bit pointless, but it's crucial to\n        * copy the config returned by this.getGlInstance().toConfig()\n        * onto a new object. Internet Explorer keeps the references\n        * to objects on the child window, resulting in the following error\n        * once the child window is closed:\n        *\n        * The callee (server [not server application]) is not available and disappeared\n        */\n        const glInstanceLayoutConfig = this.getGlInstance().saveLayout();\n        const copiedGlInstanceLayoutConfig = deepExtend({}, glInstanceLayoutConfig) as ResolvedLayoutConfig;\n        const copiedRoot = copiedGlInstanceLayoutConfig.root;\n        if (copiedRoot === undefined) {\n            throw new UnexpectedUndefinedError('BPPIR19998');\n        }\n        const groundItem = this._layoutManager.groundItem;\n        if (groundItem === undefined) {\n            throw new UnexpectedUndefinedError('BPPIG34972');\n        }\n        parentItem = groundItem.getItemsByPopInParentId(this._config.parentId)[0];\n\n        /*\n        * Fallback if parentItem is not available. Either add it to the topmost\n        * item or make it the topmost item if the layout is empty\n        */\n        if (!parentItem) {\n            if (groundItem.contentItems.length > 0) {\n                parentItem = groundItem.contentItems[0];\n            } else {\n                parentItem = groundItem;\n            }\n            index = 0;\n        }\n\n        const newContentItem = this._layoutManager.createAndInitContentItem(copiedRoot, parentItem);\n\n        parentItem.addChild(newContentItem, index);\n        if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n            this._onClose();\n        } else {\n            this.close();\n        }\n    }\n\n    /**\n     * Creates the URL and window parameter\n     * and opens a new window\n     * @internal\n     */\n    private createWindow(): void {\n        const url = this.createUrl();\n\n        /**\n         * Bogus title to prevent re-usage of existing window with the\n         * same title. The actual title will be set by the new window's\n         * GoldenLayout instance if it detects that it is in subWindowMode\n         */\n        const target = Math.floor(Math.random() * 1000000).toString(36);\n\n        /**\n         * The options as used in the window.open string\n         */\n        const features = this.serializeWindowFeatures({\n            width: this._initialWindowSize.width,\n            height: this._initialWindowSize.height,\n            innerWidth: this._initialWindowSize.width,\n            innerHeight: this._initialWindowSize.height,\n            menubar: 'no',\n            toolbar: 'no',\n            location: 'no',\n            personalbar: 'no',\n            resizable: 'yes',\n            scrollbars: 'no',\n            status: 'no'\n        });\n\n        this._popoutWindow = globalThis.open(url, target, features);\n\n        if (!this._popoutWindow) {\n            if (this._layoutManager.layoutConfig.settings.blockedPopoutsThrowError === true) {\n                const error = new PopoutBlockedError('Popout blocked');\n                throw error;\n            } else {\n                return;\n            }\n        }\n\n        this._popoutWindow.addEventListener('load', () => this.positionWindow(), { passive: true })\n        this._popoutWindow.addEventListener('beforeunload', () => {\n            if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n                this.popIn();\n            } else {\n                this._onClose();\n            }\n        }, { passive: true })\n\n        /**\n         * Polling the childwindow to find out if GoldenLayout has been initialised\n         * doesn't seem optimal, but the alternatives - adding a callback to the parent\n         * window or raising an event on the window object - both would introduce knowledge\n         * about the parent to the child window which we'd rather avoid\n         */\n        this._checkReadyInterval = setInterval(() => this.checkReady(), 10);\n    }\n\n    /** @internal */\n    private checkReady() {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPCR01844');\n        } else {\n            if (this._popoutWindow.__glInstance && this._popoutWindow.__glInstance.isInitialised) {\n                this.onInitialised();\n                if (this._checkReadyInterval !== undefined) {\n                    clearInterval(this._checkReadyInterval);\n                    this._checkReadyInterval = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * Serialises a map of key:values to a window options string\n     *\n     * @param windowOptions -\n     *\n     * @returns serialised window options\n     * @internal\n     */\n    private serializeWindowFeatures(windowOptions: Record<string, string | number>): string {\n        const windowOptionsString: string[] = [];\n\n        for (const key in windowOptions) {\n            windowOptionsString.push(key + '=' + windowOptions[key].toString());\n        }\n\n        return windowOptionsString.join(',');\n    }\n\n    /**\n     * Creates the URL for the new window, including the\n     * config GET parameter\n     *\n     * @returns URL\n     * @internal\n     */\n    private createUrl(): string {\n        const storageKey = 'gl-window-config-' + getUniqueId();\n        const config = ResolvedLayoutConfig.minifyConfig(this._config);\n\n        try {\n            localStorage.setItem(storageKey, JSON.stringify(config));\n        } catch (e) {\n            throw new Error('Error while writing to localStorage ' + e.toString());\n        }\n\n        const url = new URL(location.href);\n        url.searchParams.set('gl-window', storageKey);\n        return url.toString();\n    }\n\n    /**\n     * Move the newly created window roughly to\n     * where the component used to be.\n     * @internal\n     */\n    private positionWindow() {\n        if (this._popoutWindow === null) {\n            throw new Error('BrowserPopout.positionWindow: null popoutWindow');\n        } else {\n            this._popoutWindow.moveTo(this._initialWindowSize.left, this._initialWindowSize.top);\n            this._popoutWindow.focus();\n        }\n    }\n\n    /**\n     * Callback when the new window is opened and the GoldenLayout instance\n     * within it is initialised\n     * @internal\n     */\n    private onInitialised(): void {\n        this._isInitialised = true;\n        this.getGlInstance().on('popIn', () => this.popIn());\n        this.emit('initialised');\n    }\n\n    /**\n     * Invoked 50ms after the window unload event\n     * @internal\n     */\n    private _onClose() {\n        setTimeout(() => this.emit('closed'), 50);\n    }\n}\n","import { Header } from './header';\n\n/** @internal */\nexport class HeaderButton {\n    private _element: HTMLElement;\n    private _clickEventListener = (ev: MouseEvent) => this.onClick(ev);\n    private _touchStartEventListener = (ev: TouchEvent) => this.onTouchStart(ev);\n\n    get element(): HTMLElement { return this._element; }\n\n    constructor(private _header: Header, label: string, cssClass: string, private _pushEvent: HeaderButton.PushEvent) {\n        this._element = document.createElement('div');\n        this._element.classList.add(cssClass);\n        this._element.title = label;\n        this._header.on('destroy', () => this.destroy());\n        this._element.addEventListener('click', this._clickEventListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartEventListener, { passive: true });\n        this._header.controlsContainerElement.appendChild(this._element);\n    }\n\n    destroy(): void {\n        this._element.removeEventListener('click', this._clickEventListener);\n        this._element.removeEventListener('touchstart', this._touchStartEventListener);\n        this._element.parentNode?.removeChild(this._element);\n    }\n\n    private onClick(ev: MouseEvent) {\n        this._pushEvent(ev);\n    }\n\n    private onTouchStart(ev: TouchEvent) {\n        this._pushEvent(ev);\n    }\n}\n\n/** @internal */\nexport namespace HeaderButton {\n    export type PushEvent = (this: void, ev: Event) => void;\n}\n","import { DomConstants } from './dom-constants';\nimport { EventEmitter } from './event-emitter';\n\n/** @internal */\nexport class DragListener extends EventEmitter {\n    private _timeout: ReturnType<typeof setTimeout> | undefined;\n    private _allowableTargets: HTMLElement[];\n    private _oDocument: Document;\n    private _eBody: HTMLElement;\n    private _nDelay: number;\n    private _nDistance: number;\n    private _nX: number;\n    private _nY: number;\n    private _nOriginalX: number;\n    private _nOriginalY: number;\n    private _dragging: boolean;\n    private _pointerTracking = false;\n\n    private _pointerDownEventListener = (ev: PointerEvent) => this.onPointerDown(ev);\n    private _pointerMoveEventListener = (ev: PointerEvent) => this.onPointerMove(ev);\n    private _pointerUpEventListener = (ev: PointerEvent) => this.onPointerUp(ev);\n\n    constructor(private _eElement: HTMLElement, extraAllowableChildTargets: HTMLElement[]) {\n        super();\n\n        this._timeout = undefined;\n\n        this._allowableTargets = [_eElement, ...extraAllowableChildTargets];\n        this._oDocument = document;\n        this._eBody = document.body;\n\n        /**\n         * The delay after which to start the drag in milliseconds\n         * Do NOT make too short (previous value of 200 was not long enough for my touchpad)\n         * Should generally rely on the mouse move to start drag.  Not this delay.\n         */\n        this._nDelay = 1800;\n\n        /**\n         * The distance the mouse needs to be moved to qualify as a drag\n         * Previous comment: works better with delay only\n         * ???\n         * Probably somehow needs tuning for different devices\n         */\n        this._nDistance = 10;\n\n        this._nX = 0;\n        this._nY = 0;\n\n        this._nOriginalX = 0;\n        this._nOriginalY = 0;\n\n        this._dragging = false;\n\n        this._eElement.addEventListener('pointerdown', this._pointerDownEventListener, { passive: true });\n    }\n\n    destroy(): void {\n        this.checkRemovePointerTrackingEventListeners();\n\n        this._eElement.removeEventListener('pointerdown', this._pointerDownEventListener);\n    }\n\n    cancelDrag(): void {\n        this.processDragStop(undefined);\n    }\n\n    private onPointerDown(oEvent: PointerEvent) {\n        if (this._allowableTargets.includes(oEvent.target as HTMLElement) && oEvent.isPrimary) {\n            const coordinates = this.getPointerCoordinates(oEvent);\n            this.processPointerDown(coordinates);\n        }\n    }\n\n    private processPointerDown(coordinates: DragListener.PointerCoordinates) {\n        this._nOriginalX = coordinates.x;\n        this._nOriginalY = coordinates.y;\n\n        this._oDocument.addEventListener('pointermove', this._pointerMoveEventListener);\n        this._oDocument.addEventListener('pointerup', this._pointerUpEventListener, { passive: true });\n        this._pointerTracking = true;\n\n        this._timeout = setTimeout(\n            () => {\n                try {\n                    this.startDrag()\n                }\n                catch (err) {\n                    console.error(err);\n                    throw err;\n                }\n            }\n            , this._nDelay);\n    }\n\n    private onPointerMove(oEvent: PointerEvent) {\n        if (this._pointerTracking) {\n            this.processDragMove(oEvent);\n            oEvent.preventDefault();\n        }\n    }\n\n    private processDragMove(dragEvent: PointerEvent) {\n        this._nX = dragEvent.pageX - this._nOriginalX;\n        this._nY = dragEvent.pageY - this._nOriginalY;\n\n        if (this._dragging === false) {\n            if (\n                Math.abs(this._nX) > this._nDistance ||\n                Math.abs(this._nY) > this._nDistance\n            ) {\n                this.startDrag();\n            }\n        }\n\n        if (this._dragging) {\n            this.emit('drag', this._nX, this._nY, dragEvent);\n        }\n    }\n\n    private onPointerUp(oEvent: PointerEvent) {\n        this.processDragStop(oEvent);\n    }\n\n    private processDragStop(dragEvent?: PointerEvent) {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n\n        this.checkRemovePointerTrackingEventListeners();\n    \n        if (this._dragging === true) {\n            this._eBody.classList.remove(DomConstants.ClassName.Dragging);\n            this._eElement.classList.remove(DomConstants.ClassName.Dragging);\n            this._oDocument.querySelector('iframe')?.style.setProperty('pointer-events', '');\n            this._dragging = false;\n            this.emit('dragStop', dragEvent);\n        }\n    }\n\n    private checkRemovePointerTrackingEventListeners(): void {\n        if (this._pointerTracking) {\n            this._oDocument.removeEventListener('pointermove', this._pointerMoveEventListener);\n            this._oDocument.removeEventListener('pointerup', this._pointerUpEventListener);\n            this._pointerTracking = false;\n        }    \n    }\n\n    private startDrag() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n        this._dragging = true;\n        this._eBody.classList.add(DomConstants.ClassName.Dragging);\n        this._eElement.classList.add(DomConstants.ClassName.Dragging);\n        this._oDocument.querySelector('iframe')?.style.setProperty('pointer-events', 'none');\n        this.emit('dragStart', this._nOriginalX, this._nOriginalY);\n    }\n\n    private getPointerCoordinates(event: PointerEvent) {\n        const result: DragListener.PointerCoordinates = {\n            x: event.pageX,\n            y: event.pageY\n        };\n        return result;\n    }\n\n}\n\n/** @internal */\nexport namespace DragListener {\n    export interface PointerCoordinates {\n        x: number,\n        y: number,\n    }\n}","import { UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\n\n/**\n * Represents an individual tab within a Stack's header\n * @public\n */\nexport class Tab {\n    /** @internal */\n    private readonly _element: HTMLDivElement;\n    /** @internal */\n    private readonly _titleElement: HTMLSpanElement;\n    /** @internal */\n    private readonly _closeElement: HTMLDivElement | undefined;\n\n    /** @internal */\n    private _dragListener: DragListener | undefined;\n    /** @internal */\n    private _isActive = false;\n\n    /** @internal */\n    private readonly _tabClickListener = (ev: MouseEvent) => this.onTabClickDown(ev);\n    /** @internal */\n    private readonly _tabTouchStartListener = (ev: TouchEvent) => this.onTabTouchStart(ev);\n    /** @internal */\n    private readonly _closeClickListener = () => this.onCloseClick();\n    /** @internal */\n    private readonly _closeTouchStartListener = () => this.onCloseTouchStart();\n    // /** @internal */\n    // private readonly _closeMouseDownListener = () => this.onCloseMousedown();\n    /** @internal */\n    private readonly _dragStartListener = (x: number, y: number) => this.onDragStart(x, y);\n    /** @internal */\n    private readonly _contentItemDestroyListener = () => this.onContentItemDestroy();\n    /** @internal */\n    private readonly _tabTitleChangedListener = (title: string) => this.setTitle(title)\n\n    get isActive(): boolean { return this._isActive; }\n    // get header(): Header { return this._header; }\n    get componentItem(): ComponentItem { return this._componentItem; }\n    /** @deprecated use {@link (Tab:class).componentItem} */\n    get contentItem(): ComponentItem { return this._componentItem; }\n    get element(): HTMLElement { return this._element; }\n    get titleElement(): HTMLElement { return this._titleElement; }\n    get closeElement(): HTMLElement | undefined { return this._closeElement; }\n    get reorderEnabled(): boolean { return this._dragListener !== undefined; }\n    set reorderEnabled(value: boolean) {\n        if (value !== this.reorderEnabled) {\n            if (value) {\n                this.enableReorder();\n            } else {\n                this.disableReorder();\n            }\n        }\n    }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private readonly _layoutManager: LayoutManager,\n        /** @internal */\n        private _componentItem: ComponentItem,\n        /** @internal */\n        private _closeEvent: Tab.CloseEvent | undefined,\n        /** @internal */\n        private _focusEvent: Tab.FocusEvent | undefined,\n        /** @internal */\n        private _dragStartEvent: Tab.DragStartEvent | undefined\n    ) {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.Tab);\n        this._titleElement = document.createElement('span'); \n        this._titleElement.classList.add(DomConstants.ClassName.Title);\n        this._closeElement = document.createElement('div'); \n        this._closeElement.classList.add(DomConstants.ClassName.CloseTab);\n        this._element.appendChild(this._titleElement);\n        this._element.appendChild(this._closeElement);\n\n        if (_componentItem.isClosable) {\n            this._closeElement.style.display = '';\n        } else {\n            this._closeElement.style.display = 'none';\n        }\n\n        this.setTitle(_componentItem.title);\n        this._componentItem.on('titleChanged', this._tabTitleChangedListener);\n\n        const reorderEnabled = _componentItem.reorderEnabled ?? this._layoutManager.layoutConfig.settings.reorderEnabled;\n\n        if (reorderEnabled) {\n            this.enableReorder();\n        }\n\n        this._element.addEventListener('click', this._tabClickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._tabTouchStartListener, { passive: true });\n\n        if (this._componentItem.isClosable) {\n            this._closeElement.addEventListener('click', this._closeClickListener, { passive: true });\n            this._closeElement.addEventListener('touchstart', this._closeTouchStartListener, { passive: true });\n            // this._closeElement.addEventListener('mousedown', this._closeMouseDownListener, { passive: true });\n        } else {\n            this._closeElement.remove();\n            this._closeElement = undefined;\n        }\n\n        this._componentItem.setTab(this);\n        this._layoutManager.emit('tabCreated', this);\n    }\n\n    /**\n     * Sets the tab's title to the provided string and sets\n     * its title attribute to a pure text representation (without\n     * html tags) of the same string.\n     */\n    setTitle(title: string): void {\n        this._titleElement.innerText = title;\n        this._element.title = title;\n    }\n\n    /**\n     * Sets this tab's active state. To programmatically\n     * switch tabs, use Stack.setActiveComponentItem( item ) instead.\n     */\n    setActive(isActive: boolean): void {\n        if (isActive === this._isActive) {\n            return;\n        }\n        this._isActive = isActive;\n\n        if (isActive) {\n            this._element.classList.add(DomConstants.ClassName.Active);\n        } else {\n            this._element.classList.remove(DomConstants.ClassName.Active);\n        }\n    }\n\n    /**\n     * Destroys the tab\n     * @internal\n     */\n    destroy(): void {\n        this._closeEvent = undefined;\n        this._focusEvent = undefined;\n        this._dragStartEvent = undefined;\n        this._element.removeEventListener('click', this._tabClickListener);\n        this._element.removeEventListener('touchstart', this._tabTouchStartListener);\n        this._closeElement?.removeEventListener('click', this._closeClickListener);\n        this._closeElement?.removeEventListener('touchstart', this._closeTouchStartListener);\n        // this._closeElement?.removeEventListener('mousedown', this._closeMouseDownListener);\n        this._componentItem.off('titleChanged', this._tabTitleChangedListener);\n        if (this.reorderEnabled) {\n            this.disableReorder();\n        }\n        this._element.remove();\n    }\n\n    /** @internal */\n    setBlurred(): void {\n        this._element.classList.remove(DomConstants.ClassName.Focused);\n        this._titleElement.classList.remove(DomConstants.ClassName.Focused);\n    }\n\n    /** @internal */\n    setFocused(): void {\n        this._element.classList.add(DomConstants.ClassName.Focused);\n        this._titleElement.classList.add(DomConstants.ClassName.Focused);\n    }\n\n    /**\n     * Callback for the DragListener\n     * @param x - The tabs absolute x position\n     * @param y - The tabs absolute y position\n     * @internal\n     */\n    private onDragStart(x: number, y: number): void {\n        if (this._dragListener === undefined) {\n            throw new UnexpectedUndefinedError('TODSDLU10093');\n        } else {\n            if (this._dragStartEvent === undefined) {\n                throw new UnexpectedUndefinedError('TODS23309');\n            } else {\n                this._dragStartEvent(x, y, this._dragListener, this.componentItem);\n            }\n        }\n\n    }\n\n    /** @internal */\n    private onContentItemDestroy() {\n        if (this._dragListener !== undefined) {\n            this._dragListener.destroy();\n            this._dragListener = undefined;\n        }\n    }\n\n    /**\n     * Callback when the tab is clicked\n     * @internal\n     */\n    private onTabClickDown(event: MouseEvent) {\n        const target = event.target;\n        if (target === this._element || target === this._titleElement) {\n            // left mouse button\n            if (event.button === 0) {\n                // event.stopPropagation();\n                this.notifyFocus();\n\n                // middle mouse button\n            } else if (event.button === 1 && this._componentItem.isClosable) {\n                // event.stopPropagation();\n                this.notifyClose();\n            }\n        }\n    }\n\n    /** @internal */\n    private onTabTouchStart(event: TouchEvent) {\n        if (event.target === this._element) {\n            this.notifyFocus();\n        }\n    }\n\n    /**\n     * Callback when the tab's close button is clicked\n     * @internal\n     */\n    private onCloseClick() {\n        this.notifyClose();\n    }\n\n    /** @internal */\n    private onCloseTouchStart() {\n        this.notifyClose();\n    }\n\n    /**\n     * Callback to capture tab close button mousedown\n     * to prevent tab from activating.\n     * @internal\n     */\n    // private onCloseMousedown(): void {\n    //     // event.stopPropagation();\n    // }\n\n    /** @internal */\n    private notifyClose() {\n        if (this._closeEvent === undefined) {\n            throw new UnexpectedUndefinedError('TNC15007');\n        } else {\n            this._closeEvent(this._componentItem);\n        }\n    }\n\n    /** @internal */\n    private notifyFocus() {\n        if (this._focusEvent === undefined) {\n            throw new UnexpectedUndefinedError('TNA15007');\n        } else {\n            this._focusEvent(this._componentItem);\n        }\n    }\n\n    /** @internal */\n    private enableReorder() {\n        this._dragListener = new DragListener(this._element, [this._titleElement]);\n        this._dragListener.on('dragStart', this._dragStartListener);\n        this._componentItem.on('destroy', this._contentItemDestroyListener);\n    }\n\n    /** @internal */\n    private disableReorder() {\n        if (this._dragListener === undefined) {\n            throw new UnexpectedUndefinedError('TDR87745');\n        } else {\n            this._componentItem.off('destroy', this._contentItemDestroyListener);\n            this._dragListener.off('dragStart', this._dragStartListener);\n            this._dragListener = undefined;\n        }\n    }\n}\n\n/** @public */\nexport namespace Tab {\n    /** @internal */\n    export type CloseEvent = (componentItem: ComponentItem) => void;\n    /** @internal */\n    export type FocusEvent = (componentItem: ComponentItem) => void;\n    /** @internal */\n    export type DragStartEvent = (x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n}\n","import { AssertError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { numberToPixels, pixelsToNumber } from '../utils/utils';\nimport { Tab } from './tab';\n\n/** @internal */\nexport class TabsContainer {\n    // There is one tab per ComponentItem in stack.  However they may not be ordered the same\n    private readonly _tabs: Tab[] = [];\n\n    private readonly _dropdownElement: HTMLElement;\n    private readonly _element: HTMLElement;\n    private _lastVisibleTabIndex = -1;\n    private _dropdownActive = false;\n\n    get tabs(): Tab[] { return this._tabs; }\n    get tabCount(): number { return this._tabs.length; }\n    get lastVisibleTabIndex(): number { return this._lastVisibleTabIndex; }\n    \n    get element(): HTMLElement { return this._element; }\n    get dropdownElement(): HTMLElement { return this._dropdownElement; }\n    get dropdownActive(): boolean { return this._dropdownActive; }\n\n    constructor(private _layoutManager: LayoutManager,\n        private _componentRemoveEvent: TabsContainer.ComponentItemRemoveEvent,\n        private _componentFocusEvent: TabsContainer.ComponentItemFocusEvent,\n        private _componentDragStartEvent: TabsContainer.ComponentItemDragStartEvent,\n        private _dropdownActiveChangedEvent: TabsContainer.DropdownActiveChangedEvent,\n    ) {\n        this._element = document.createElement('section');\n        this._element.classList.add(DomConstants.ClassName.Tabs);\n\n        this._dropdownElement = document.createElement('section');\n        this._dropdownElement.classList.add(DomConstants.ClassName.TabDropdownList);\n        this._dropdownElement.style.display = 'none';\n    }\n\n    destroy(): void {\n        for (let i = 0; i < this._tabs.length; i++) {\n            this._tabs[i].destroy();\n        }\n    }\n\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     */\n    createTab(componentItem: ComponentItem, index: number): void {\n        //If there's already a tab relating to the\n        //content item, don't do anything\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                return;\n            }\n        }\n\n        const tab = new Tab(this._layoutManager,\n            componentItem,\n            (item) => this.handleTabCloseEvent(item),\n            (item) => this.handleTabFocusEvent(item),\n            (x, y, dragListener, item) => this.handleTabDragStartEvent(x, y, dragListener, item));\n\n        if (this._tabs.length === 0) {\n            this._tabs.push(tab);\n            this._element.appendChild(tab.element);\n        } else {\n            if (index === undefined) {\n                index = this._tabs.length;\n            }\n\n            if (index > 0) {\n                this._tabs[index - 1].element.insertAdjacentElement('afterend', tab.element);\n            } else {\n                this._tabs[0].element.insertAdjacentElement('beforebegin', tab.element);\n            }\n\n            this._tabs.splice(index, 0, tab);\n        }\n    }\n\n    removeTab(componentItem: ComponentItem): void {\n        // componentItem cannot be ActiveComponentItem\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                const tab = this._tabs[i];\n                tab.destroy();\n                this._tabs.splice(i, 1);\n                return;\n            }\n        }\n\n        throw new Error('contentItem is not controlled by this header');\n    }\n\n    processActiveComponentChanged(newActiveComponentItem: ComponentItem): void {\n        let activeIndex = -1;\n        for (let i = 0; i < this._tabs.length; i++) {\n            const isActive = this._tabs[i].componentItem === newActiveComponentItem;\n            this._tabs[i].setActive(isActive);\n            if (isActive) {\n                activeIndex = i;\n            }\n        }\n\n        if (activeIndex < 0) {\n            throw new AssertError('HSACI56632');\n        } else {\n            if (this._layoutManager.layoutConfig.settings.reorderOnTabMenuClick) {\n                /**\n                 * If the tab selected was in the dropdown, move everything down one to make way for this one to be the first.\n                 * This will make sure the most used tabs stay visible.\n                 */\n                if (this._lastVisibleTabIndex !== -1 && activeIndex > this._lastVisibleTabIndex) {\n                    const activeTab = this._tabs[activeIndex];\n                    for (let j = activeIndex; j > 0; j--) {\n                        this._tabs[j] = this._tabs[j - 1];\n                    }\n                    this._tabs[0] = activeTab;\n\n                    // updateTabSizes will always be called after this and it will reposition tab elements\n                }\n            }\n        }\n    }\n\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     */\n    updateTabSizes(availableWidth: number, activeComponentItem: ComponentItem | undefined): void {\n        let dropDownActive = false;\n        const success = this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem);\n        if (!success) {\n            dropDownActive = true;\n            // this will always succeed\n            this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem)\n        }\n\n        if (dropDownActive !== this._dropdownActive) {\n            this._dropdownActive = dropDownActive;\n            this._dropdownActiveChangedEvent();\n        }\n    }\n\n    tryUpdateTabSizes(dropdownActive: boolean, availableWidth: number, activeComponentItem: ComponentItem | undefined): boolean {\n        if (this._tabs.length > 0) {\n            if (activeComponentItem === undefined) {\n                throw new Error('non-empty tabs must have active component item');\n            }\n\n            let cumulativeTabWidth = 0;\n            let tabOverlapAllowanceExceeded = false;\n            const tabOverlapAllowance = this._layoutManager.layoutConfig.settings.tabOverlapAllowance;\n            const activeIndex = this._tabs.indexOf(activeComponentItem.tab);\n            const activeTab = this._tabs[activeIndex];\n            this._lastVisibleTabIndex = -1;\n\n            for (let i = 0; i < this._tabs.length; i++) {\n                const tabElement = this._tabs[i].element;\n\n                //Put the tab in the tabContainer so its true width can be checked\n                if (tabElement.parentElement !== this._element) {\n                    this._element.appendChild(tabElement);\n                }\n                const tabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                const tabMarginRight = pixelsToNumber(tabMarginRightPixels);\n                const tabWidth = tabElement.offsetWidth + tabMarginRight;\n\n                cumulativeTabWidth += tabWidth;\n\n                //Include the active tab's width if it isn't already\n                //This is to ensure there is room to show the active tab\n                let visibleTabWidth = 0;\n                if (activeIndex <= i) {\n                    visibleTabWidth = cumulativeTabWidth;\n                } else {\n                    const activeTabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                    const activeTabMarginRight = pixelsToNumber(activeTabMarginRightPixels);\n                    visibleTabWidth = cumulativeTabWidth + activeTab.element.offsetWidth + activeTabMarginRight;\n                }\n\n                // If the tabs won't fit, check the overlap allowance.\n                if (visibleTabWidth > availableWidth) {\n\n                    //Once allowance is exceeded, all remaining tabs go to menu.\n                    if (!tabOverlapAllowanceExceeded) {\n\n                        //No overlap for first tab or active tab\n                        //Overlap spreads among non-active, non-first tabs\n                        let overlap: number;\n                        if (activeIndex > 0 && activeIndex <= i) {\n                            overlap = (visibleTabWidth - availableWidth) / (i - 1);\n                        } else {\n                            overlap = (visibleTabWidth - availableWidth) / i;\n                        }\n\n                        //Check overlap against allowance.\n                        if (overlap < tabOverlapAllowance) {\n                            for (let j = 0; j <= i; j++) {\n                                const marginLeft = (j !== activeIndex && j !== 0) ? '-' + numberToPixels(overlap) : '';\n                                this._tabs[j].element.style.zIndex = numberToPixels(i - j);\n                                this._tabs[j].element.style.marginLeft = marginLeft;\n                            }\n                            this._lastVisibleTabIndex = i;\n                            if (tabElement.parentElement !== this._element) {\n                                this._element.appendChild(tabElement);\n                            }\n                        } else {\n                            tabOverlapAllowanceExceeded = true;\n                        }\n\n                    } else if (i === activeIndex) {\n                        //Active tab should show even if allowance exceeded. (We left room.)\n                        tabElement.style.zIndex = 'auto';\n                        tabElement.style.marginLeft = '';\n                        if (tabElement.parentElement !== this._element) {\n                            this._element.appendChild(tabElement);\n                        }\n                    }\n\n                    if (tabOverlapAllowanceExceeded && i !== activeIndex) {\n                        if (dropdownActive) {\n                            //Tab menu already shown, so we just add to it.\n                            tabElement.style.zIndex = 'auto';\n                            tabElement.style.marginLeft = '';\n                            \n                            if (tabElement.parentElement !== this._dropdownElement) {\n                                this._dropdownElement.appendChild(tabElement);\n                            }\n                        } else {\n                            //We now know the tab menu must be shown, so we have to recalculate everything.\n                            return false;\n                        }\n                    }\n\n                } else {\n                    this._lastVisibleTabIndex = i;\n                    tabElement.style.zIndex = 'auto';\n                    tabElement.style.marginLeft = '';\n                    if (tabElement.parentElement !== this._element) {\n                        this._element.appendChild(tabElement);\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Shows drop down for additional tabs when there are too many to display.\n     */\n    showAdditionalTabsDropdown(): void {\n        this._dropdownElement.style.display = '';\n    }\n\n    /**\n     * Hides drop down for additional tabs when there are too many to display.\n     */\n    hideAdditionalTabsDropdown(): void {\n        this._dropdownElement.style.display = 'none';\n    }\n\n    private handleTabCloseEvent(componentItem: ComponentItem) {\n        this._componentRemoveEvent(componentItem);\n    }\n\n    private handleTabFocusEvent(componentItem: ComponentItem) {\n        this._componentFocusEvent(componentItem);\n    }\n\n    private handleTabDragStartEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        this._componentDragStartEvent(x, y, dragListener, componentItem);\n    }\n\n}\n\n/** @internal */\nexport namespace TabsContainer {\n    export type ComponentItemRemoveEvent = (this: void, componentItem: ComponentItem) => void;\n    export type ComponentItemFocusEvent = (this: void, componentItem: ComponentItem) => void;\n    export type ComponentItemDragStartEvent = (this: void, x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n    export type DropdownActiveChangedEvent = (this: void) => void;\n}","import { UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { Stack } from '../items/stack';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Side } from '../utils/types';\nimport { numberToPixels, setElementDisplayVisibility } from '../utils/utils';\nimport { HeaderButton } from './header-button';\nimport { Tab } from './tab';\nimport { TabsContainer } from './tabs-container';\n\n/**\n * This class represents a header above a Stack ContentItem.\n * @public\n */\nexport class Header extends EventEmitter {\n    /** @internal */\n    private readonly _tabsContainer: TabsContainer;\n    /** @internal */\n    private readonly _element: HTMLElement;\n    /** @internal */\n    private readonly _controlsContainerElement: HTMLElement;\n\n    /** @internal */\n    private readonly _show: boolean;\n    /** @internal */\n    private readonly _popoutEnabled: boolean;\n    /** @internal */\n    private readonly _popoutLabel: string;\n    /** @internal */\n    private readonly _maximiseEnabled: boolean;\n    /** @internal */\n    private readonly _maximiseLabel: string;\n    /** @internal */\n    private readonly _minimiseEnabled: boolean;\n    /** @internal */\n    private readonly _minimiseLabel: string;\n    /** @internal */\n    private readonly _closeEnabled: boolean;\n    /** @internal */\n    private readonly _closeLabel: string;\n    /** @internal */\n    private readonly _tabDropdownEnabled: boolean;\n    /** @internal */\n    private readonly _tabDropdownLabel: string;\n\n    /** @internal */\n    private readonly _tabControlOffset: number;\n\n    /** @internal */\n    private readonly _clickListener = (ev: MouseEvent) => this.onClick(ev);\n    /** @internal */\n    private readonly _touchStartListener = (ev: TouchEvent) => this.onTouchStart(ev);\n    /** @internal */\n    private readonly _documentMouseUpListener: (this: void) => void;\n\n    /** @internal */\n    private _rowColumnClosable = true;\n    /** @internal */\n    private _canRemoveComponent: boolean;\n    /** @internal */\n    private _side: Side;\n    /** @internal */\n    private _leftRightSided: boolean;\n    /** @internal */\n    private readonly _closeButton: HeaderButton | null = null;\n    /** @internal */\n    private readonly _popoutButton: HeaderButton | null = null;\n    /** @internal */\n    private readonly _tabDropdownButton: HeaderButton;\n    /** @internal */\n    private readonly _maximiseButton: HeaderButton | undefined;\n    // /** @internal */\n    // private _activeComponentItem: ComponentItem | null = null; // only used to identify active tab\n\n    get show(): boolean { return this._show; }\n    get side(): Side { return this._side; }\n    get leftRightSided(): boolean { return this._leftRightSided; }\n\n    get layoutManager(): LayoutManager { return this._layoutManager; }\n    get parent(): Stack { return this._parent; }\n    get tabs(): Tab[] { return this._tabsContainer.tabs; }\n    get lastVisibleTabIndex(): number { return this._tabsContainer.lastVisibleTabIndex; }\n\n    get element(): HTMLElement { return this._element; }\n    get tabsContainerElement(): HTMLElement { return this._tabsContainer.element; }\n    get controlsContainerElement(): HTMLElement { return this._controlsContainerElement; }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager,\n        /** @internal */\n        private _parent: Stack,\n        settings: Header.Settings,\n        /** @internal */\n        private readonly _configClosable: boolean,\n        /** @internal */\n        private _getActiveComponentItemEvent: Header.GetActiveComponentItemEvent,\n        closeEvent: Header.CloseEvent,\n        /** @internal */\n        private _popoutEvent: Header.PopoutEvent | undefined,\n        /** @internal */\n        private _maximiseToggleEvent: Header.MaximiseToggleEvent | undefined,\n        /** @internal */\n        private _clickEvent: Header.ClickEvent | undefined,\n        /** @internal */\n        private _touchStartEvent: Header.TouchStartEvent | undefined,\n        /** @internal */\n        private _componentRemoveEvent: Header.ComponentRemoveEvent | undefined,\n        /** @internal */\n        private _componentFocusEvent: Header.ComponentFocusEvent | undefined,\n        /** @internal */\n        private _componentDragStartEvent: Header.ComponentDragStartEvent | undefined,\n    ) {\n        super();\n\n        this._tabsContainer = new TabsContainer(this._layoutManager,\n            (item) => this.handleTabInitiatedComponentRemoveEvent(item),\n            (item) => this.handleTabInitiatedComponentFocusEvent(item),\n            (x, y, dragListener, item) => this.handleTabInitiatedDragStartEvent(x, y, dragListener, item),\n            () => this.processTabDropdownActiveChanged(),\n        );\n\n        this._show = settings.show;\n        this._popoutEnabled = settings.popoutEnabled;\n        this._popoutLabel = settings.popoutLabel;\n        this._maximiseEnabled = settings.maximiseEnabled;\n        this._maximiseLabel = settings.maximiseLabel;\n        this._minimiseEnabled = settings.minimiseEnabled;\n        this._minimiseLabel = settings.minimiseLabel;\n        this._closeEnabled = settings.closeEnabled;\n        this._closeLabel = settings.closeLabel;\n        this._tabDropdownEnabled = settings.tabDropdownEnabled;\n        this._tabDropdownLabel = settings.tabDropdownLabel;\n        this.setSide(settings.side);\n\n        this._canRemoveComponent = this._configClosable;\n\n        this._element = document.createElement('section');\n        this._element.classList.add(DomConstants.ClassName.Header);\n        this._controlsContainerElement = document.createElement('section');\n        this._controlsContainerElement.classList.add(DomConstants.ClassName.Controls);\n        this._element.appendChild(this._tabsContainer.element);\n        this._element.appendChild(this._controlsContainerElement);\n        this._element.appendChild(this._tabsContainer.dropdownElement);\n\n        this._element.addEventListener('click', this._clickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartListener, { passive: true });\n\n        this._documentMouseUpListener = () => this._tabsContainer.hideAdditionalTabsDropdown()\n        globalThis.document.addEventListener('mouseup', this._documentMouseUpListener, { passive: true });\n\n        this._tabControlOffset = this._layoutManager.layoutConfig.settings.tabControlOffset;\n\n        if (this._tabDropdownEnabled) {\n            this._tabDropdownButton = new HeaderButton(this, this._tabDropdownLabel, DomConstants.ClassName.TabDropdown,\n                () => this._tabsContainer.showAdditionalTabsDropdown()\n            );\n        }\n\n        if (this._popoutEnabled) {\n            this._popoutButton = new HeaderButton(this, this._popoutLabel, DomConstants.ClassName.Popout, () => this.handleButtonPopoutEvent());\n        }\n\n        /**\n         * Maximise control - set the component to the full size of the layout\n         */\n        if (this._maximiseEnabled) {\n            this._maximiseButton = new HeaderButton(this, this._maximiseLabel, DomConstants.ClassName.Maximise,\n                (ev) => this.handleButtonMaximiseToggleEvent(ev)\n            );\n        }\n\n        /**\n         * Close button\n         */\n        if (this._configClosable) {\n            this._closeButton = new HeaderButton(this, this._closeLabel, DomConstants.ClassName.Close, () => closeEvent());\n        }\n\n        this.processTabDropdownActiveChanged();\n    }\n\n    /**\n     * Destroys the entire header\n     * @internal\n     */\n    destroy(): void {\n        this.emit('destroy');\n\n        this._popoutEvent = undefined;\n        this._maximiseToggleEvent = undefined;\n        this._clickEvent = undefined;\n        this._touchStartEvent = undefined;\n        this._componentRemoveEvent = undefined;\n        this._componentFocusEvent = undefined;\n        this._componentDragStartEvent = undefined;\n\n        this._tabsContainer.destroy();\n\n        globalThis.document.removeEventListener('mouseup', this._documentMouseUpListener);\n        this._element.remove();\n    }\n\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     * @internal\n     */\n    createTab(componentItem: ComponentItem, index: number): void {\n        this._tabsContainer.createTab(componentItem, index);\n    }\n\n    /**\n     * Finds a tab based on the contentItem its associated with and removes it.\n     * Cannot remove tab if it has the active ComponentItem\n     * @internal\n     */\n    removeTab(componentItem: ComponentItem): void {\n        this._tabsContainer.removeTab(componentItem);\n    }\n\n    /** @internal */\n    processActiveComponentChanged(newActiveComponentItem: ComponentItem): void {\n        this._tabsContainer.processActiveComponentChanged(newActiveComponentItem);\n        this.updateTabSizes();\n    }\n\n    /** @internal */\n    setSide(value: Side): void {\n        this._side = value;\n        this._leftRightSided = [Side.right, Side.left].includes(this._side);\n    }\n\n    /**\n     * Programmatically set closability.\n     * @param value - Whether to enable/disable closability.\n     * @returns Whether the action was successful\n     * @internal\n     */\n    setRowColumnClosable(value: boolean): void {\n        this._rowColumnClosable = value;\n        this.updateClosability();\n    }\n\n    /**\n     * Updates the header's closability. If a stack/header is able\n     * to close, but has a non closable component added to it, the stack is no\n     * longer closable until all components are closable.\n     * @internal\n     */\n    updateClosability(): void {\n        let isClosable: boolean;\n        if (!this._configClosable) {\n            isClosable = false;\n        } else {\n            if (!this._rowColumnClosable) {\n                isClosable = false;\n            } else {\n                isClosable = true;\n                const len = this.tabs.length;\n                for (let i = 0; i < len; i++) {\n                    const tab = this._tabsContainer.tabs[i];\n                    const item = tab.componentItem;\n                    if (!item.isClosable) {\n                        isClosable = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (this._closeButton !== null) {\n            setElementDisplayVisibility(this._closeButton.element, isClosable);\n        }\n        if (this._popoutButton !== null) {\n            setElementDisplayVisibility(this._popoutButton.element, isClosable);\n        }\n\n        this._canRemoveComponent = isClosable || this._tabsContainer.tabCount > 1;\n    }\n\n    /** @internal */\n    applyFocusedValue(value: boolean): void {\n        if (value) {\n            this._element.classList.add(DomConstants.ClassName.Focused);\n        } else {\n            this._element.classList.remove(DomConstants.ClassName.Focused);\n        }\n    }\n\n    /** @internal */\n    processMaximised(): void {\n        if (this._maximiseButton === undefined) {\n            throw new UnexpectedUndefinedError('HPMAX16997');\n        } else {\n            this._maximiseButton.element.setAttribute('title', this._minimiseLabel);\n        }\n    }\n\n    /** @internal */\n    processMinimised(): void {\n        if (this._maximiseButton === undefined) {\n            throw new UnexpectedUndefinedError('HPMIN16997');\n        } else {\n            this._maximiseButton.element.setAttribute('title', this._maximiseLabel);\n        }\n    }\n\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     * @internal\n     */\n    updateTabSizes(): void {\n        if (this._tabsContainer.tabCount > 0) {\n            const headerHeight = this._show ? this._layoutManager.layoutConfig.dimensions.headerHeight : 0;\n\n            if (this._leftRightSided) {\n                this._element.style.height = '';\n                this._element.style.width = numberToPixels(headerHeight);\n            } else {\n                this._element.style.width = '';\n                this._element.style.height = numberToPixels(headerHeight);\n            }\n            let availableWidth: number;\n            if (this._leftRightSided) {\n                availableWidth = this._element.offsetHeight - this._controlsContainerElement.offsetHeight - this._tabControlOffset;\n            } else {\n                availableWidth = this._element.offsetWidth - this._controlsContainerElement.offsetWidth - this._tabControlOffset;\n            }\n\n            this._tabsContainer.updateTabSizes(availableWidth, this._getActiveComponentItemEvent());\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedComponentRemoveEvent(componentItem: ComponentItem) {\n        if (this._canRemoveComponent) {\n            if (this._componentRemoveEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHTCE22294');\n            } else {\n                this._componentRemoveEvent(componentItem);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedComponentFocusEvent(componentItem: ComponentItem) {\n        if (this._componentFocusEvent === undefined) {\n            throw new UnexpectedUndefinedError('HHTAE22294');\n        } else {\n            this._componentFocusEvent(componentItem);\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedDragStartEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        if (!this._canRemoveComponent) {\n            dragListener.cancelDrag();\n        } else {\n            if (this._componentDragStartEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHTDSE22294');\n            } else {\n                this._componentDragStartEvent(x, y, dragListener, componentItem);\n            }\n        }\n    }\n\n    /** @internal */\n    private processTabDropdownActiveChanged() {\n        if (this._tabDropdownButton !== undefined) {\n            setElementDisplayVisibility(this._tabDropdownButton.element, this._tabsContainer.dropdownActive);\n        }\n    }\n\n    /** @internal */\n    private handleButtonPopoutEvent() {\n        if (this._layoutManager.layoutConfig.settings.popoutWholeStack) {\n            if (this._popoutEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHBPOE17834');\n            } else {\n                this._popoutEvent();\n            }\n        } else {\n            const activeComponentItem = this._getActiveComponentItemEvent();\n            if (activeComponentItem) {\n                activeComponentItem.popout();\n            }\n            // else: if the stack is empty there won't be an active item (and nothing to popout)\n        }\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private handleButtonMaximiseToggleEvent(ev: Event) {\n        if (this._maximiseToggleEvent === undefined) {\n            throw new UnexpectedUndefinedError('HHBMTE16834');\n        } else {\n            this._maximiseToggleEvent();\n        }\n    }\n\n    /**\n     * Invoked when the header's background is clicked (not it's tabs or controls)\n     * @internal\n     */\n    private onClick(event: MouseEvent) {\n        if (event.target === this._element) {\n            this.notifyClick(event);\n        }\n    }\n\n    /**\n     * Invoked when the header's background is touched (not it's tabs or controls)\n     * @internal\n     */\n    private onTouchStart(event: TouchEvent) {\n        if (event.target === this._element) {\n            this.notifyTouchStart(event);\n        }\n    }\n\n    /** @internal */\n    private notifyClick(ev: MouseEvent) {\n        if (this._clickEvent === undefined) {\n            throw new UnexpectedUndefinedError('HNHC46834');\n        } else {\n            this._clickEvent(ev);\n        }\n    }\n\n    /** @internal */\n    private notifyTouchStart(ev: TouchEvent) {\n        if (this._touchStartEvent === undefined) {\n            throw new UnexpectedUndefinedError('HNHTS46834');\n        } else {\n            this._touchStartEvent(ev);\n        }\n    }\n}\n\n/** @public */\nexport namespace Header {\n    /** @internal */\n    export type GetActiveComponentItemEvent = (this: void) => ComponentItem | undefined;\n    /** @internal */\n    export type CloseEvent = (this: void) => void;\n    /** @internal */\n    export type PopoutEvent = (this: void) => void;\n    /** @internal */\n    export type MaximiseToggleEvent = (this: void) => void;\n    /** @internal */\n    export type ClickEvent = (this: void, ev: MouseEvent) => void;\n    /** @internal */\n    export type TouchStartEvent = (this: void, ev: TouchEvent) => void;\n    /** @internal */\n    export type ComponentRemoveEvent = (this: void, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type ComponentFocusEvent = (this: void, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type ComponentDragStartEvent = (this: void, x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type StateChangedEvent = (this: void) => void;\n\n    /** @internal */\n    export interface Settings {\n        show: boolean;\n        side: Side;\n        popoutEnabled: boolean;\n        popoutLabel: string;\n        maximiseEnabled: boolean;\n        maximiseLabel: string;\n        minimiseEnabled: boolean;\n        minimiseLabel: string;\n        closeEnabled: boolean;\n        closeLabel: string;\n        tabDropdownEnabled: boolean;\n        tabDropdownLabel: string;\n    }\n}\n","import { LeftAndTop } from './types';\nimport { pixelsToNumber } from './utils';\n\n/** @internal */\nexport interface JQueryOffset {\n    top: number;\n    left: number;    \n}\n\n/** @internal */\nexport function getJQueryOffset(element: HTMLElement): JQueryOffset {\n    const rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + document.body.scrollTop,\n        left: rect.left + document.body.scrollLeft,\n    }\n}\n\n/** @internal */\nexport function getJQueryLeftAndTop(element: HTMLElement): LeftAndTop {\n    const style = getComputedStyle(element, null);\n    const leftAndTop: LeftAndTop = {\n        left: pixelsToNumber(style.left),\n        top: pixelsToNumber(style.top),\n    }\n    return leftAndTop;\n}\n","import { ComponentItemConfig, ItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig } from '../config/resolved-config';\nimport { Tab } from '../controls/tab';\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { ContentItem } from '../items/content-item';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { JsonValue, LogicalZIndex, LogicalZIndexToDefaultMap } from '../utils/types';\nimport { deepExtend, setElementHeight, setElementWidth } from '../utils/utils';\n\n/** @public */\nexport class ComponentContainer extends EventEmitter {\n    /** @internal */\n    private _componentType: JsonValue;\n    /** @internal */\n    private _boundComponent: ComponentContainer.BindableComponent;\n    /** @internal */\n    private _width: number;\n    /** @internal */\n    private _height: number;\n    /** @internal */\n    private _isClosable;\n    /** @internal */\n    private _initialState: JsonValue | undefined;\n    /** @internal */\n    private _state: JsonValue | undefined;\n    /** @internal */\n    private _visible;\n    /** @internal */\n    private _isShownWithZeroDimensions;\n    /** @internal */\n    private _tab: Tab;\n    /** @internal */\n    private _stackMaximised = false;\n    /** @internal */\n    private _logicalZIndex: LogicalZIndex;\n\n    stateRequestEvent: ComponentContainer.StateRequestEventHandler | undefined;\n    virtualRectingRequiredEvent: ComponentContainer.VirtualRectingRequiredEvent | undefined;\n    virtualVisibilityChangeRequiredEvent: ComponentContainer.VirtualVisibilityChangeRequiredEvent | undefined;\n    virtualZIndexChangeRequiredEvent: ComponentContainer.VirtualZIndexChangeRequiredEvent | undefined;\n\n    get width(): number { return this._width; }\n    get height(): number { return this._height; }\n    get parent(): ComponentItem { return this._parent; }\n    /** @internal @deprecated use {@link (ComponentContainer:class).componentType} */\n    get componentName(): JsonValue { return this._componentType; }\n    get componentType(): JsonValue { return this._componentType; }\n    get virtual(): boolean { return this._boundComponent.virtual; }\n    get component(): ComponentContainer.Component { return this._boundComponent.component; }\n    get tab(): Tab { return this._tab; }\n    get title(): string { return this._parent.title; }\n    get layoutManager(): LayoutManager { return this._layoutManager; }\n    get isHidden(): boolean { return !this._visible; }\n    get visible(): boolean { return this._visible; }\n    get state(): JsonValue | undefined { return this._state; }\n    /** Return the initial component state */\n    get initialState(): JsonValue | undefined { return this._initialState; }\n    /** The inner DOM element where the container's content is intended to live in */\n    get element(): HTMLElement { return this._element; }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private readonly _config: ResolvedComponentItemConfig,\n        /** @internal */\n        private readonly _parent: ComponentItem,\n        /** @internal */\n        private readonly _layoutManager: LayoutManager,\n        /** @internal */\n        private readonly _element: HTMLElement,\n        /** @internal */\n        private readonly _updateItemConfigEvent: ComponentContainer.UpdateItemConfigEventHandler,\n        /** @internal */\n        private readonly _showEvent: ComponentContainer.ShowEventHandler,\n        /** @internal */\n        private readonly _hideEvent: ComponentContainer.HideEventHandler,\n        /** @internal */\n        private readonly _focusEvent: ComponentContainer.FocusEventHandler,\n        /** @internal */\n        private readonly _blurEvent: ComponentContainer.BlurEventHandler,\n    ) {\n        super();\n\n        this._width = 0;\n        this._height = 0;\n        this._visible = true;\n        this._isShownWithZeroDimensions = true;\n\n        this._componentType = _config.componentType;\n        this._isClosable = _config.isClosable;\n        this._initialState = _config.componentState;\n        this._state = this._initialState;\n\n        this._boundComponent = this.layoutManager.bindComponent(this, _config);\n\n        this.updateElementPositionPropertyFromBoundComponent();\n    }\n\n    /** @internal */\n    destroy(): void {\n        this.releaseComponent();\n        this.stateRequestEvent = undefined;\n        this.emit('destroy');\n    }\n\n    /** @deprecated use {@link (ComponentContainer:class).element } */\n    getElement(): HTMLElement {\n        return this._element;\n    }\n\n    /**\n     * Hides the container's component item (and hence, the container) if not already hidden.\n     * Emits hide event prior to hiding the container.\n     */\n    hide(): void {\n        this._hideEvent();\n    }\n\n    /**\n     * Shows the container's component item (and hence, the container) if not visible.\n     * Emits show event prior to hiding the container.\n     */\n    show(): void {\n        this._showEvent();\n    }\n\n    /**\n     * Focus this component in Layout.\n     */\n    focus(suppressEvent = false): void {\n        this._focusEvent(suppressEvent);\n    }\n\n    /**\n     * Remove focus from this component in Layout.\n     */\n    blur(suppressEvent = false): void {\n        this._blurEvent(suppressEvent);\n    }\n\n    /**\n     * Set the size from within the container. Traverses up\n     * the item tree until it finds a row or column element\n     * and resizes its items accordingly.\n     *\n     * If this container isn't a descendant of a row or column\n     * it returns false\n     * @param width - The new width in pixel\n     * @param height - The new height in pixel\n     *\n     * @returns resizeSuccesful\n     *\n     * @internal\n     */\n    setSize(width: number, height: number): boolean {\n        let ancestorItem: ContentItem | null = this._parent;\n        if (ancestorItem.isColumn || ancestorItem.isRow || ancestorItem.parent === null) {\n            throw new AssertError('ICSSPRC', 'ComponentContainer cannot have RowColumn Parent');\n        } else {\n            let ancestorChildItem: ContentItem;\n            do {\n                ancestorChildItem = ancestorItem;\n                ancestorItem = ancestorItem.parent;\n            } while (ancestorItem !== null && !ancestorItem.isColumn && !ancestorItem.isRow);\n\n            if (ancestorItem === null) {\n                // no Row or Column found\n                return false;\n            } else {\n                // ancestorItem is Row or Column\n                const direction = ancestorItem.isColumn ? 'height' : 'width';\n                const currentSize = this[direction];\n                if (currentSize === null) {\n                    throw new UnexpectedNullError('ICSSCS11194');\n                } else {\n                    const newSize = direction === 'height' ? height : width;\n\n                    const totalPixel = currentSize * (1 / (ancestorChildItem[direction] / 100));\n                    const percentage = (newSize / totalPixel) * 100;\n                    const delta = (ancestorChildItem[direction] - percentage) / (ancestorItem.contentItems.length - 1);\n\n                    for (let i = 0; i < ancestorItem.contentItems.length; i++) {\n                        if (ancestorItem.contentItems[i] === ancestorChildItem) {\n                            ancestorItem.contentItems[i][direction] = percentage;\n                        } else {\n                            ancestorItem.contentItems[i][direction] += delta;\n                        }\n                    }\n\n                    ancestorItem.updateSize(false);\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes the container if it is closable. Can be called by\n     * both the component within at as well as the contentItem containing\n     * it. Emits a close event before the container itself is closed.\n     */\n    close(): void {\n        if (this._isClosable) {\n            this.emit('close');\n            this._parent.close();\n        }\n    }\n\n    /** Replaces component without affecting layout */\n    replaceComponent(itemConfig: ComponentItemConfig): void {\n        this.releaseComponent();\n\n        if (!ItemConfig.isComponent(itemConfig)) {\n            throw new Error('ReplaceComponent not passed a component ItemConfig')\n        } else {\n            const config = ComponentItemConfig.resolve(itemConfig);\n            this._initialState = config.componentState;\n            this._state = this._initialState;\n            this._componentType = config.componentType;\n\n            this._updateItemConfigEvent(config);\n\n            this._boundComponent = this.layoutManager.bindComponent(this, config);\n            this.updateElementPositionPropertyFromBoundComponent();\n\n            if (this._boundComponent.virtual) {\n                if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                    this.virtualVisibilityChangeRequiredEvent(this, this._visible);\n                }\n                if (this.virtualRectingRequiredEvent !== undefined) {\n                    this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                    try {\n                        this.virtualRectingRequiredEvent(this, this._width, this._height);\n                    } finally {\n                        this._layoutManager.fireAfterVirtualRectingEvent();\n                    }\n                }\n                this.setBaseLogicalZIndex();\n            }\n\n            this.emit('stateChanged');\n        }\n    }\n\n    /**\n     * Returns the initial component state or the latest passed in setState()\n     * @returns state\n     * @deprecated Use {@link (ComponentContainer:class).initialState}\n     */\n    getState(): JsonValue | undefined {\n        return this._state;\n    }\n\n    /**\n     * Merges the provided state into the current one\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    extendState(state: Record<string, unknown>): void {\n        const extendedState = deepExtend(this._state as Record<string, unknown>, state);\n        this.setState(extendedState as JsonValue);\n    }\n\n    /**\n     * Sets the component state\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    setState(state: JsonValue): void {\n        this._state = state;\n        this._parent.emitBaseBubblingEvent('stateChanged');\n    }\n\n    /**\n     * Set's the components title\n     */\n    setTitle(title: string): void {\n        this._parent.setTitle(title);\n    }\n\n    /** @internal */\n    setTab(tab: Tab): void {\n        this._tab = tab;\n        this.emit('tab', tab)\n    }\n\n    /** @internal */\n    setVisibility(value: boolean): void {\n        if (this._boundComponent.virtual) {\n            if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                this.virtualVisibilityChangeRequiredEvent(this, value);\n            }\n        }\n\n        if (value) {\n            if (!this._visible) {\n                this._visible = true;\n                if (this._height === 0 && this._width === 0) {\n                    this._isShownWithZeroDimensions = true;\n                } else {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            } else {\n                if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            }\n        } else {\n            if (this._visible) {\n                this._visible = false;\n                this._isShownWithZeroDimensions = false;\n                this.emitHide();\n            }\n        }\n    }\n\n    setBaseLogicalZIndex(): void {\n        this.setLogicalZIndex(LogicalZIndex.base);\n    }\n\n    setLogicalZIndex(logicalZIndex: LogicalZIndex): void {\n        if (logicalZIndex !== this._logicalZIndex) {\n            this._logicalZIndex = logicalZIndex;\n\n            this.notifyVirtualZIndexChangeRequired();\n        }\n    }\n\n    /**\n     * Set the container's size, but considered temporary (for dragging)\n     * so don't emit any events.\n     * @internal\n     */\n    enterDragMode(width: number, height: number): void {\n        this._width = width;\n        this._height = height;\n        setElementWidth(this._element, width);\n        setElementHeight(this._element, height);\n\n        this.setLogicalZIndex(LogicalZIndex.drag);\n\n        this.drag();\n    }\n\n    /** @internal */\n    exitDragMode(): void {\n        this.setBaseLogicalZIndex();\n    }\n\n    /** @internal */\n    enterStackMaximised(): void {\n        this._stackMaximised = true;\n        this.setLogicalZIndex(LogicalZIndex.stackMaximised);\n    }\n\n    /** @internal */\n    exitStackMaximised(): void {\n        this.setBaseLogicalZIndex();\n        this._stackMaximised = false;\n    }\n\n    /** @internal */\n    drag(): void {\n        if (this._boundComponent.virtual) {\n            if (this.virtualRectingRequiredEvent !== undefined) {\n                this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                try {\n                    this.virtualRectingRequiredEvent(this, this._width, this._height);\n                } finally {\n                    this._layoutManager.fireAfterVirtualRectingEvent();\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the container's size. Called by the container's component item.\n     * To instead set the size programmatically from within the component itself,\n     * use the public setSize method\n     * @param width - in px\n     * @param height - in px\n     * @param force - set even if no change\n     * @internal\n     */\n    setSizeToNodeSize(width: number, height: number, force: boolean): void {\n        if (width !== this._width || height !== this._height || force) {\n            this._width = width;\n            this._height = height;\n            setElementWidth(this._element, width);\n            setElementHeight(this._element, height);\n\n            if (this._boundComponent.virtual) {\n                this.addVirtualSizedContainerToLayoutManager();\n            } else {\n                this.emit('resize');\n                this.checkShownFromZeroDimensions();\n            }\n        }\n    }\n\n    /** @internal */\n    notifyVirtualRectingRequired(): void {\n        if (this.virtualRectingRequiredEvent !== undefined) {\n            this.virtualRectingRequiredEvent(this, this._width, this._height);\n            this.emit('resize');\n            this.checkShownFromZeroDimensions();\n        }\n    }\n\n    /** @internal */\n    private notifyVirtualZIndexChangeRequired(): void {\n        if (this.virtualZIndexChangeRequiredEvent !== undefined) {\n            const logicalZIndex = this._logicalZIndex;\n            const defaultZIndex = LogicalZIndexToDefaultMap[logicalZIndex];\n            this.virtualZIndexChangeRequiredEvent(this, logicalZIndex, defaultZIndex);\n        }\n    }\n\n    /** @internal */\n    private updateElementPositionPropertyFromBoundComponent() {\n        if (this._boundComponent.virtual) {\n            this._element.style.position = 'static';\n        } else {\n            this._element.style.position = ''; // set it back to attribute value\n        }\n    }\n\n    /** @internal */\n    private addVirtualSizedContainerToLayoutManager() {\n        this._layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this._layoutManager.addVirtualSizedContainer(this);\n        } finally {\n            this._layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /** @internal */\n    private checkShownFromZeroDimensions() {\n        if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n            this._isShownWithZeroDimensions = false;\n            this.emitShow();\n        }\n    }\n\n    /** @internal */\n    private emitShow(): void {\n        this.emit('shown');\n        this.emit('show');\n    }\n\n    /** @internal */\n    private emitHide(): void {\n        this.emit('hide');\n    }\n\n    /** @internal */\n    private releaseComponent() {\n        if (this._stackMaximised) {\n            this.exitStackMaximised();\n        }\n        this.emit('beforeComponentRelease', this._boundComponent.component);\n        this.layoutManager.unbindComponent(this, this._boundComponent.virtual, this._boundComponent.component);\n    }\n}\n\n/** @public @deprecated use {@link ComponentContainer} */\nexport type ItemContainer = ComponentContainer;\n\n/** @public */\nexport namespace ComponentContainer {\n    export type Component = unknown;\n\n    export interface BindableComponent {\n        component: Component;\n        virtual: boolean;\n    }\n\n    export type StateRequestEventHandler = (this: void) => JsonValue | undefined;\n    export type VirtualRectingRequiredEvent = (this: void, container: ComponentContainer, width: number, height: number) => void;\n    export type VirtualVisibilityChangeRequiredEvent = (this: void, container: ComponentContainer, visible: boolean) => void;\n    export type VirtualZIndexChangeRequiredEvent =\n        (this: void, container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) => void;\n    /** @internal */\n    export type ShowEventHandler = (this: void) => void;\n    /** @internal */\n    export type HideEventHandler = (this: void) => void;\n    /** @internal */\n    export type FocusEventHandler = (this: void, suppressEvent: boolean) => void;\n    /** @internal */\n    export type BlurEventHandler = (this: void, suppressEvent: boolean) => void;\n    /** @internal */\n    export type UpdateItemConfigEventHandler = (itemConfig: ResolvedComponentItemConfig) => void;\n}\n","import { ResolvedItemConfig } from '../config/resolved-config'\nimport { BrowserPopout } from '../controls/browser-popout'\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error'\nimport { LayoutManager } from '../layout-manager'\nimport { EventEmitter } from '../utils/event-emitter'\nimport { getJQueryOffset } from '../utils/jquery-legacy'\nimport { AreaLinkedRect, ItemType } from '../utils/types'\nimport { getUniqueId, setElementDisplayVisibility } from '../utils/utils'\nimport { ComponentItem } from './component-item'\nimport { ComponentParentableItem } from './component-parentable-item'\nimport { Stack } from './stack'\n\n/**\n * This is the baseclass that all content items inherit from.\n * Most methods provide a subset of what the sub-classes do.\n *\n * It also provides a number of functions for tree traversal\n * @public\n */\n\nexport abstract class ContentItem extends EventEmitter {\n    /** @internal */\n    private _type: ItemType;\n    /** @internal */\n    private _id: string;\n    /** @internal */\n    private _popInParentIds: string[] = [];\n    /** @internal */\n    private _contentItems: ContentItem[];\n    /** @internal */\n    private _isClosable;\n    /** @internal */\n    private _pendingEventPropagations: Record<string, unknown>;\n    /** @internal */\n    private _throttledEvents: string[];\n    /** @internal */\n    private _isInitialised;\n\n    /** @internal */\n    width: number; // pixels\n    /** @internal */\n    minWidth: number; // pixels\n    /** @internal */\n    height: number; // pixels\n    /** @internal */\n    minHeight: number; // pixels\n\n    isGround: boolean\n    isRow: boolean\n    isColumn: boolean\n    isStack: boolean\n    isComponent: boolean\n\n    get type(): ItemType { return this._type; }\n    get id(): string { return this._id; }\n    set id(value: string) { this._id = value; }\n    /** @internal */\n    get popInParentIds(): string[] { return this._popInParentIds; }\n    get parent(): ContentItem | null { return this._parent; }\n    get contentItems(): ContentItem[] { return this._contentItems; }\n    get isClosable(): boolean { return this._isClosable; }\n    get element(): HTMLElement { return this._element; }\n    get isInitialised(): boolean { return this._isInitialised; }\n\n    static isStack(item: ContentItem): item is Stack {\n        return item.isStack;\n    }\n\n    static isComponentItem(item: ContentItem): item is ComponentItem {\n        return item.isComponent;\n    }\n\n    static isComponentParentableItem(item: ContentItem): item is ComponentParentableItem {\n        return item.isStack || item.isGround;\n    }\n\n    /** @internal */\n    constructor(public readonly layoutManager: LayoutManager,\n        config: ResolvedItemConfig,\n        /** @internal */\n        private _parent: ContentItem | null,\n        /** @internal */\n        private readonly _element: HTMLElement\n    ) {\n        super();\n\n        this._type = config.type;\n        this._id = config.id;\n\n        this._isInitialised = false;\n        this.isGround = false;\n        this.isRow = false;\n        this.isColumn = false;\n        this.isStack = false;\n        this.isComponent = false;\n\n        this.width = config.width;\n        this.minWidth = config.minWidth;\n        this.height = config.height;\n        this.minHeight = config.minHeight;\n\n        this._isClosable = config.isClosable;\n\n        this._pendingEventPropagations = {};\n        this._throttledEvents = ['stateChanged'];\n\n        this._contentItems = this.createContentItems(config.content);\n    }\n\n    /**\n     * Updaters the size of the component and its children, called recursively\n     * @param force - In some cases the size is not updated if it has not changed. In this case, events\n     * (such as ComponentContainer.virtualRectingRequiredEvent) are not fired. Setting force to true, ensures the size is updated regardless, and\n     * the respective events are fired. This is sometimes necessary when a component's size has not changed but it has become visible, and the\n     * relevant events need to be fired.\n     * @internal\n     */\n    abstract updateSize(force: boolean): void;\n\n    /**\n     * Removes a child node (and its children) from the tree\n     * @param contentItem - The child item to remove\n     * @param keepChild - Whether to destroy the removed item\n     */\n    removeChild(contentItem: ContentItem, keepChild = false): void {\n        /*\n         * Get the position of the item that's to be removed within all content items this node contains\n         */\n        const index = this._contentItems.indexOf(contentItem);\n\n        /*\n         * Make sure the content item to be removed is actually a child of this item\n         */\n        if (index === -1) {\n            throw new Error('Can\\'t remove child item. Unknown content item');\n        }\n\n        /**\n\t\t * Call destroy on the content item.\n\t\t * All children are destroyed as well\n\t\t */\n        if (!keepChild) {\n\t\t\tthis._contentItems[index].destroy();\n        }\n\n        /**\n         * Remove the content item from this nodes array of children\n         */\n        this._contentItems.splice(index, 1);\n\n        /**\n         * If this node still contains other content items, adjust their size\n         */\n        if (this._contentItems.length > 0) {\n            this.updateSize(false);\n        } else {\n            /**\n             * If this was the last content item, remove this node as well\n             */\n            if (!this.isGround && this._isClosable === true) {\n                if (this._parent === null) {\n                    throw new UnexpectedNullError('CIUC00874');\n                } else {\n                    this._parent.removeChild(this);\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets up the tree structure for the newly added child\n     * The responsibility for the actual DOM manipulations lies\n     * with the concrete item\n     *\n     * @param contentItem -\n     * @param index - If omitted item will be appended\n     * @param suspendResize - Used by descendent implementations\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addChild(contentItem: ContentItem, index?: number | null, suspendResize?: boolean): number {\n        index ??= this._contentItems.length;\n\n        this._contentItems.splice(index, 0, contentItem);\n        contentItem.setParent(this);\n\n        if (this._isInitialised === true && contentItem._isInitialised === false) {\n            contentItem.init();\n        }\n\n        return index;\n    }\n\n    /**\n     * Replaces oldChild with newChild\n     * @param oldChild -\n     * @param newChild -\n     * @internal\n     */\n    replaceChild(oldChild: ContentItem, newChild: ContentItem, destroyOldChild = false): void {\n        // Do not try to replace ComponentItem - will not work\n        const index = this._contentItems.indexOf(oldChild);\n        const parentNode = oldChild._element.parentNode;\n\n        if (index === -1) {\n            throw new AssertError('CIRCI23232', 'Can\\'t replace child. oldChild is not child of this');\n        }\n\n        if (parentNode === null) {\n            throw new UnexpectedNullError('CIRCP23232');\n        } else {\n            parentNode.replaceChild(newChild._element, oldChild._element);\n\n            /*\n            * Optionally destroy the old content item\n            */\n            if (destroyOldChild === true) {\n                oldChild._parent = null;\n                oldChild.destroy(); // will now also destroy all children of oldChild\n            }\n\n            /*\n            * Wire the new contentItem into the tree\n            */\n            this._contentItems[index] = newChild;\n            newChild.setParent(this);\n            // newChild inherits the sizes from the old child:\n            newChild.height = oldChild.height;\n            newChild.width = oldChild.width;\n\n            //TODO This doesn't update the config... refactor to leave item nodes untouched after creation\n            if (newChild._parent === null) {\n                throw new UnexpectedNullError('CIRCNC45699');\n            } else {\n                if (newChild._parent._isInitialised === true && newChild._isInitialised === false) {\n                    newChild.init();\n                }\n\n                this.updateSize(false);\n            }\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Shorthand for this.parent.removeChild( this )\n     */\n    remove(): void {\n        if (this._parent === null) {\n            throw new UnexpectedNullError('CIR11110');\n        } else {\n            this._parent.removeChild(this);\n        }\n    }\n\n    /**\n     * Removes the component from the layout and creates a new\n     * browser window with the component and its children inside\n     */\n    popout(): BrowserPopout {\n        const parentId = getUniqueId();\n        const browserPopout = this.layoutManager.createPopoutFromContentItem(this, undefined, parentId, undefined);\n        this.emitBaseBubblingEvent('stateChanged');\n        return browserPopout;\n    }\n\n    abstract toConfig(): ResolvedItemConfig;\n\n    /** @internal */\n    calculateConfigContent(): ResolvedItemConfig[] {\n        const contentItems = this._contentItems;\n        const count = contentItems.length;\n        const result = new Array<ResolvedItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            result[i] = item.toConfig();\n        }\n        return result;\n    }\n\n    /** @internal */\n    highlightDropZone(x: number, y: number, area: AreaLinkedRect): void {\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('ACIHDZ5593');\n        } else {\n            dropTargetIndicator.highlightArea(area);\n        }\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onDrop(contentItem: ContentItem, area: ContentItem.Area): void {\n        this.addChild(contentItem);\n    }\n\n    /** @internal */\n    show(): void {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            // Not sure why showAllActiveContentItems() was called. GoldenLayout seems to work fine without it.  Left commented code\n            // in source in case a reason for it becomes apparent.\n            // this.layoutManager.showAllActiveContentItems();\n            setElementDisplayVisibility(this._element, true);\n            // this.layoutManager.updateSizeFromContainer();\n\n            for (let i = 0; i < this._contentItems.length; i++) {\n                this._contentItems[i].show();\n            }\n        } finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n\n    /**\n     * Destroys this item ands its children\n     * @internal\n     */\n    destroy(): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].destroy();\n        }\n        this._contentItems = [];\n\n        this.emitBaseBubblingEvent('beforeItemDestroyed');\n        this._element.remove();\n        this.emitBaseBubblingEvent('itemDestroyed');\n    }\n\n    /**\n     * Returns the area the component currently occupies\n     * @internal\n     */\n    getElementArea(element?: HTMLElement): ContentItem.Area | null {\n        element = element ?? this._element;\n\n        const offset = getJQueryOffset(element);\n        const width = element.offsetWidth;\n        const height = element.offsetHeight;\n        // const widthAndHeight = getJQueryWidthAndHeight(element);\n\n        return {\n            x1: offset.left + 1,\n            y1: offset.top + 1,\n            x2: offset.left + width - 1,\n            y2: offset.top + height - 1,\n            surface: width * height,\n            contentItem: this\n        };\n    }\n\n    /**\n     * The tree of content items is created in two steps: First all content items are instantiated,\n     * then init is called recursively from top to bottem. This is the basic init function,\n     * it can be used, extended or overwritten by the content items\n     *\n     * Its behaviour depends on the content item\n     * @internal\n     */\n    init(): void {\n        this._isInitialised = true;\n        this.emitBaseBubblingEvent('itemCreated');\n        this.emitUnknownBubblingEvent(this.type + 'Created');\n    }\n\n    /** @internal */\n    protected setParent(parent: ContentItem): void {\n        this._parent = parent;\n    }\n\n    /** @internal */\n    addPopInParentId(id: string): void {\n        if (!this.popInParentIds.includes(id)) {\n            this.popInParentIds.push(id);\n        }\n    }\n\n    /** @internal */\n    protected initContentItems(): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].init();\n        }\n    }\n\n    /** @internal */\n    protected hide(): void {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            setElementDisplayVisibility(this._element, false);\n            // this.layoutManager.updateSizeFromContainer();\n        } finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n\n    /** @internal */\n    protected updateContentItemsSize(force: boolean): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].updateSize(force);\n        }\n    }\n\n    /**\n     * creates all content items for this node at initialisation time\n     * PLEASE NOTE, please see addChild for adding contentItems at runtime\n     * @internal\n     */\n    private createContentItems(content: readonly ResolvedItemConfig[]) {\n        const count = content.length;\n        const result = new Array<ContentItem>(count);\n        for (let i = 0; i < content.length; i++) {\n            result[i] = this.layoutManager.createContentItem(content[i], this);\n        }\n        return result;\n    }\n\n    /**\n     * Called for every event on the item tree. Decides whether the event is a bubbling\n     * event and propagates it to its parent\n     *\n     * @param name - The name of the event\n     * @param event -\n     * @internal\n     */\n    private propagateEvent(name: string, args: unknown[]) {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true) {\n\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                } else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n\n    override tryBubbleEvent(name: string, args: unknown[]): void {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true\n            ) {\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                } else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n\n    /**\n     * All raw events bubble up to the Ground element. Some events that\n     * are propagated to - and emitted by - the layoutManager however are\n     * only string-based, batched and sanitized to make them more usable\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    private scheduleEventPropagationToLayoutManager(name: string, event: EventEmitter.BubblingEvent) {\n        if (this._throttledEvents.indexOf(name) === -1) {\n            this.layoutManager.emitUnknown(name, event);\n        } else {\n            if (this._pendingEventPropagations[name] !== true) {\n                this._pendingEventPropagations[name] = true;\n                globalThis.requestAnimationFrame(() => this.propagateEventToLayoutManager(name, event));\n            }\n        }\n\n    }\n\n    /**\n     * Callback for events scheduled by _scheduleEventPropagationToLayoutManager\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    private propagateEventToLayoutManager(name: string, event: EventEmitter.BubblingEvent) {\n        this._pendingEventPropagations[name] = false;\n        this.layoutManager.emitUnknown(name, event);\n    }\n}\n\n/** @public */\nexport namespace ContentItem {\n    /** @internal */\n    export interface Area extends AreaLinkedRect {\n        surface: number;\n        contentItem: ContentItem;\n    }\n}\n\n/** @public @deprecated Use {@link (ContentItem:class)} */\nexport type AbstractContentItem = ContentItem;\n","import { ResolvedComponentItemConfig, ResolvedHeaderedItemConfig } from '../config/resolved-config';\nimport { ComponentContainer } from '../container/component-container';\nimport { Tab } from '../controls/tab';\nimport { UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { ItemType, JsonValue } from '../utils/types';\nimport { getElementWidthAndHeight, setElementHeight, setElementWidth } from '../utils/utils';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\n\n/** @public */\nexport class ComponentItem extends ContentItem {\n    /** @internal */\n    private _reorderEnabled: boolean;\n    /** @internal */\n    private _headerConfig: ResolvedHeaderedItemConfig.Header | undefined;\n    /** @internal */\n    private _title: string;\n    /** @internal */\n    private readonly _initialWantMaximise: boolean;\n    /** @internal */\n    private _container: ComponentContainer;\n    /** @internal */\n    private _tab: Tab;\n    /** @internal */\n    private _focused = false;\n\n    /** @internal @deprecated use {@link (ComponentItem:class).componentType} */\n    get componentName(): JsonValue { return this._container.componentType; }\n    get componentType(): JsonValue { return this._container.componentType; }\n    get reorderEnabled(): boolean { return this._reorderEnabled; }\n    /** @internal */\n    get initialWantMaximise(): boolean { return this._initialWantMaximise; }\n    get component(): ComponentContainer.Component | undefined { return this._container.component; }\n    get container(): ComponentContainer { return this._container; }\n    get parentItem(): ComponentParentableItem { return this._parentItem; }\n\n    get headerConfig(): ResolvedHeaderedItemConfig.Header | undefined { return this._headerConfig; }\n    get title(): string { return this._title; }\n    get tab(): Tab { return this._tab; }\n    get focused(): boolean { return this._focused; }\n\n    /** @internal */\n    constructor(\n        layoutManager: LayoutManager,\n        config: ResolvedComponentItemConfig,\n        /** @internal */\n        private _parentItem: ComponentParentableItem\n    ) {\n        super(layoutManager, config, _parentItem, document.createElement('div'));\n\n        this.isComponent = true;\n\n        this._reorderEnabled = config.reorderEnabled;\n\n        this.applyUpdatableConfig(config);\n\n        this._initialWantMaximise = config.maximised;\n\n        const containerElement = document.createElement('div');\n        containerElement.classList.add(DomConstants.ClassName.Content);\n        this.element.appendChild(containerElement);\n        this._container = new ComponentContainer(config, this, layoutManager, containerElement,\n            (itemConfig) => this.handleUpdateItemConfigEvent(itemConfig),\n            () => this.show(),\n            () => this.hide(),\n            (suppressEvent) => this.focus(suppressEvent),\n            (suppressEvent) => this.blur(suppressEvent),\n        );\n    }\n\n    /** @internal */\n    override destroy(): void {\n        this._container.destroy()\n        super.destroy();\n    }\n\n    applyUpdatableConfig(config: ResolvedComponentItemConfig): void {\n        this.setTitle(config.title);\n        this._headerConfig = config.header;\n    }\n\n    toConfig(): ResolvedComponentItemConfig {\n        const stateRequestEvent = this._container.stateRequestEvent;\n        const state = stateRequestEvent === undefined ? this._container.state : stateRequestEvent();\n\n        const result: ResolvedComponentItemConfig = {\n            type: ItemType.component,\n            content: [],\n            width: this.width,\n            minWidth: this.minWidth,\n            height: this.height,\n            minHeight: this.minHeight,\n            id: this.id,\n            maximised: false,\n            isClosable: this.isClosable,\n            reorderEnabled: this._reorderEnabled,\n            title: this._title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig),\n            componentType: ResolvedComponentItemConfig.copyComponentType(this.componentType),\n            componentState: state,\n        }\n\n        return result;\n    }\n\n    close(): void {\n        if (this.parent === null) {\n            throw new UnexpectedNullError('CIC68883');\n        } else {\n            this.parent.removeChild(this, false);\n        }\n    }\n\n    // Used by Drag Proxy\n    /** @internal */\n    enterDragMode(width: number, height: number): void {\n        setElementWidth(this.element, width);\n        setElementHeight(this.element, height);\n        this._container.enterDragMode(width, height);\n    }\n\n    /** @internal */\n    exitDragMode(): void {\n        this._container.exitDragMode();\n    }\n\n    /** @internal */\n    enterStackMaximised(): void {\n        this._container.enterStackMaximised();\n    }\n\n    /** @internal */\n    exitStackMaximised(): void {\n        this._container.exitStackMaximised();\n    }\n\n    // Used by Drag Proxy\n    /** @internal */\n    drag(): void {\n        this._container.drag();\n    }\n\n    /** @internal */\n    override updateSize(force: boolean): void {\n        this.updateNodeSize(force);\n    }\n\n    /** @internal */\n    override init(): void {\n        this.updateNodeSize(false);\n\n        super.init();\n        this._container.emit('open');\n        this.initContentItems();\n    }\n\n    /**\n     * Set this component's title\n     *\n     * @public\n     * @param title -\n     */\n\n    setTitle(title: string): void {\n        this._title = title;\n        this.emit('titleChanged', title);\n        this.emit('stateChanged');\n    }\n\n    setTab(tab: Tab): void {\n        this._tab = tab;\n        this.emit('tab', tab)\n        this._container.setTab(tab);\n    }\n\n    /** @internal */\n    override hide(): void {\n        super.hide();\n        this._container.setVisibility(false);\n    }\n\n    /** @internal */\n    override show(): void {\n        super.show();\n        this._container.setVisibility(true);\n    }\n\n    /**\n     * Focuses the item if it is not already focused\n     */\n    focus(suppressEvent = false): void {\n        this.parentItem.setActiveComponentItem(this, true, suppressEvent);\n    }\n\n    /** @internal */\n    setFocused(suppressEvent: boolean): void {\n        this._focused = true;\n        this.tab.setFocused();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('focus');\n        }\n    }\n\n    /**\n     * Blurs (defocuses) the item if it is focused\n     */\n    blur(suppressEvent = false): void {\n        if (this._focused) {\n            this.layoutManager.setFocusedComponentItem(undefined, suppressEvent);\n        }\n    }\n\n    /** @internal */\n    setBlurred(suppressEvent: boolean): void {\n        this._focused = false;\n        this.tab.setBlurred();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('blur');\n        }\n    }\n\n    /** @internal */\n    protected override setParent(parent: ContentItem): void {\n        this._parentItem = parent as ComponentParentableItem;\n        super.setParent(parent);\n    }\n\n    /** @internal */\n    private handleUpdateItemConfigEvent(itemConfig: ResolvedComponentItemConfig) {\n        this.applyUpdatableConfig(itemConfig);\n    }\n\n    /** @internal */\n    private updateNodeSize(force: boolean): void {\n        if (this.element.style.display !== 'none') {\n            // Do not update size of hidden components to prevent unwanted reflows\n\n            const { width, height } = getElementWidthAndHeight(this.element);\n            this._container.setSizeToNodeSize(width, height, force);\n        }\n    }\n}\n\n/** @public @deprecated use {@link (ComponentItem:class)} */\nexport type Component = ComponentItem;\n\n/** @public */\nexport namespace ComponentItem {\n    export type Component = ComponentContainer.Component;\n}\n","import { ComponentItem } from './component-item';\nimport { ContentItem } from './content-item';\n\nexport abstract class ComponentParentableItem extends ContentItem {\n    /** @internal */\n    private _focused = false;\n\n    get focused(): boolean { return this._focused; }\n\n    /** @internal */\n    setFocusedValue(value: boolean): void {\n        this._focused = value;\n    }\n\n    abstract setActiveComponentItem(item: ComponentItem, focus: boolean, suppressFocusEvent: boolean): void;\n}\n","import { ComponentItemConfig, ItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig, ResolvedHeaderedItemConfig, ResolvedItemConfig, ResolvedStackItemConfig } from '../config/resolved-config';\nimport { Header } from '../controls/header';\nimport { AssertError, UnexpectedNullError, UnexpectedUndefinedError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { getJQueryOffset } from '../utils/jquery-legacy';\nimport { AreaLinkedRect, ItemType, JsonValue, Side, WidthAndHeight, WidthOrHeightPropertyName } from '../utils/types';\nimport {\n    getElementHeight,\n    getElementWidth,\n    getElementWidthAndHeight,\n    numberToPixels,\n    setElementDisplayVisibility\n} from '../utils/utils';\nimport { ComponentItem } from './component-item';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\n\n/** @public */\nexport class Stack extends ComponentParentableItem {\n    /** @internal */\n    private readonly _headerConfig: ResolvedHeaderedItemConfig.Header | undefined;\n    /** @internal */\n    private readonly _header: Header;\n    /** @internal */\n    private readonly _childElementContainer: HTMLElement;\n    /** @internal */\n    private readonly _maximisedEnabled: boolean;\n    /** @internal */\n    private _activeComponentItem: ComponentItem | undefined;\n    /** @internal */\n    private _dropSegment: Stack.Segment;\n    /** @internal */\n    private _dropIndex: number;\n    /** @internal */\n    private _contentAreaDimensions: Stack.ContentAreaDimensions;\n    /** @internal */\n    private _headerSideChanged = false;\n    /** @internal */\n    private readonly _initialWantMaximise: boolean;\n    /** @internal */\n    private _initialActiveItemIndex: number;\n\n    /** @internal */\n    private _resizeListener = () => this.handleResize();\n    /** @internal */\n    private _maximisedListener = () => this.handleMaximised();\n    /** @internal */\n    private _minimisedListener = () => this.handleMinimised();\n\n    get childElementContainer(): HTMLElement { return this._childElementContainer; }\n    get header(): Header { return this._header; }\n    get headerShow(): boolean { return this._header.show; }\n    get headerSide(): Side { return this._header.side; }\n    get headerLeftRightSided(): boolean { return this._header.leftRightSided; }\n    /** @internal */\n    get contentAreaDimensions(): Stack.ContentAreaDimensions | undefined { return this._contentAreaDimensions; }\n    /** @internal */\n    get initialWantMaximise(): boolean { return this._initialWantMaximise; }\n    get isMaximised(): boolean { return this === this.layoutManager.maximisedStack; }\n    get stackParent(): ContentItem {\n        if (!this.parent) {\n            throw new Error('Stack should always have a parent');\n        }\n        return this.parent;\n    }\n\n    /** @internal */\n    constructor(layoutManager: LayoutManager, config: ResolvedStackItemConfig, parent: ContentItem) {\n        super(layoutManager, config, parent, Stack.createElement(document));\n\n        this._headerConfig = config.header;\n        const layoutHeaderConfig = layoutManager.layoutConfig.header;\n        const configContent = config.content;\n        // If stack has only one component, then we can also check this for header settings\n        let componentHeaderConfig: ResolvedHeaderedItemConfig.Header | undefined;\n        if (configContent.length !== 1) {\n            componentHeaderConfig = undefined;\n        } else {\n            const firstChildItemConfig = configContent[0];\n            componentHeaderConfig = (firstChildItemConfig as ResolvedHeaderedItemConfig).header; // will be undefined if not component (and wont be stack)\n        }\n\n        this._initialWantMaximise = config.maximised;\n        this._initialActiveItemIndex = config.activeItemIndex ?? 0; // make sure defined\n\n        // check for defined value for each item in order of Stack (this Item), Component (first child), Manager.\n        const show = this._headerConfig?.show ?? componentHeaderConfig?.show ?? layoutHeaderConfig.show;\n        const popout = this._headerConfig?.popout ?? componentHeaderConfig?.popout ?? layoutHeaderConfig.popout;\n        const maximise = this._headerConfig?.maximise ?? componentHeaderConfig?.maximise ?? layoutHeaderConfig.maximise;\n        const close = this._headerConfig?.close ?? componentHeaderConfig?.close ?? layoutHeaderConfig.close;\n        const minimise = this._headerConfig?.minimise ?? componentHeaderConfig?.minimise ?? layoutHeaderConfig.minimise;\n        const tabDropdown = this._headerConfig?.tabDropdown ?? componentHeaderConfig?.tabDropdown ?? layoutHeaderConfig.tabDropdown;\n        this._maximisedEnabled = maximise !== false;\n        const headerSettings: Header.Settings = {\n            show: show !== false,\n            side: show === false ? Side.top : show,\n            popoutEnabled: popout !== false,\n            popoutLabel: popout === false ? '' : popout,\n            maximiseEnabled: this._maximisedEnabled,\n            maximiseLabel: maximise === false ? '' : maximise,\n            closeEnabled: close !== false,\n            closeLabel: close === false ? '' : close,\n            minimiseEnabled: true,\n            minimiseLabel: minimise,\n            tabDropdownEnabled: tabDropdown !== false,\n            tabDropdownLabel: tabDropdown === false ? '' : tabDropdown,\n        };\n\n        this._header = new Header(layoutManager,\n            this, headerSettings,\n            config.isClosable && close !== false,\n            () => this.getActiveComponentItem(),\n            () => this.remove(),\n            () => this.handlePopoutEvent(),\n            () => this.toggleMaximise(),\n            (ev) => this.handleHeaderClickEvent(ev),\n            (ev) => this.handleHeaderTouchStartEvent(ev),\n            (item) => this.handleHeaderComponentRemoveEvent(item),\n            (item) => this.handleHeaderComponentFocusEvent(item),\n            (x, y, dragListener, item) => this.handleHeaderComponentStartDragEvent(x, y, dragListener, item),\n        );\n\n        // this._dropZones = {};\n\n        this.isStack = true;\n\n        this._childElementContainer = document.createElement('section');\n        this._childElementContainer.classList.add(DomConstants.ClassName.Items);\n\n        this.on('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.on('maximised', this._maximisedListener);\n            this.on('minimised', this._minimisedListener);\n        }\n\n        this.element.appendChild(this._header.element);\n        this.element.appendChild(this._childElementContainer);\n\n        this.setupHeaderPosition();\n        this._header.updateClosability();\n    }\n\n    /** @internal */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /** @internal */\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        const contentItems = this.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount > 0) { // contentItemCount will be 0 on drag drop\n            if (this._initialActiveItemIndex < 0 || this._initialActiveItemIndex >= contentItemCount) {\n                throw new Error(`ActiveItemIndex out of range: ${this._initialActiveItemIndex} id: ${this.id}`);\n            } else {\n                for (let i = 0; i < contentItemCount; i++) {\n                    const contentItem = contentItems[i];\n                    if (!(contentItem instanceof ComponentItem)) {\n                        throw new Error(`Stack Content Item is not of type ComponentItem: ${i} id: ${this.id}`);\n                    } else {\n                        this._header.createTab(contentItem, i);\n                        contentItem.hide();\n                        contentItem.container.setBaseLogicalZIndex();\n                    }\n                }\n\n                this.setActiveComponentItem(contentItems[this._initialActiveItemIndex] as ComponentItem, false);\n\n                this._header.updateTabSizes();\n            }\n        }\n\n        this._header.updateClosability();\n        this.initContentItems();\n    }\n\n    /** @deprecated Use {@link (Stack:class).setActiveComponentItem} */\n    setActiveContentItem(item: ContentItem): void {\n        if (!ContentItem.isComponentItem(item)) {\n            throw new Error('Stack.setActiveContentItem: item is not a ComponentItem');\n        } else {\n            this.setActiveComponentItem(item, false);\n        }\n    }\n\n    setActiveComponentItem(componentItem: ComponentItem, focus: boolean, suppressFocusEvent = false): void {\n        if (this._activeComponentItem !== componentItem) {\n            if (this.contentItems.indexOf(componentItem) === -1) {\n                throw new Error('componentItem is not a child of this stack');\n            } else {\n                this.layoutManager.beginSizeInvalidation();\n                try {\n                    if (this._activeComponentItem !== undefined) {\n                        this._activeComponentItem.hide();\n                    }\n                    this._activeComponentItem = componentItem;\n                    this._header.processActiveComponentChanged(componentItem);\n                    componentItem.show();\n                } finally {\n                    this.layoutManager.endSizeInvalidation();\n                }\n\n                this.emit('activeContentItemChanged', componentItem);\n                this.layoutManager.emit('activeContentItemChanged', componentItem);\n                this.emitStateChangedEvent();\n            }\n        }\n\n        if (this.focused || focus) {\n            this.layoutManager.setFocusedComponentItem(componentItem, suppressFocusEvent);\n        }\n    }\n\n    /** @deprecated Use {@link (Stack:class).getActiveComponentItem} */\n    getActiveContentItem(): ContentItem | null {\n        return this.getActiveComponentItem() ?? null;\n    }\n\n    getActiveComponentItem(): ComponentItem | undefined {\n        return this._activeComponentItem;\n    }\n\n    /** @internal */\n    focusActiveContentItem(): void {\n        this._activeComponentItem?.focus();\n    }\n\n    /** @internal */\n    override setFocusedValue(value: boolean): void {\n        this._header.applyFocusedValue(value);\n        super.setFocusedValue(value);\n    }\n\n    /** @internal */\n    setRowColumnClosable(value: boolean): void {\n        this._header.setRowColumnClosable(value);\n    }\n\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): ComponentItem {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index) as ComponentItem;\n    }\n\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): number {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n\n    newItem(itemConfig: ComponentItemConfig,  index?: number): ContentItem {\n        index = this.addItem(itemConfig, index);\n        return this.contentItems[index];\n    }\n\n    addItem(itemConfig: ComponentItemConfig, index?: number): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index);\n    }\n\n    override addChild(contentItem: ContentItem, index?: number, focus = false): number {\n        if(index !== undefined && index > this.contentItems.length){\n            index -= 1;\n            throw new AssertError('SAC99728'); // undisplayChild() removed so this condition should no longer occur\n        }\n\n        if (!(contentItem instanceof ComponentItem)) {\n            throw new AssertError('SACC88532'); // Stacks can only have Component children\n        } else {\n            index = super.addChild(contentItem, index);\n            this._childElementContainer.appendChild(contentItem.element);\n            this._header.createTab(contentItem, index);\n            this.setActiveComponentItem(contentItem, focus);\n            this._header.updateTabSizes();\n            this.updateSize(false);\n            contentItem.container.setBaseLogicalZIndex();\n            this._header.updateClosability();\n            this.emitStateChangedEvent();\n            return index;\n        }\n    }\n\n    override removeChild(contentItem: ContentItem, keepChild: boolean): void {\n        const componentItem = contentItem as ComponentItem;\n        const index = this.contentItems.indexOf(componentItem);\n        const stackWillBeDeleted = this.contentItems.length === 1;\n\n        if (this._activeComponentItem === componentItem) {\n            if (componentItem.focused) {\n                componentItem.blur();\n            }\n            if (!stackWillBeDeleted) {\n                // At this point we're already sure we have at least one content item left *after*\n                // removing contentItem, so we can safely assume index 1 is a valid one if\n                // the index of contentItem is 0, otherwise we just use the previous content item.\n                const newActiveComponentIdx = index === 0 ? 1 : index - 1;\n                this.setActiveComponentItem(this.contentItems[newActiveComponentIdx] as ComponentItem, false);\n            }\n        }\n\n        this._header.removeTab(componentItem);\n\n        super.removeChild(componentItem, keepChild);\n\n        if (!stackWillBeDeleted) {\n            this._header.updateClosability();\n        }\n\n        this.emitStateChangedEvent();\n    }\n\n    /**\n     * Maximises the Item or minimises it if it is already maximised\n     */\n    toggleMaximise(): void {\n        if (this.isMaximised) {\n            this.minimise();\n        } else {\n            this.maximise();\n        }\n    }\n\n    maximise(): void {\n        if (!this.isMaximised) {\n            this.layoutManager.setMaximisedStack(this);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof ComponentItem) {\n                    contentItem.enterStackMaximised();\n                } else {\n                    throw new AssertError('SMAXI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n\n    minimise(): void {\n        if (this.isMaximised) {\n            this.layoutManager.setMaximisedStack(undefined);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof ComponentItem) {\n                    contentItem.exitStackMaximised();\n                } else {\n                    throw new AssertError('SMINI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n\n    /** @internal */\n    override destroy(): void {\n        if (this._activeComponentItem?.focused) {\n            this._activeComponentItem.blur();\n        }\n        super.destroy();\n        this.off('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.off('maximised', this._maximisedListener);\n            this.off('minimised', this._minimisedListener);\n        }\n        this._header.destroy();\n    }\n\n    toConfig(): ResolvedStackItemConfig {\n        let activeItemIndex: number | undefined;\n        if (this._activeComponentItem) {\n            activeItemIndex = this.contentItems.indexOf(this._activeComponentItem);\n            if (activeItemIndex < 0) {\n                throw new Error('active component item not found in stack');\n            }\n        }\n        if (this.contentItems.length > 0 && activeItemIndex === undefined) {\n            throw new Error('expected non-empty stack to have an active component item');\n        } else {\n            const result: ResolvedStackItemConfig = {\n                type: 'stack',\n                content: this.calculateConfigContent() as ResolvedComponentItemConfig[],\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n                id: this.id,\n                isClosable: this.isClosable,\n                maximised: this.isMaximised,\n                header: this.createHeaderConfig(),\n                activeItemIndex,\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Ok, this one is going to be the tricky one: The user has dropped a {@link (ContentItem:class)} onto this stack.\n     *\n     * It was dropped on either the stacks header or the top, right, bottom or left bit of the content area\n     * (which one of those is stored in this._dropSegment). Now, if the user has dropped on the header the case\n     * is relatively clear: We add the item to the existing stack... job done (might be good to have\n     * tab reordering at some point, but lets not sweat it right now)\n     *\n     * If the item was dropped on the content part things are a bit more complicated. If it was dropped on either the\n     * top or bottom region we need to create a new column and place the items accordingly.\n     * Unless, of course if the stack is already within a column... in which case we want\n     * to add the newly created item to the existing column...\n     * either prepend or append it, depending on wether its top or bottom.\n     *\n     * Same thing for rows and left / right drop segments... so in total there are 9 things that can potentially happen\n     * (left, top, right, bottom) * is child of the right parent (row, column) + header drop\n     *\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    override onDrop(contentItem: ContentItem, area: ContentItem.Area): void {\n        /*\n         * The item was dropped on the header area. Just add it as a child of this stack and\n         * get the hell out of this logic\n         */\n        if (this._dropSegment === Stack.Segment.Header) {\n            this.resetHeaderDropZone();\n            if (this._dropIndex === undefined) {\n                throw new UnexpectedUndefinedError('SODDI68990');\n            } else {\n                this.addChild(contentItem, this._dropIndex);\n                return;\n            }\n        }\n\n        /*\n         * The stack is empty. Let's just add the element.\n         */\n        if (this._dropSegment === Stack.Segment.Body) {\n            this.addChild(contentItem, 0, true);\n            return;\n        }\n\n        /*\n         * The item was dropped on the top-, left-, bottom- or right- part of the content. Let's\n         * aggregate some conditions to make the if statements later on more readable\n         */\n        const isVertical = this._dropSegment === Stack.Segment.Top || this._dropSegment === Stack.Segment.Bottom;\n        const isHorizontal = this._dropSegment === Stack.Segment.Left || this._dropSegment === Stack.Segment.Right;\n        const insertBefore = this._dropSegment === Stack.Segment.Top || this._dropSegment === Stack.Segment.Left;\n        const hasCorrectParent = (isVertical && this.stackParent.isColumn) || (isHorizontal && this.stackParent.isRow);\n        const dimension = isVertical ? 'height' : 'width';\n\n        /*\n         * The content item can be either a component or a stack. If it is a component, wrap it into a stack\n         */\n        if (contentItem.isComponent) {\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n\n\n        /*\n         * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n         * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n         * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n         */\n        if(contentItem.type === ItemType.row || contentItem.type === ItemType.column){\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createContentItem(itemConfig, this);\n            stack.addChild(contentItem)\n            contentItem = stack\n        }\n\n        /*\n         * If the item is dropped on top or bottom of a column or left and right of a row, it's already\n         * layd out in the correct way. Just add it as a child\n         */\n        if (hasCorrectParent) {\n            const index = this.stackParent.contentItems.indexOf(this);\n            this.stackParent.addChild(contentItem, insertBefore ? index : index + 1, true);\n            this[dimension] *= 0.5;\n            contentItem[dimension] = this[dimension];\n            this.stackParent.updateSize(false);\n            /*\n             * This handles items that are dropped on top or bottom of a row or left / right of a column. We need\n             * to create the appropriate contentItem for them to live in\n             */\n        } else {\n            const type = isVertical ? ItemType.column : ItemType.row;\n            const itemConfig = ResolvedItemConfig.createDefault(type) as ResolvedItemConfig;\n            const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n            this.stackParent.replaceChild(this, rowOrColumn);\n\n            rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n            rowOrColumn.addChild(this, insertBefore ? undefined : 0, true);\n\n            this[dimension] = 50;\n            contentItem[dimension] = 50;\n            rowOrColumn.updateSize(false);\n        }\n    }\n\n    /**\n     * If the user hovers above the header part of the stack, indicate drop positions for tabs.\n     * otherwise indicate which segment of the body the dragged item would be dropped on\n     *\n     * @param x - Absolute Screen X\n     * @param y - Absolute Screen Y\n     * @internal\n     */\n    override highlightDropZone(x: number, y: number): void {\n        for (const key in this._contentAreaDimensions) {\n            const segment = key as Stack.Segment;\n            const area = this._contentAreaDimensions[segment].hoverArea;\n\n            if (area.x1 < x && area.x2 > x && area.y1 < y && area.y2 > y) {\n\n                if (segment === Stack.Segment.Header) {\n                    this._dropSegment = Stack.Segment.Header;\n                    this.highlightHeaderDropZone(this._header.leftRightSided ? y : x);\n                } else {\n                    this.resetHeaderDropZone();\n                    this.highlightBodyDropZone(segment);\n                }\n\n                return;\n            }\n        }\n    }\n\n    /** @internal */\n    getArea(): ContentItem.Area | null {\n        if (this.element.style.display === 'none') {\n            return null;\n        }\n\n        const headerArea = super.getElementArea(this._header.element);\n        const contentArea = super.getElementArea(this._childElementContainer);\n        if (headerArea === null || contentArea === null) {\n            throw new UnexpectedNullError('SGAHC13086');\n        }\n        const contentWidth = contentArea.x2 - contentArea.x1;\n        const contentHeight = contentArea.y2 - contentArea.y1;\n\n        this._contentAreaDimensions = {\n            header: {\n                hoverArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                },\n                highlightArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                }\n            }\n        };\n\n        /**\n         * Highlight the entire body if the stack is empty\n         */\n        if (this.contentItems.length === 0) {\n\n            this._contentAreaDimensions.body = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            return super.getElementArea(this.element);\n        } else {\n            this._contentAreaDimensions.left = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.25,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.5,\n                    y2: contentArea.y2\n                }\n            };\n\n            this._contentAreaDimensions.top = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                }\n            };\n\n            this._contentAreaDimensions.right = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.75,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1 + contentWidth * 0.5,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            this._contentAreaDimensions.bottom = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            return super.getElementArea(this.element);\n        }\n    }\n\n    /**\n     * Programmatically operate with header position.\n     *\n     * @param position -\n     *\n     * @returns previous header position\n     * @internal\n     */\n    positionHeader(position: Side): void {\n        if (this._header.side !== position) {\n            this._header.setSide(position);\n            this._headerSideChanged = true;\n            this.setupHeaderPosition();\n        }\n    }\n\n    /** @internal */\n    private updateNodeSize(): void {\n        if (this.element.style.display !== 'none') {\n            const content: WidthAndHeight = getElementWidthAndHeight(this.element);\n\n            if (this._header.show) {\n                const dimension = this._header.leftRightSided ? WidthOrHeightPropertyName.width : WidthOrHeightPropertyName.height;\n                content[dimension] -= this.layoutManager.layoutConfig.dimensions.headerHeight;\n            }\n            this._childElementContainer.style.width = numberToPixels(content.width);\n            this._childElementContainer.style.height = numberToPixels(content.height);\n            for (let i = 0; i < this.contentItems.length; i++) {\n                this.contentItems[i].element.style.width = numberToPixels(content.width);\n                this.contentItems[i].element.style.height = numberToPixels(content.height);\n            }\n            this.emit('resize');\n            this.emitStateChangedEvent();\n        }\n    }\n\n    /** @internal */\n    private highlightHeaderDropZone(x: number): void {\n        // Only walk over the visible tabs\n        const tabsLength = this._header.lastVisibleTabIndex + 1;\n\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('SHHDZDTI97110');\n        }\n\n        let area: AreaLinkedRect;\n\n        // Empty stack\n        if (tabsLength === 0) {\n            const headerOffset = getJQueryOffset(this._header.element);\n\n            const elementHeight = getElementHeight(this._header.element);\n            area = {\n                x1: headerOffset.left,\n                x2: headerOffset.left + 100,\n                y1: headerOffset.top + elementHeight - 20,\n                y2: headerOffset.top + elementHeight,\n            };\n\n            this._dropIndex = 0;\n        } else {\n            let tabIndex = 0;\n            // This indicates whether our cursor is exactly over a tab\n            let isAboveTab = false;\n            let tabTop: number;\n            let tabLeft: number;\n            let tabWidth: number;\n            let tabElement: HTMLElement;\n            do {\n                tabElement = this._header.tabs[tabIndex].element;\n                const offset = getJQueryOffset(tabElement);\n                if (this._header.leftRightSided) {\n                    tabLeft = offset.top;\n                    tabTop = offset.left;\n                    tabWidth = getElementHeight(tabElement);\n                } else {\n                    tabLeft = offset.left;\n                    tabTop = offset.top;\n                    tabWidth = getElementWidth(tabElement);\n                }\n\n                if (x >= tabLeft && x < tabLeft + tabWidth) {\n                    isAboveTab = true;\n                } else {\n                    tabIndex++;\n                }\n            } while (tabIndex < tabsLength && !isAboveTab);\n\n            // If we're not above any tabs, or to the right of any tab, we are out of the area, so give up\n            if (isAboveTab === false && x < tabLeft) {\n                return;\n            }\n\n            const halfX = tabLeft + tabWidth / 2;\n\n            if (x < halfX) {\n                this._dropIndex = tabIndex;\n                tabElement.insertAdjacentElement('beforebegin', this.layoutManager.tabDropPlaceholder);\n            } else {\n                this._dropIndex = Math.min(tabIndex + 1, tabsLength);\n                tabElement.insertAdjacentElement('afterend', this.layoutManager.tabDropPlaceholder);\n            }\n\n            const tabDropPlaceholderOffset = getJQueryOffset(this.layoutManager.tabDropPlaceholder);\n            const tabDropPlaceholderWidth = getElementWidth(this.layoutManager.tabDropPlaceholder)\n            if (this._header.leftRightSided) {\n                const placeHolderTop = tabDropPlaceholderOffset.top;\n                area = {\n                    x1: tabTop,\n                    x2: tabTop + tabElement.clientHeight,\n                    y1: placeHolderTop,\n                    y2: placeHolderTop + tabDropPlaceholderWidth,\n                };\n            } else {\n                const placeHolderLeft = tabDropPlaceholderOffset.left;\n\n                area = {\n                    x1: placeHolderLeft,\n                    x2: placeHolderLeft + tabDropPlaceholderWidth,\n                    y1: tabTop,\n                    y2: tabTop + tabElement.clientHeight,\n                };\n            }\n        }\n\n        dropTargetIndicator.highlightArea(area);\n        return;\n    }\n\n    /** @internal */\n    private resetHeaderDropZone() {\n        this.layoutManager.tabDropPlaceholder.remove();\n    }\n\n    /** @internal */\n    private setupHeaderPosition() {\n        setElementDisplayVisibility(this._header.element, this._header.show);\n        this.element.classList.remove(DomConstants.ClassName.Left, DomConstants.ClassName.Right, DomConstants.ClassName.Bottom);\n        if (this._header.leftRightSided) {\n            this.element.classList.add('lm_' + this._header.side);\n        }\n\n        //if ([Side.right, Side.bottom].includes(this._header.side)) {\n        //    // move the header behind the content.\n        //    this.element.appendChild(this._header.element);\n        //}\n        this.updateSize(false);\n    }\n\n    /** @internal */\n    private highlightBodyDropZone(segment: Stack.Segment): void {\n        if (this._contentAreaDimensions === undefined) {\n            throw new UnexpectedUndefinedError('SHBDZC82265');\n        } else {\n            const highlightArea = this._contentAreaDimensions[segment].highlightArea;\n            const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n            if (dropTargetIndicator === null) {\n                throw new UnexpectedNullError('SHBDZD96110');\n            } else {\n                dropTargetIndicator.highlightArea(highlightArea);\n                this._dropSegment = segment;\n            }\n        }\n    }\n\n    /** @internal */\n    private handleResize() {\n        this._header.updateTabSizes()\n    }\n\n    /** @internal */\n    private handleMaximised() {\n        this._header.processMaximised();\n    }\n\n    /** @internal */\n    private handleMinimised() {\n        this._header.processMinimised();\n    }\n\n    /** @internal */\n    private handlePopoutEvent() {\n        this.popout();\n    }\n\n    /** @internal */\n    private handleHeaderClickEvent(ev: MouseEvent) {\n        const eventName = EventEmitter.headerClickEventName;\n        const bubblingEvent = new EventEmitter.ClickBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n\n    /** @internal */\n    private handleHeaderTouchStartEvent(ev: TouchEvent) {\n        const eventName = EventEmitter.headerTouchStartEventName;\n        const bubblingEvent = new EventEmitter.TouchStartBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n\n    /** @internal */\n    private handleHeaderComponentRemoveEvent(item: ComponentItem) {\n        this.removeChild(item, false);\n    }\n\n    /** @internal */\n    private handleHeaderComponentFocusEvent(item: ComponentItem) {\n        this.setActiveComponentItem(item, true);\n    }\n\n    /** @internal */\n    private handleHeaderComponentStartDragEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        if (this.isMaximised === true) {\n            this.toggleMaximise();\n        }\n        this.layoutManager.startComponentDrag(x, y, dragListener, componentItem, this);\n    }\n\n    /** @internal */\n    private createHeaderConfig() {\n        if (!this._headerSideChanged) {\n            return ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig);\n        } else {\n            const show = this._header.show ? this._header.side : false;\n\n            let result = ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig, show);\n            if (result === undefined) {\n                result = {\n                    show,\n                    popout: undefined,\n                    maximise: undefined,\n                    close: undefined,\n                    minimise: undefined,\n                    tabDropdown: undefined,\n                };\n            }\n            return result;\n        }\n    }\n\n    /** @internal */\n    private emitStateChangedEvent() {\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n}\n\n/** @public */\nexport namespace Stack {\n    /** @internal */\n    export const enum Segment {\n        Header = 'header',\n        Body = 'body',\n        Left = 'left',\n        Right = 'right',\n        Top = 'top',\n        Bottom = 'bottom',\n    }\n\n    /** @internal */\n    export interface ContentAreaDimension {\n        hoverArea: AreaLinkedRect;\n        highlightArea: AreaLinkedRect;\n    }\n\n    /** @internal */\n    export type ContentAreaDimensions = {\n        [segment: string]: ContentAreaDimension;\n    };\n\n    /** @internal */\n    export function createElement(document: Document): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.Item);\n        element.classList.add(DomConstants.ClassName.Stack);\n        return element;\n    }\n}\n","import { UnexpectedNullError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { ContentItem } from '../items/content-item';\nimport { Stack } from '../items/stack';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { getJQueryOffset } from '../utils/jquery-legacy';\nimport { Side } from '../utils/types';\nimport {\n    getElementWidthAndHeight,\n    numberToPixels\n} from '../utils/utils';\n\n/**\n * This class creates a temporary container\n * for the component whilst it is being dragged\n * and handles drag events\n * @internal\n */\nexport class DragProxy extends EventEmitter {\n    private _area: ContentItem.Area | null = null;\n    private _lastValidArea: ContentItem.Area | null = null;\n    private _minX: number;\n    private _minY: number;\n    private _maxX: number;\n    private _maxY: number;\n    private _sided: boolean;\n    private _element: HTMLElement;\n    private _proxyContainerElement: HTMLElement;\n    private _componentItemFocused: boolean;\n\n    get element(): HTMLElement { return this._element; }\n\n    /**\n     * @param x - The initial x position\n     * @param y - The initial y position\n     * @internal\n     */\n    constructor(x: number, y: number,\n        private readonly _dragListener: DragListener,\n        private readonly _layoutManager: LayoutManager,\n        private readonly _componentItem: ComponentItem,\n        private readonly _originalParent: ContentItem) {\n\n        super();\n\n        this._dragListener.on('drag', (offsetX, offsetY, event) => this.onDrag(offsetX, offsetY, event));\n        this._dragListener.on('dragStop', () => this.onDrop());\n\n        this.createDragProxyElements(x, y);\n\n        if (this._componentItem.parent === null) {\n            // Note that _contentItem will have dummy GroundItem as parent if initiated by a external drag source\n            throw new UnexpectedNullError('DPC10097');\n        }\n\n        this._componentItemFocused = this._componentItem.focused;\n        if (this._componentItemFocused) {\n            this._componentItem.blur();\n        }\n        this._componentItem.parent.removeChild(this._componentItem, true);\n\n        this.setDimensions();\n\n        document.body.appendChild(this._element);\n\n        this.determineMinMaxXY();\n        if (this._layoutManager.layoutConfig.settings.constrainDragToContainer) {\n            const constrainedPosition = this.getXYWithinMinMax(x, y);\n            x = constrainedPosition.x;\n            y = constrainedPosition.y;\n        }\n\n        this._layoutManager.calculateItemAreas();\n        this.setDropPosition(x, y);\n    }\n\n    /** Create Stack-like structure to contain the dragged component */\n    private createDragProxyElements(initialX: number, initialY: number): void {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.DragProxy);\n        const headerElement = document.createElement('div');\n        headerElement.classList.add(DomConstants.ClassName.Header);\n        const tabsElement = document.createElement('div');\n        tabsElement.classList.add(DomConstants.ClassName.Tabs);\n        const tabElement = document.createElement('div');\n        tabElement.classList.add(DomConstants.ClassName.Tab);\n        const titleElement = document.createElement('span');\n        titleElement.classList.add(DomConstants.ClassName.Title);\n        tabElement.appendChild(titleElement);\n        tabsElement.appendChild(tabElement);\n        headerElement.appendChild(tabsElement);\n\n        this._proxyContainerElement = document.createElement('div');\n        this._proxyContainerElement.classList.add(DomConstants.ClassName.Content);\n\n        this._element.appendChild(headerElement);\n        this._element.appendChild(this._proxyContainerElement);\n\n        if (this._originalParent instanceof Stack && this._originalParent.headerShow) {\n            this._sided = this._originalParent.headerLeftRightSided;\n            this._element.classList.add('lm_' + this._originalParent.headerSide);\n            if ([Side.right, Side.bottom].indexOf(this._originalParent.headerSide) >= 0) {\n                this._proxyContainerElement.insertAdjacentElement('afterend', headerElement);\n            }\n        }\n        this._element.style.left = numberToPixels(initialX);\n        this._element.style.top = numberToPixels(initialY);\n        tabElement.setAttribute('title', this._componentItem.title);\n        titleElement.insertAdjacentText('afterbegin', this._componentItem.title);\n        this._proxyContainerElement.appendChild(this._componentItem.element);\n    }\n\n    private determineMinMaxXY(): void {\n        const offset = getJQueryOffset(this._layoutManager.container);\n        this._minX = offset.left;\n        this._minY = offset.top;\n        const { width: containerWidth, height: containerHeight } = getElementWidthAndHeight(this._layoutManager.container);\n        this._maxX = containerWidth + this._minX;\n        this._maxY = containerHeight + this._minY;\n    }\n\n    private getXYWithinMinMax(x: number, y: number): {x: number, y: number} {\n        if (x <= this._minX) {\n            x = Math.ceil(this._minX + 1);\n        } else if (x >= this._maxX) {\n            x = Math.floor(this._maxX - 1);\n        }\n\n        if (y <= this._minY) {\n            y = Math.ceil(this._minY + 1);\n        } else if (y >= this._maxY) {\n            y = Math.floor(this._maxY - 1);\n        }\n\n        return {x,y};\n    }\n\n    /**\n     * Callback on every mouseMove event during a drag. Determines if the drag is\n     * still within the valid drag area and calls the layoutManager to highlight the\n     * current drop area\n     *\n     * @param offsetX - The difference from the original x position in px\n     * @param offsetY - The difference from the original y position in px\n     * @param event -\n     * @internal\n     */\n    private onDrag(offsetX: number, offsetY: number, event: PointerEvent) {\n\n        const x = event.pageX;\n        const y = event.pageY;\n\n        if (!this._layoutManager.layoutConfig.settings.constrainDragToContainer) {\n            this.setDropPosition(x, y);\n        } else {\n            const isWithinContainer = x > this._minX && x < this._maxX && y > this._minY && y < this._maxY;\n            if (isWithinContainer) {\n                this.setDropPosition(x, y);\n            }\n        }\n\n        this._componentItem.drag();\n    }\n\n    /**\n     * Sets the target position, highlighting the appropriate area\n     *\n     * @param x - The x position in px\n     * @param y - The y position in px\n     *\n     * @internal\n     */\n    private setDropPosition(x: number, y: number): void {\n        this._element.style.left = numberToPixels(x);\n        this._element.style.top = numberToPixels(y);\n        this._area = this._layoutManager.getArea(x, y);\n\n        if (this._area !== null) {\n            this._lastValidArea = this._area;\n            this._area.contentItem.highlightDropZone(x, y, this._area);\n        }\n    }\n\n    /**\n     * Callback when the drag has finished. Determines the drop area\n     * and adds the child to it\n     * @internal\n     */\n    private onDrop(): void {\n        const dropTargetIndicator = this._layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('DPOD30011');\n        } else {\n            dropTargetIndicator.hide();\n        }\n\n        this._componentItem.exitDragMode();\n\n        /*\n         * Valid drop area found\n         */\n        let droppedComponentItem: ComponentItem | undefined;\n        if (this._area !== null) {\n            droppedComponentItem = this._componentItem;\n            this._area.contentItem.onDrop(droppedComponentItem, this._area);\n\n            /**\n             * No valid drop area available at present, but one has been found before.\n             * Use it\n             */\n        } else if (this._lastValidArea !== null) {\n            droppedComponentItem = this._componentItem;\n            const newParentContentItem = this._lastValidArea.contentItem;\n            newParentContentItem.onDrop(droppedComponentItem, this._lastValidArea);\n\n            /**\n             * No valid drop area found during the duration of the drag. Return\n             * content item to its original position if a original parent is provided.\n             * (Which is not the case if the drag had been initiated by createDragSource)\n             */\n        } else if (this._originalParent) {\n            droppedComponentItem = this._componentItem;\n            this._originalParent.addChild(droppedComponentItem);\n\n            /**\n             * The drag didn't ultimately end up with adding the content item to\n             * any container. In order to ensure clean up happens, destroy the\n             * content item.\n             */\n        } else {\n            this._componentItem.destroy(); // contentItem children are now destroyed as well\n        }\n\n        this._element.remove();\n\n        this._layoutManager.emit('itemDropped', this._componentItem);\n\n        if (this._componentItemFocused && droppedComponentItem !== undefined) {\n            droppedComponentItem.focus();\n        }\n    }\n\n    /**\n     * Updates the Drag Proxy's dimensions\n     * @internal\n     */\n    private setDimensions() {\n        const dimensions = this._layoutManager.layoutConfig.dimensions;\n        if (dimensions === undefined) {\n            throw new Error('DragProxy.setDimensions: dimensions undefined');\n        }\n\n        let width = dimensions.dragProxyWidth;\n        let height = dimensions.dragProxyHeight;\n        if (width === undefined || height === undefined) {\n            throw new Error('DragProxy.setDimensions: width and/or height undefined');\n        }\n\n        const headerHeight = this._layoutManager.layoutConfig.header.show === false ? 0 : dimensions.headerHeight;\n        this._element.style.width = numberToPixels(width);\n        this._element.style.height = numberToPixels(height)\n        width -= (this._sided ? headerHeight : 0);\n        height -= (!this._sided ? headerHeight : 0);\n        this._proxyContainerElement.style.width = numberToPixels(width);\n        this._proxyContainerElement.style.height = numberToPixels(height);\n        this._componentItem.enterDragMode(width, height);\n        this._componentItem.show();\n    }\n}\n","import { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { numberToPixels } from '../utils/utils';\n\n/** @internal */\nexport class Splitter {\n    private _grabSize;\n    private _dragListener: DragListener;\n\n    private readonly _element: HTMLDivElement;\n\n    get element(): HTMLDivElement { return this._element; }\n\n    constructor(private _isVertical: boolean, private _size: number, grabSize: number) {\n        this._grabSize = grabSize < this._size ? this._size : grabSize;\n\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.Splitter);\n        const dragHandleElement = document.createElement('div');\n        dragHandleElement.classList.add(DomConstants.ClassName.DragHandle);\n\n        const handleExcessSize = this._grabSize - this._size;\n        const handleExcessPos = handleExcessSize / 2;\n\n        if (this._isVertical) {\n            dragHandleElement.style.top = numberToPixels(-handleExcessPos);\n            dragHandleElement.style.height = numberToPixels(this._size + handleExcessSize);\n            this._element.classList.add(DomConstants.ClassName.Vertical);\n            this._element.style.height = numberToPixels(this._size);\n        } else {\n            dragHandleElement.style.left = numberToPixels(-handleExcessPos);\n            dragHandleElement.style.width = numberToPixels(this._size + handleExcessSize);\n            this._element.classList.add(DomConstants.ClassName.Horizontal);\n            this._element.style.width = numberToPixels(this._size);\n        }\n\n        this._element.appendChild(dragHandleElement);\n\n        this._dragListener = new DragListener(this._element, [dragHandleElement]);\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    on<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this._dragListener.on<K>(eventName, callback);\n    }\n}\n","import { ComponentItemConfig, ItemConfig, RowOrColumnItemConfig, StackItemConfig } from '../config/config'\nimport { ResolvedRowOrColumnItemConfig, ResolvedStackItemConfig } from '../config/resolved-config'\nimport { Splitter } from '../controls/splitter'\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error'\nimport { LayoutManager } from '../layout-manager'\nimport { DomConstants } from '../utils/dom-constants'\nimport { ItemType, JsonValue, WidthOrHeightPropertyName } from '../utils/types'\nimport {\n    getElementHeight,\n    getElementWidth,\n    getElementWidthAndHeight,\n    numberToPixels,\n    pixelsToNumber,\n    setElementHeight,\n    setElementWidth\n} from \"../utils/utils\"\nimport { ComponentItem } from './component-item'\nimport { ContentItem } from './content-item'\n\n/** @public */\nexport class RowOrColumn extends ContentItem {\n    /** @internal */\n    private readonly _childElementContainer: HTMLElement;\n    /** @internal */\n    private readonly _configType: 'row' | 'column';\n    /** @internal */\n    private readonly _isColumn: boolean;\n    /** @internal */\n    private readonly _splitterSize: number;\n    /** @internal */\n    private readonly _splitterGrabSize: number;\n    /** @internal */\n    private readonly _dimension: WidthOrHeightPropertyName;\n    /** @internal */\n    private readonly _splitter: Splitter[] = [];\n    /** @internal */\n    private _splitterPosition: number | null;\n    /** @internal */\n    private _splitterMinPosition: number | null;\n    /** @internal */\n    private _splitterMaxPosition: number | null;\n\n    /** @internal */\n    constructor(isColumn: boolean, layoutManager: LayoutManager, config: ResolvedRowOrColumnItemConfig,\n        /** @internal */\n        private _rowOrColumnParent: ContentItem\n    ) {\n        super(layoutManager, config, _rowOrColumnParent, RowOrColumn.createElement(document, isColumn));\n\n        this.isRow = !isColumn;\n        this.isColumn = isColumn;\n\n        this._childElementContainer = this.element;\n        this._splitterSize = layoutManager.layoutConfig.dimensions.borderWidth;\n        this._splitterGrabSize = layoutManager.layoutConfig.dimensions.borderGrabWidth;\n        this._isColumn = isColumn;\n        this._dimension = isColumn ? 'height' : 'width';\n        this._splitterPosition = null;\n        this._splitterMinPosition = null;\n        this._splitterMaxPosition = null;\n\n        switch (config.type) {\n            case ItemType.row:\n            case ItemType.column:\n                this._configType = config.type;\n                break;\n            default:\n                throw new AssertError('ROCCCT00925');\n        }\n    }\n\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): ComponentItem {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index) as ComponentItem;\n    }\n\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): number {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n\n    newItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,  index?: number): ContentItem {\n        index = this.addItem(itemConfig, index);\n        const createdItem = this.contentItems[index];\n\n        if (ContentItem.isStack(createdItem) && (ItemConfig.isComponent(itemConfig))) {\n            // createdItem is a Stack which was created to hold wanted component.  Return component\n            return createdItem.contentItems[0];\n        } else {\n            return createdItem;\n        }\n    }\n\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        index?: number\n    ): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index, false);\n    }\n\n    /**\n     * Add a new contentItem to the Row or Column\n     *\n     * @param contentItem -\n     * @param index - The position of the new item within the Row or Column.\n     *                If no index is provided the item will be added to the end\n     * @param suspendResize - If true the items won't be resized. This will leave the item in\n     *                        an inconsistent state and is only intended to be used if multiple\n     *                        children need to be added in one go and resize is called afterwards\n     *\n     * @returns\n     */\n    override addChild(contentItem: ContentItem, index?: number, suspendResize?: boolean): number {\n\n        // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n\n        if (index === undefined) {\n            index = this.contentItems.length;\n        }\n\n        if (this.contentItems.length > 0) {\n            const splitterElement = this.createSplitter(Math.max(0, index - 1)).element;\n\n            if (index > 0) {\n                this.contentItems[index - 1].element.insertAdjacentElement('afterend', splitterElement);\n                splitterElement.insertAdjacentElement('afterend', contentItem.element);\n            } else {\n                this.contentItems[0].element.insertAdjacentElement('beforebegin', splitterElement);\n                splitterElement.insertAdjacentElement('beforebegin', contentItem.element);\n            }\n        } else {\n            this._childElementContainer.appendChild(contentItem.element);\n        }\n\n        super.addChild(contentItem, index);\n\n        const newItemSize = (1 / this.contentItems.length) * 100;\n\n        if (suspendResize === true) {\n            this.emitBaseBubblingEvent('stateChanged');\n            return index;\n        }\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.contentItems[i] === contentItem) {\n                contentItem[this._dimension] = newItemSize;\n            } else {\n                const itemSize = this.contentItems[i][this._dimension] *= (100 - newItemSize) / 100;\n                this.contentItems[i][this._dimension] = itemSize;\n            }\n        }\n\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n\n        return index;\n    }\n\n    /**\n     * Removes a child of this element\n     *\n     * @param contentItem -\n     * @param keepChild - If true the child will be removed, but not destroyed\n     *\n     */\n    override removeChild(contentItem: ContentItem, keepChild: boolean): void {\n        const index = this.contentItems.indexOf(contentItem);\n        const splitterIndex = Math.max(index - 1, 0);\n\n        if (index === -1) {\n            throw new Error('Can\\'t remove child. ContentItem is not child of this Row or Column');\n        }\n\n        /**\n         * Remove the splitter before the item or after if the item happens\n         * to be the first in the row/column\n         */\n        if (this._splitter[splitterIndex]) {\n            this._splitter[splitterIndex].destroy();\n            this._splitter.splice(splitterIndex, 1);\n        }\n\n        super.removeChild(contentItem, keepChild);\n\n        if (this.contentItems.length === 1 && this.isClosable === true) {\n            const childItem = this.contentItems[0];\n            this.contentItems.length = 0;\n            this._rowOrColumnParent.replaceChild(this, childItem, true);\n        } else {\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n        }\n    }\n\n    /**\n     * Replaces a child of this Row or Column with another contentItem\n     */\n    override replaceChild(oldChild: ContentItem, newChild: ContentItem): void {\n        const size = oldChild[this._dimension];\n        super.replaceChild(oldChild, newChild);\n        newChild[this._dimension] = size;\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n\n    /**\n     * Called whenever the dimensions of this item or one of its parents change\n     */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /**\n     * Invoked recursively by the layout manager. ContentItem.init appends\n     * the contentItem's DOM elements to the container, RowOrColumn init adds splitters\n     * in between them\n     * @internal\n     */\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        for (let i = 0; i < this.contentItems.length - 1; i++) {\n            this.contentItems[i].element.insertAdjacentElement('afterend', this.createSplitter(i).element);\n        }\n\n        this.initContentItems();\n    }\n\n    toConfig(): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: this.type as 'row' | 'column',\n            content: this.calculateConfigContent() as (ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig)[],\n            width: this.width,\n            minWidth: this.minWidth,\n            height: this.height,\n            minHeight: this.minHeight,\n            id: this.id,\n            isClosable: this.isClosable,\n        }\n        return result;\n    }\n\n    /** @internal */\n    protected override setParent(parent: ContentItem): void {\n        this._rowOrColumnParent = parent;\n        super.setParent(parent);\n    }\n\n    /** @internal */\n    private updateNodeSize(): void {\n        if (this.contentItems.length > 0) {\n            this.calculateRelativeSizes();\n            this.setAbsoluteSizes();\n        }\n        this.emitBaseBubblingEvent('stateChanged');\n        this.emit('resize');\n    }\n\n    /**\n     * Turns the relative sizes calculated by calculateRelativeSizes into\n     * absolute pixel values and applies them to the children's DOM elements\n     *\n     * Assigns additional pixels to counteract Math.floor\n     * @internal\n     */\n    private setAbsoluteSizes() {\n        const sizeData = this.calculateAbsoluteSizes();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (sizeData.additionalPixel - i > 0) {\n                sizeData.itemSizes[i]++;\n            }\n\n            if (this._isColumn) {\n                setElementWidth(this.contentItems[i].element, sizeData.totalWidth);\n                setElementHeight(this.contentItems[i].element, sizeData.itemSizes[i]);\n            } else {\n                setElementWidth(this.contentItems[i].element, sizeData.itemSizes[i]);\n                setElementHeight(this.contentItems[i].element, sizeData.totalHeight);\n            }\n        }\n    }\n\n    /**\n     * Calculates the absolute sizes of all of the children of this Item.\n     * @returns Set with absolute sizes and additional pixels.\n     * @internal\n     */\n    private calculateAbsoluteSizes() {\n        const totalSplitterSize = (this.contentItems.length - 1) * this._splitterSize;\n        let { width: totalWidth, height: totalHeight } = getElementWidthAndHeight(this.element);\n\n        if (this._isColumn) {\n            totalHeight -= totalSplitterSize;\n        } else {\n            totalWidth -= totalSplitterSize;\n        }\n\n        let totalAssigned = 0;\n        const itemSizes = [];\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            let itemSize: number;\n            if (this._isColumn) {\n                itemSize = Math.floor(totalHeight * (this.contentItems[i].height / 100));\n            } else {\n                itemSize = Math.floor(totalWidth * (this.contentItems[i].width / 100));\n            }\n\n            totalAssigned += itemSize;\n            itemSizes.push(itemSize);\n        }\n\n        const additionalPixel = Math.floor((this._isColumn ? totalHeight : totalWidth) - totalAssigned);\n\n        return {\n            itemSizes: itemSizes,\n            additionalPixel: additionalPixel,\n            totalWidth: totalWidth,\n            totalHeight: totalHeight\n        };\n    }\n\n    /**\n     * Calculates the relative sizes of all children of this Item. The logic\n     * is as follows:\n     *\n     * - Add up the total size of all items that have a configured size\n     *\n     * - If the total == 100 (check for floating point errors)\n     *        Excellent, job done\n     *\n     * - If the total is \\> 100,\n     *        set the size of items without set dimensions to 1/3 and add this to the total\n     *        set the size off all items so that the total is hundred relative to their original size\n     *\n     * - If the total is \\< 100\n     *        If there are items without set dimensions, distribute the remainder to 100 evenly between them\n     *        If there are no items without set dimensions, increase all items sizes relative to\n     *        their original size so that they add up to 100\n     *\n     * @internal\n     */\n    private calculateRelativeSizes() {\n\n        let total = 0;\n        const itemsWithoutSetDimension: ContentItem[] = [];\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (this.contentItems[i][this._dimension] !== undefined) {\n                total += this.contentItems[i][this._dimension];\n            } else {\n                itemsWithoutSetDimension.push(this.contentItems[i]);\n            }\n        }\n\n        /**\n         * Everything adds up to hundred, all good :-)\n         */\n        if (Math.round(total) === 100) {\n            this.respectMinItemWidth();\n            return;\n        }\n\n        /**\n         * Allocate the remaining size to the items without a set dimension\n         */\n        if (Math.round(total) < 100 && itemsWithoutSetDimension.length > 0) {\n            for (let i = 0; i < itemsWithoutSetDimension.length; i++) {\n                itemsWithoutSetDimension[i][this._dimension] = (100 - total) / itemsWithoutSetDimension.length;\n            }\n            this.respectMinItemWidth();\n            return;\n        }\n\n        /**\n         * If the total is > 100, but there are also items without a set dimension left, assing 50\n         * as their dimension and add it to the total\n         *\n         * This will be reset in the next step\n         */\n        if (Math.round(total) > 100) {\n            for (let i = 0; i < itemsWithoutSetDimension.length; i++) {\n                itemsWithoutSetDimension[i][this._dimension] = 50;\n                total += 50;\n            }\n        }\n\n        /**\n         * Set every items size relative to 100 relative to its size to total\n         */\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this.contentItems[i][this._dimension] = (this.contentItems[i][this._dimension] / total) * 100;\n        }\n\n        this.respectMinItemWidth();\n    }\n\n    /**\n     * Adjusts the column widths to respect the dimensions minItemWidth if set.\n     * @internal\n     */\n    private respectMinItemWidth() {\n        interface Entry {\n            width: number;\n        }\n\n        const minItemWidth = this.layoutManager.layoutConfig.dimensions.minItemWidth;\n        let totalOverMin = 0;\n        let totalUnderMin = 0;\n        const entriesOverMin: Entry[] = [];\n        const allEntries: Entry[] = [];\n\n        if (this._isColumn || !minItemWidth || this.contentItems.length <= 1) {\n            return;\n        }\n\n        const sizeData = this.calculateAbsoluteSizes();\n\n        /**\n         * Figure out how much we are under the min item size total and how much room we have to use.\n         */\n        for (let i = 0; i < sizeData.itemSizes.length; i++) {\n            const itemSize = sizeData.itemSizes[i];\n\n            let entry: Entry;\n            if (itemSize < minItemWidth) {\n                totalUnderMin += minItemWidth - itemSize;\n                entry = {\n                    width: minItemWidth\n                };\n\n            } else {\n                totalOverMin += itemSize - minItemWidth;\n                entry = {\n                    width: itemSize\n                };\n                entriesOverMin.push(entry);\n            }\n\n            allEntries.push(entry);\n        }\n\n        /**\n         * If there is nothing under min, or there is not enough over to make up the difference, do nothing.\n         */\n        if (totalUnderMin === 0 || totalUnderMin > totalOverMin) {\n            return;\n        }\n\n        /**\n         * Evenly reduce all columns that are over the min item width to make up the difference.\n         */\n        const reducePercent = totalUnderMin / totalOverMin;\n        let remainingWidth = totalUnderMin;\n        for (let i = 0; i < entriesOverMin.length; i++) {\n            const entry = entriesOverMin[i];\n            const reducedWidth = Math.round((entry.width - minItemWidth) * reducePercent);\n            remainingWidth -= reducedWidth;\n            entry.width -= reducedWidth;\n        }\n\n        /**\n         * Take anything remaining from the last item.\n         */\n        if (remainingWidth !== 0) {\n            allEntries[allEntries.length - 1].width -= remainingWidth;\n        }\n\n        /**\n         * Set every items size relative to 100 relative to its size to total\n         */\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this.contentItems[i].width = (allEntries[i].width / sizeData.totalWidth) * 100;\n        }\n    }\n\n    /**\n     * Instantiates a new Splitter, binds events to it and adds\n     * it to the array of splitters at the position specified as the index argument\n     *\n     * What it doesn't do though is append the splitter to the DOM\n     *\n     * @param index - The position of the splitter\n     *\n     * @returns\n     * @internal\n     */\n    private createSplitter(index: number): Splitter {\n        const splitter = new Splitter(this._isColumn, this._splitterSize, this._splitterGrabSize);\n        splitter.on('drag', (offsetX, offsetY) => this.onSplitterDrag(splitter, offsetX, offsetY));\n        splitter.on('dragStop', () => this.onSplitterDragStop(splitter));\n        splitter.on('dragStart', () => this.onSplitterDragStart(splitter));\n        this._splitter.splice(index, 0, splitter);\n        return splitter;\n    }\n\n    /**\n     * Locates the instance of Splitter in the array of\n     * registered splitters and returns a map containing the contentItem\n     * before and after the splitters, both of which are affected if the\n     * splitter is moved\n     *\n     * @returns A map of contentItems that the splitter affects\n     * @internal\n     */\n    private getItemsForSplitter(splitter: Splitter) {\n        const index = this._splitter.indexOf(splitter);\n\n        return {\n            before: this.contentItems[index],\n            after: this.contentItems[index + 1]\n        };\n    }\n\n    /**\n     * Gets the minimum dimensions for the given item configuration array\n     * @internal\n     */\n    private getMinimumDimensions(arr: readonly ContentItem[]) {\n        let minWidth = 0;\n        let minHeight = 0;\n\n        for (let i = 0; i < arr.length; ++i) {\n            minWidth = Math.max(arr[i].minWidth ?? 0, minWidth);\n            minHeight = Math.max(arr[i].minHeight ?? 0, minHeight);\n        }\n\n        return {\n            horizontal: minWidth,\n            vertical: minHeight\n        };\n    }\n\n    /**\n     * Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\n     * movement area once (so that it doesn't need calculating on every mousemove event)\n     * @internal\n     */\n    private onSplitterDragStart(splitter: Splitter) {\n        const items = this.getItemsForSplitter(splitter);\n        const minSize = this.layoutManager.layoutConfig.dimensions[this._isColumn ? 'minItemHeight' : 'minItemWidth'];\n\n        const beforeMinDim = this.getMinimumDimensions(items.before.contentItems);\n        const beforeMinSize = this._isColumn ? beforeMinDim.vertical : beforeMinDim.horizontal;\n\n        const afterMinDim = this.getMinimumDimensions(items.after.contentItems);\n        const afterMinSize = this._isColumn ? afterMinDim.vertical : afterMinDim.horizontal;\n\n        this._splitterPosition = 0;\n        this._splitterMinPosition = -1 * (pixelsToNumber(items.before.element.style[this._dimension]) - (beforeMinSize || minSize));\n        this._splitterMaxPosition = pixelsToNumber(items.after.element.style[this._dimension]) - (afterMinSize || minSize);\n    }\n\n    /**\n     * Invoked when a splitter's DragListener fires drag. Updates the splitter's DOM position,\n     * but not the sizes of the elements the splitter controls in order to minimize resize events\n     *\n     * @param splitter -\n     * @param offsetX - Relative pixel values to the splitter's original position. Can be negative\n     * @param offsetY - Relative pixel values to the splitter's original position. Can be negative\n     * @internal\n     */\n    private onSplitterDrag(splitter: Splitter, offsetX: number, offsetY: number) {\n        let offset = this._isColumn ? offsetY : offsetX;\n\n        if (this._splitterMinPosition === null || this._splitterMaxPosition === null) {\n            throw new UnexpectedNullError('ROCOSD59226');\n        }\n        offset = Math.max(offset, this._splitterMinPosition);\n        offset = Math.min(offset, this._splitterMaxPosition);\n\n        this._splitterPosition = offset;\n        const offsetPixels = numberToPixels(offset);\n        if (this._isColumn) {\n            splitter.element.style.top = offsetPixels;\n        } else {\n            splitter.element.style.left = offsetPixels;\n        }\n    }\n\n    /**\n     * Invoked when a splitter's DragListener fires dragStop. Resets the splitters DOM position,\n     * and applies the new sizes to the elements before and after the splitter and their children\n     * on the next animation frame\n     * @internal\n     */\n    private onSplitterDragStop(splitter: Splitter) {\n        if (this._splitterPosition === null) {\n            throw new UnexpectedNullError('ROCOSDS66932');\n        } else {\n            const items = this.getItemsForSplitter(splitter);\n            const sizeBefore = pixelsToNumber(items.before.element.style[this._dimension]);\n            const sizeAfter = pixelsToNumber(items.after.element.style[this._dimension]);\n            const splitterPositionInRange = (this._splitterPosition + sizeBefore) / (sizeBefore + sizeAfter);\n            const totalRelativeSize = items.before[this._dimension] + items.after[this._dimension];\n\n            items.before[this._dimension] = splitterPositionInRange * totalRelativeSize;\n            items.after[this._dimension] = (1 - splitterPositionInRange) * totalRelativeSize;\n\n            splitter.element.style.top = numberToPixels(0);\n            splitter.element.style.left = numberToPixels(0);\n\n            globalThis.requestAnimationFrame(() => this.updateSize(false));\n        }\n    }\n}\n\n/** @public */\nexport namespace RowOrColumn {\n    /** @internal */\n    export function getElementDimensionSize(element: HTMLElement, dimension: WidthOrHeightPropertyName): number {\n        if (dimension === 'width') {\n            return getElementWidth(element);\n        } else {\n            return getElementHeight(element);\n        }\n    }\n\n    /** @internal */\n    export function setElementDimensionSize(element: HTMLElement, dimension: WidthOrHeightPropertyName, value: number): void {\n        if (dimension === 'width') {\n            return setElementWidth(element, value);\n        } else {\n            return setElementHeight(element, value);\n        }\n    }\n\n    /** @internal */\n    export function createElement(document: Document, isColumn: boolean): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.Item);\n        if (isColumn) {\n            element.classList.add(DomConstants.ClassName.Column);\n        } else {\n            element.classList.add(DomConstants.ClassName.Row);\n        }\n        return element;\n    }\n}\n","import { ComponentItemConfig, ItemConfig, RowOrColumnItemConfig, StackItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig, ResolvedGroundItemConfig, ResolvedHeaderedItemConfig, ResolvedItemConfig, ResolvedRootItemConfig, ResolvedStackItemConfig } from '../config/resolved-config';\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { AreaLinkedRect, ItemType } from '../utils/types';\nimport { getElementWidthAndHeight, setElementHeight, setElementWidth } from '../utils/utils';\nimport { ComponentItem } from './component-item';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\nimport { RowOrColumn } from './row-or-column';\n\n/**\n * GroundItem is the ContentItem whose one child is the root ContentItem (Root is planted in Ground).\n * (Previously it was called root however this was incorrect as its child is the root item)\n * There is only one instance of GroundItem and it is automatically created by the Layout Manager\n * @internal\n */\nexport class GroundItem extends ComponentParentableItem {\n    private readonly _childElementContainer: HTMLElement;\n    private readonly _containerElement: HTMLElement;\n\n    constructor(layoutManager: LayoutManager, rootItemConfig: ResolvedRootItemConfig | undefined, containerElement: HTMLElement) {\n\n        super(layoutManager, ResolvedGroundItemConfig.create(rootItemConfig), null, GroundItem.createElement(document));\n\n        this.isGround = true;\n        this._childElementContainer = this.element;\n        this._containerElement = containerElement;\n\n        // insert before any pre-existing content elements\n        let before = null;\n        while (true) {\n            const prev: ChildNode | null =\n                before ? before.previousSibling : this._containerElement.lastChild;\n            if (prev instanceof Element\n                && prev.classList.contains(DomConstants.ClassName.Content)) {\n                before = prev;\n            } else {\n                break;\n            }\n        }\n        this._containerElement.insertBefore(this.element, before);\n    }\n\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        this.initContentItems();\n    }\n\n    /**\n     * Loads a new Layout\n     * Internal only.  To load a new layout with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    loadRoot(rootItemConfig: ResolvedRootItemConfig | undefined): void {\n        // Remove existing root if it exists\n        this.clearRoot();\n\n        if (rootItemConfig !== undefined) {\n            const rootContentItem = this.layoutManager.createAndInitContentItem(rootItemConfig, this);\n            this.addChild(rootContentItem, 0);\n        }\n    }\n\n    clearRoot(): void {\n        // Remove existing root if it exists\n        const contentItems = this.contentItems;\n        switch (contentItems.length) {\n            case 0: {\n                return;\n            }\n            case 1: {\n                const existingRootContentItem = contentItems[0];\n                existingRootContentItem.remove();\n                return;\n            }\n            default: {\n                throw new AssertError('GILR07721');\n            }\n        }\n    }\n\n    /**\n     * Adds a ContentItem child to root ContentItem.\n     * Internal only.  To load a add with API, use {@link (LayoutManager:class).addItem}\n     * @returns -1 if added as root otherwise index in root ContentItem's content\n     */\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        index?: number\n    ): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig);\n        let parent: ContentItem;\n        if (this.contentItems.length > 0) {\n            parent = this.contentItems[0];\n        } else {\n            parent = this;\n        }\n        if (parent.isComponent) {\n            throw new Error('Cannot add item as child to ComponentItem');\n        } else {\n            const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, parent);\n            index = parent.addChild(contentItem, index);\n            return (parent === this) ? -1 : index;\n        }\n    }\n\n    loadComponentAsRoot(itemConfig: ComponentItemConfig): void {\n        // Remove existing root if it exists\n        this.clearRoot();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig) as ResolvedComponentItemConfig;\n\n        if (resolvedItemConfig.maximised) {\n            throw new Error('Root Component cannot be maximised');\n        } else {\n            const rootContentItem = new ComponentItem(this.layoutManager, resolvedItemConfig, this);\n            rootContentItem.init();\n            this.addChild(rootContentItem, 0);\n        }\n    }\n\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    override addChild(contentItem: ContentItem, index?: number): number {\n        if (this.contentItems.length > 0) {\n            throw new Error('Ground node can only have a single child');\n        } else {\n            // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n            this._childElementContainer.appendChild(contentItem.element);\n            index = super.addChild(contentItem, index);\n\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n\n            return index;\n        }\n    }\n\n    /** @internal */\n    override calculateConfigContent(): ResolvedRootItemConfig[] {\n        const contentItems = this.contentItems;\n        const count = contentItems.length;\n        const result = new Array<ResolvedRootItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            const itemConfig = item.toConfig();\n            if (ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                result[i] = itemConfig;\n            } else {\n                throw new AssertError('RCCC66832');\n            }\n        }\n        return result;\n    }\n\n    /** @internal */\n    setSize(width: number, height: number): void {\n        if (width === undefined || height === undefined) {\n            this.updateSize(false); // For backwards compatibility with v1.x API\n        } else {\n            setElementWidth(this.element, width);\n            setElementHeight(this.element, height);\n\n            // GroundItem can be empty\n            if (this.contentItems.length > 0) {\n                setElementWidth(this.contentItems[0].element, width);\n                setElementHeight(this.contentItems[0].element, height);\n            }\n\n            this.updateContentItemsSize(false);\n        }\n    }\n\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).updateRootSize}\n     */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    createSideAreas(): GroundItem.Area[] {\n        const areaSize = 50;\n\n        const oppositeSides = GroundItem.Area.oppositeSides;\n        const result = new Array<GroundItem.Area>(Object.keys(oppositeSides).length);\n        let idx = 0;\n\n        for (const key in oppositeSides) {\n            const side = key as keyof GroundItem.Area.Sides;\n            const area = this.getElementArea() as GroundItem.Area;\n            if (area === null) {\n                throw new UnexpectedNullError('RCSA77553');\n            } else {\n                area.side = side;\n                if (oppositeSides[side][1] === '2' )\n                    area[side] = area[oppositeSides[side]] - areaSize;\n                else\n                    area[side] = area[oppositeSides[side]] + areaSize;\n                area.surface = (area.x2 - area.x1) * (area.y2 - area.y1);\n                result[idx++] = area;\n            }\n        }\n\n        return result;\n    }\n\n    override highlightDropZone(x: number, y: number, area: AreaLinkedRect): void {\n        this.layoutManager.tabDropPlaceholder.remove();\n        super.highlightDropZone(x, y, area);\n    }\n\n    override onDrop(contentItem: ContentItem, area: GroundItem.Area): void {\n\n        if (contentItem.isComponent) {\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            // since ResolvedItemConfig.contentItems not set up, we need to add header from Component\n            const component = contentItem as ComponentItem;\n            itemConfig.header = ResolvedHeaderedItemConfig.Header.createCopy(component.headerConfig);\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n\n        if (this.contentItems.length === 0) {\n            this.addChild(contentItem);\n        } else {\n            /*\n             * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n             * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n             * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n             */\n            if(contentItem.type === ItemType.row || contentItem.type === ItemType.column){\n                const itemConfig = ResolvedStackItemConfig.createDefault();\n                const stack = this.layoutManager.createContentItem(itemConfig, this);\n                stack.addChild(contentItem)\n                contentItem = stack\n            }\n\n            const type = area.side[0] == 'x' ? ItemType.row : ItemType.column;\n            const dimension = area.side[0] == 'x' ? 'width' : 'height';\n            const insertBefore = area.side[1] == '2';\n            const column = this.contentItems[0];\n            if (!(column instanceof RowOrColumn) || column.type !== type) {\n                const itemConfig = ResolvedItemConfig.createDefault(type);\n                const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n                this.replaceChild(column, rowOrColumn);\n                rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                rowOrColumn.addChild(column, insertBefore ? undefined : 0, true);\n                column[dimension] = 50;\n                contentItem[dimension] = 50;\n                rowOrColumn.updateSize(false);\n            } else {\n                const sibling = column.contentItems[insertBefore ? 0 : column.contentItems.length - 1]\n                column.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                sibling[dimension] *= 0.5;\n                contentItem[dimension] = sibling[dimension];\n                column.updateSize(false);\n            }\n        }\n    }\n\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement dock() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    dock(): void {\n        throw new AssertError('GID87731');\n    }\n\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement validateDocking() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    validateDocking(): void {\n        throw new AssertError('GIVD87732');\n    }\n\n    getAllContentItems(): ContentItem[] {\n        const result: ContentItem[] = [this];\n        this.deepGetAllContentItems(this.contentItems, result);\n        return result;\n    }\n\n    getConfigMaximisedItems(): ContentItem[] {\n        const result: ContentItem[] = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => {\n            if (ContentItem.isStack(item) && item.initialWantMaximise) {\n                return true;\n            } else {\n                if (ContentItem.isComponentItem(item) && item.initialWantMaximise) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n\n        return result;\n    }\n\n    getItemsByPopInParentId(popInParentId: string): ContentItem[] {\n        const result: ContentItem[] = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => item.popInParentIds.includes(popInParentId));\n        return result;\n    }\n\n    toConfig(): ResolvedItemConfig {\n        throw new Error('Cannot generate GroundItem config');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setActiveComponentItem(item: ComponentItem, focus: boolean, suppressFocusEvent: boolean): void {\n        // only applicable if ComponentItem is root and then it always has focus\n    }\n\n    private updateNodeSize(): void {\n        const { width, height } = getElementWidthAndHeight(this._containerElement);\n\n        setElementWidth(this.element, width);\n        setElementHeight(this.element, height);\n\n        /*\n         * GroundItem can be empty\n         */\n        if (this.contentItems.length > 0) {\n            setElementWidth(this.contentItems[0].element, width);\n            setElementHeight(this.contentItems[0].element, height);\n        }\n    }\n\n    private deepGetAllContentItems(content: readonly ContentItem[], result: ContentItem[]): void {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            result.push(contentItem);\n            this.deepGetAllContentItems(contentItem.contentItems, result);\n        }\n    }\n\n    private deepFilterContentItems(content: readonly ContentItem[], result: ContentItem[],\n        checkAcceptFtn: ((this: void, item: ContentItem) => boolean)\n    ): void {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            if (checkAcceptFtn(contentItem)) {\n                result.push(contentItem);\n            }\n            this.deepFilterContentItems(contentItem.contentItems, result, checkAcceptFtn);\n        }\n    }\n\n}\n\n/** @internal */\nexport namespace GroundItem {\n    export interface Area extends ContentItem.Area {\n        side: keyof typeof Area.Side;\n    }\n\n    export namespace Area {\n        export const enum Side {\n            y2,\n            x2,\n            y1,\n            x1,\n        }\n\n        export type Sides = { [side in keyof typeof Side]: keyof typeof Side; }\n\n        export const oppositeSides: Sides = {\n            y2: 'y1',\n            x2: 'x1',\n            y1: 'y2',\n            x1: 'x2',\n        };\n    }\n\n    export function createElement(document: Document): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.GoldenLayout);\n        element.classList.add(DomConstants.ClassName.Item);\n        element.classList.add(DomConstants.ClassName.Root);\n        return element;\n    }\n}\n","import { ComponentItemConfig } from '../config/config';\nimport { UnexpectedNullError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { GroundItem } from '../items/ground-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DragListener } from '../utils/drag-listener';\nimport { JsonValue } from '../utils/types';\nimport { DragProxy } from './drag-proxy';\nimport { ResolvedRowOrColumnItemConfig } from \"../config/resolved-config\";\n\n/**\n * Allows for any DOM item to create a component on drag\n * start to be dragged into the Layout\n * @public\n */\nexport class DragSource {\n    /** @internal */\n    private _dragListener: DragListener | null;\n    /** @internal */\n    private _dummyGroundContainer: HTMLElement;\n    /** @internal */\n    private _dummyGroundContentItem: GroundItem;\n \n    /** @internal */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager,\n        /** @internal */\n        private readonly _element: HTMLElement,\n        /** @internal */\n        private readonly _extraAllowableChildTargets: HTMLElement[],\n        /** @internal */\n        private _componentTypeOrFtn: JsonValue | (() => DragSource.ComponentItemConfig),\n        /** @internal */\n        private _componentState: JsonValue | undefined,\n        /** @internal */\n        private _title: string | undefined,\n    ) {\n        this._dragListener = null;\n\n        this._dummyGroundContainer = document.createElement('div');\n\n        const dummyRootItemConfig = ResolvedRowOrColumnItemConfig.createDefault('row');\n        this._dummyGroundContentItem = new GroundItem(this._layoutManager, dummyRootItemConfig, this._dummyGroundContainer);\n \n        this.createDragListener();\n    }\n\n\t/**\n\t * Disposes of the drag listeners so the drag source is not usable any more.\n     * @internal\n\t */\n\tdestroy(): void {\n\t\tthis.removeDragListener();\n    }\n    \n    /**\n     * Called initially and after every drag\n     * @internal\n     */\n    private createDragListener() {\n        this.removeDragListener();\n\n        this._dragListener = new DragListener(this._element, this._extraAllowableChildTargets);\n        this._dragListener.on('dragStart', (x, y) => this.onDragStart(x, y));\n        this._dragListener.on('dragStop', () => this.onDragStop());\n    }\n\n    /**\n     * Callback for the DragListener's dragStart event\n     *\n     * @param x - The x position of the mouse on dragStart\n     * @param y - The x position of the mouse on dragStart\n     * @internal\n     */\n    private onDragStart(x: number, y: number) {\n        let componentType: JsonValue;\n        let componentState: JsonValue | undefined;\n        let title: string | undefined;\n        if (typeof this._componentTypeOrFtn === \"function\") {\n            const dragSourceItemConfig: DragSource.ComponentItemConfig = this._componentTypeOrFtn();\n            componentType = dragSourceItemConfig.type;\n            componentState = dragSourceItemConfig.state;\n            title = dragSourceItemConfig.title;\n        } else {\n            componentType = this._componentTypeOrFtn;\n            componentState = this._componentState;\n            title = this._title;\n        }\n\n        // Create a dummy ContentItem only for drag purposes\n        // All ContentItems (except for GroundItem) need a parent.  When dragging, the parent is not used.\n        // Instead of allowing null parents (as Javascript version did), use a temporary dummy GroundItem parent and add ContentItem to that\n        // If this does not work, need to create alternative GroundItem class\n\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        }\n        const resolvedItemConfig = ComponentItemConfig.resolve(itemConfig);\n\n        const componentItem = new ComponentItem(this._layoutManager, resolvedItemConfig, this._dummyGroundContentItem)\n        this._dummyGroundContentItem.contentItems.push(componentItem);\n\n        if (this._dragListener === null) {\n            throw new UnexpectedNullError('DSODSD66746');\n        } else {\n            const dragProxy = new DragProxy(x, y, this._dragListener, this._layoutManager, componentItem , this._dummyGroundContentItem);\n\n            const transitionIndicator = this._layoutManager.transitionIndicator;\n            if (transitionIndicator === null) {\n                throw new UnexpectedNullError('DSODST66746');\n            } else {\n                transitionIndicator.transitionElements(this._element, dragProxy.element);\n            }\n        }\n    }\n\n    /** @internal */\n    private onDragStop() {\n        // if (this._dummyGroundContentItem === undefined) {\n        //     throw new UnexpectedUndefinedError('DSODSDRU08116');\n        // } else {\n        //     this._dummyGroundContentItem._$destroy\n        //     this._dummyGroundContentItem = undefined;\n        // }\n        this.createDragListener();\n    }\n\n    /**\n\t * Called after every drag and when the drag source is being disposed of.\n     * @internal\n\t */\n\tprivate removeDragListener() {\n\t\tif (this._dragListener !== null ) {\n            this._dragListener.destroy();\n            this._dragListener = null;\n\t\t}\n\t}\n}\n\n/** @public */\nexport namespace DragSource {\n    export interface ComponentItemConfig {\n        type: JsonValue,\n        state?: JsonValue,\n        title?: string,\n    }\n}\n","import { DomConstants } from '../utils/dom-constants';\nimport { AreaLinkedRect } from '../utils/types';\nimport { numberToPixels, setElementDisplayVisibility } from '../utils/utils';\n\n/** @internal */\nexport class DropTargetIndicator {\n    private _element: HTMLElement;\n\n    constructor() {\n        // Maybe use container instead of Document Body?\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.DropTargetIndicator);\n        const innerElement = document.createElement('div');\n        innerElement.classList.add(DomConstants.ClassName.Inner);\n        this._element.appendChild(innerElement);\n\n        document.body.appendChild(this._element);\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    highlightArea(area: AreaLinkedRect): void {\n        this._element.style.left = numberToPixels(area.x1);\n        this._element.style.top = numberToPixels(area.y1);\n        this._element.style.width = numberToPixels(area.x2 - area.x1);\n        this._element.style.height = numberToPixels(area.y2 - area.y1);\n        this._element.style.display = 'block';\n    }\n\n    hide(): void {\n        setElementDisplayVisibility(this._element, false);\n    }\n}\n","import { DomConstants } from '../utils/dom-constants';\nimport { Rect } from '../utils/types';\n\n/** @internal @deprecated To be removed */\nexport class TransitionIndicator {\n    private _element: HTMLElement;\n    private _toElement: HTMLElement | null;\n    private _fromDimensions: null;\n    private _totalAnimationDuration: number;\n    private _animationStartTime: number | null;\n\n    constructor() {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.TransitionIndicator);\n        document.body.appendChild(this._element);\n\n        this._toElement = null;\n        this._fromDimensions = null;\n        this._totalAnimationDuration = 200;\n        this._animationStartTime = null;\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transitionElements(fromElement: HTMLElement, toElement: HTMLElement): void {\n        /**\n         * TODO - This is not quite as cool as expected. Review.\n         */\n        return;\n        // this._toElement = toElement;\n        // this._animationStartTime = now();\n        // this._fromDimensions = this._measure(fromElement);\n        // this._fromDimensions.opacity = 0.8;\n        // this._element.show().css(this._fromDimensions);\n        // animFrame(fnBind(this._nextAnimationFrame, this));\n    }\n\n    private nextAnimationFrame(): void {\n        // if (this._toElement === null || this._fromDimensions === null || this._animationStartTime === null) {\n        //     throw new UnexpectedNullError('TINAFTD97115');\n        // } else {\n        //     const toDimensions = this.measure(this._toElement);\n        //     const animationProgress = (now() - this._animationStartTime) / this._totalAnimationDuration;\n        //     const currentFrameStyles = {};\n        //     const cssProperty;\n\n        //     if (animationProgress >= 1) {\n        //         this._element.style.display = 'none';\n        //         return;\n        //     }\n\n        //     toDimensions.opacity = 0;\n\n        //     for (const cssProperty in this._fromDimensions) {\n        //         currentFrameStyles[cssProperty] = this._fromDimensions[cssProperty] +\n        //             (toDimensions[cssProperty] - this._fromDimensions[cssProperty]) *\n        //             animationProgress;\n        //     }\n\n        //     this._element.css(currentFrameStyles);\n        //     animFrame(fnBind(this._nextAnimationFrame, this));\n        // }\n    }\n\n    private measure(element: HTMLElement): Rect {\n        const rect = element.getBoundingClientRect();\n\n        return {\n            left: rect.left,\n            top: rect.top,\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n        };\n    }\n}\n","import { UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from './event-emitter';\n\n// Add our ChildEvent to WindowEventMap for type safety\n/** @public */\ndeclare global {\n    interface WindowEventMap {\n        [EventHub.ChildEventName]: CustomEvent<EventHub.ChildEventDetail>;\n    }\n}\n\n/**\n * An EventEmitter singleton that propagates events\n * across multiple windows. This is a little bit trickier since\n * windows are allowed to open childWindows in their own right.\n *\n * This means that we deal with a tree of windows. Therefore, we do the event propagation in two phases:\n *\n * - Propagate events from this layout to the parent layout\n *   - Repeat until the event arrived at the root layout\n * - Propagate events to this layout and to all children\n *   - Repeat until all layouts got the event\n *\n * **WARNING**: Only userBroadcast events are propagated between windows.\n * This means the you have to take care of propagating state changes between windows yourself.\n *\n * @public\n */\nexport class EventHub extends EventEmitter {\n\n    /** @internal */\n    private _childEventListener = (childEvent: CustomEvent<EventHub.ChildEventDetail>) => this.onEventFromChild(childEvent);\n\n    /**\n     * Creates a new EventHub instance\n     * @param _layoutManager - the layout manager to synchronize between the windows\n     * @internal\n     */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager\n    ) {\n        super();\n        globalThis.addEventListener(EventHub.ChildEventName, this._childEventListener, { passive: true });\n    }\n\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     * @public\n     */\n    override emit<K extends keyof EventEmitter.EventParamsMap>(eventName: K, ...args: EventEmitter.EventParamsMap[K]): void {\n        if (eventName === 'userBroadcast') {\n            // Explicitly redirect the user broadcast to our overridden method.\n            this.emitUserBroadcast(...args);\n        } else {\n            super.emit(eventName, ...args);\n        }\n    }\n\n    /**\n     * Broadcasts a message to all other currently opened windows.\n     * @public\n     */\n    emitUserBroadcast(...args: EventEmitter.UnknownParams): void {\n        // Step 1: Bubble up the event\n        this.handleUserBroadcastEvent('userBroadcast', args);\n    }\n\n    /**\n     * Destroys the EventHub\n     * @internal\n     */\n    destroy(): void {\n        globalThis.removeEventListener(EventHub.ChildEventName, this._childEventListener);\n    }\n\n    /**\n     * Internal processor to process local events.\n     * @internal\n     */\n    private handleUserBroadcastEvent(eventName: string, args: unknown[]) {\n        if (this._layoutManager.isSubWindow) {\n            // We are a sub window and received an event from one of our children.\n            // So propagate it to the Root.\n            this.propagateToParent(eventName, args);\n        } else {\n            // We are the root window, propagate it to the subtree below us.\n            this.propagateToThisAndSubtree(eventName, args);\n        }\n    }\n\n    /**\n     * Callback for child events raised on the window\n     * @internal\n     */\n    private onEventFromChild(event: CustomEvent<EventHub.ChildEventDetail>) {\n        const detail = event.detail;\n        this.handleUserBroadcastEvent(detail.eventName, detail.args);\n    }\n\n    /**\n     * Propagates the event to the parent by emitting\n     * it on the parent's DOM window\n     * @internal\n     */\n    private propagateToParent(eventName: string, args: unknown[]) {\n        const detail: EventHub.ChildEventDetail = {\n            layoutManager: this._layoutManager,\n            eventName,\n            args: args,\n        }\n\n        const eventInit: EventHub.ChildEventInit = {\n            bubbles: true,\n            cancelable: true,\n            detail,\n        };\n\n        const event = new CustomEvent<EventHub.ChildEventDetail>(EventHub.ChildEventName, eventInit);\n        const opener = globalThis.opener;\n        if (opener === null) {\n            throw new UnexpectedNullError('EHPTP15778')\n        }\n\n        opener.dispatchEvent(event);\n    }\n\n    /**\n     * Propagate events to the whole subtree under this event hub.\n     * @internal\n     */\n    private propagateToThisAndSubtree(eventName: string, args: unknown[]) {\n        this.emitUnknown(eventName, ...args);\n        for (let i = 0; i < this._layoutManager.openPopouts.length; i++) {\n            const childGl = this._layoutManager.openPopouts[i].getGlInstance();\n\n            if (childGl) {\n                childGl.eventHub.propagateToThisAndSubtree(eventName, args);\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace EventHub {\n\n    /** @internal */\n    export const ChildEventName = 'gl_child_event';\n\n    /** @internal */\n    export type ChildEventDetail = {\n        layoutManager: LayoutManager;\n        eventName: string;\n        args: unknown[];\n    };\n\n    /** @internal */\n    export type ChildEventInit = CustomEventInit<ChildEventDetail>;\n}\n","import { ComponentItemConfig, ItemConfig, LayoutConfig, RowOrColumnItemConfig, StackItemConfig } from './config/config';\nimport {\n    ResolvedComponentItemConfig,\n    ResolvedItemConfig,\n    ResolvedLayoutConfig,\n    ResolvedPopoutLayoutConfig,\n    ResolvedRootItemConfig,\n    ResolvedRowOrColumnItemConfig,\n    ResolvedStackItemConfig\n} from \"./config/resolved-config\";\nimport { ComponentContainer } from './container/component-container';\nimport { BrowserPopout } from './controls/browser-popout';\nimport { DragProxy } from './controls/drag-proxy';\nimport { DragSource } from './controls/drag-source';\nimport { DropTargetIndicator } from './controls/drop-target-indicator';\nimport { TransitionIndicator } from './controls/transition-indicator';\nimport { ConfigurationError } from './errors/external-error';\nimport { AssertError, UnexpectedNullError, UnexpectedUndefinedError, UnreachableCaseError } from './errors/internal-error';\nimport { ComponentItem } from './items/component-item';\nimport { ComponentParentableItem } from './items/component-parentable-item';\nimport { ContentItem } from './items/content-item';\nimport { GroundItem } from './items/ground-item';\nimport { RowOrColumn } from './items/row-or-column';\nimport { Stack } from './items/stack';\nimport { ConfigMinifier } from './utils/config-minifier';\nimport { DomConstants } from './utils/dom-constants';\nimport { DragListener } from './utils/drag-listener';\nimport { EventEmitter } from './utils/event-emitter';\nimport { EventHub } from './utils/event-hub';\nimport { I18nStringId, I18nStrings, i18nStrings } from './utils/i18n-strings';\nimport { ItemType, JsonValue, Rect, ResponsiveMode } from './utils/types';\nimport {\n    getElementWidthAndHeight,\n    removeFromArray,\n    setElementHeight,\n    setElementWidth\n} from './utils/utils';\n\n/** @internal */\ndeclare global {\n    interface Window {\n        __glInstance: LayoutManager;\n    }\n}\n\n/**\n * The main class that will be exposed as GoldenLayout.\n */\n\n/** @public */\nexport abstract class LayoutManager extends EventEmitter {\n    /** Whether the layout will be automatically be resized to container whenever the container's size is changed\n     * Default is true if <body> is the container otherwise false\n     * Default will be changed to true for any container in the future\n     */\n    resizeWithContainerAutomatically = false;\n    /** The debounce interval (in milliseconds) used whenever a layout is automatically resized.  0 means next tick */\n    resizeDebounceInterval = 100;\n    /** Extend the current debounce delay time period if it is triggered during the delay.\n     * If this is true, the layout will only resize when its container has stopped being resized.\n     * If it is false, the layout will resize at intervals while its container is being resized.\n     */\n    resizeDebounceExtendedWhenPossible = true;\n\n    /** @internal */\n    private _containerElement: HTMLElement;\n    /** @internal */\n    private _isInitialised = false;\n    /** @internal */\n    private _groundItem: GroundItem | undefined = undefined;\n    /** @internal */\n    private _openPopouts: BrowserPopout[] = [];\n    /** @internal */\n    private _dropTargetIndicator: DropTargetIndicator | null = null;\n    /** @internal */\n    private _transitionIndicator: TransitionIndicator | null = null;\n    /** @internal */\n    private _resizeTimeoutId: ReturnType<typeof setTimeout> | undefined;\n    /** @internal */\n    private _itemAreas: ContentItem.Area[] = [];\n    /** @internal */\n    private _maximisedStack: Stack | undefined;\n    /** @internal */\n    private _maximisePlaceholder = LayoutManager.createMaximisePlaceElement(document);\n    /** @internal */\n    private _tabDropPlaceholder = LayoutManager.createTabDropPlaceholderElement(document);\n    /** @internal */\n    private _dragSources: DragSource[] = [];\n    /** @internal */\n    private _updatingColumnsResponsive = false;\n    /** @internal */\n    private _firstLoad = true;\n    /** @internal */\n    private _eventHub = new EventHub(this);\n    /** @internal */\n    private _width: number | null = null;\n    /** @internal */\n    private _height: number | null = null;\n    /** @internal */\n    private _focusedComponentItem: ComponentItem | undefined;\n    /** @internal */\n    private _virtualSizedContainers: ComponentContainer[] = [];\n    /** @internal */\n    private _virtualSizedContainerAddingBeginCount = 0;\n    /** @internal */\n    private _sizeInvalidationBeginCount = 0;\n    /** @internal */\n    protected _constructorOrSubWindowLayoutConfig: LayoutConfig | undefined; // protected for backwards compatibility\n\n    /** @internal */\n    private _resizeObserver = new ResizeObserver(() => this.handleContainerResize());\n    /** @internal */\n    private _windowUnloadListener = () => this.onUnload();\n    /** @internal */\n    private _maximisedStackBeforeDestroyedListener = (ev: EventEmitter.BubblingEvent) => this.cleanupBeforeMaximisedStackDestroyed(ev);\n\n    readonly isSubWindow: boolean;\n    layoutConfig: ResolvedLayoutConfig;\n\n    beforeVirtualRectingEvent: LayoutManager.BeforeVirtualRectingEvent | undefined;\n    afterVirtualRectingEvent: LayoutManager.AfterVirtualRectingEvent | undefined;\n\n    get container(): HTMLElement { return this._containerElement; }\n    get isInitialised(): boolean { return this._isInitialised; }\n    /** @internal */\n    get groundItem(): GroundItem | undefined { return this._groundItem; }\n    /** @internal @deprecated use {@link (LayoutManager:class).groundItem} instead */\n    get root(): GroundItem | undefined { return this._groundItem; }\n    get openPopouts(): BrowserPopout[] { return this._openPopouts; }\n    /** @internal */\n    get dropTargetIndicator(): DropTargetIndicator | null { return this._dropTargetIndicator; }\n    /** @internal @deprecated To be removed */\n    get transitionIndicator(): TransitionIndicator | null { return this._transitionIndicator; }\n    get width(): number | null { return this._width; }\n    get height(): number | null { return this._height; }\n    /**\n     * Retrieves the {@link (EventHub:class)} instance associated with this layout manager.\n     * This can be used to propagate events between the windows\n     * @public\n     */\n    get eventHub(): EventHub { return this._eventHub; }\n    get rootItem(): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot access rootItem before init');\n        } else {\n            const groundContentItems = this._groundItem.contentItems;\n            if (groundContentItems.length === 0) {\n                return undefined;\n            } else {\n                return this._groundItem.contentItems[0];\n            }\n        }\n    }\n    get focusedComponentItem(): ComponentItem | undefined { return this._focusedComponentItem; }\n    /** @internal */\n    get tabDropPlaceholder(): HTMLElement { return this._tabDropPlaceholder; }\n    get maximisedStack(): Stack | undefined { return this._maximisedStack; }\n\n    /** @deprecated indicates deprecated constructor use */\n    get deprecatedConstructor(): boolean { return !this.isSubWindow && this._constructorOrSubWindowLayoutConfig !== undefined; }\n\n\n    /**\n    * @param container - A Dom HTML element. Defaults to body\n    * @internal\n    */\n    constructor(parameters: LayoutManager.ConstructorParameters) {\n        super();\n\n        this.isSubWindow = parameters.isSubWindow;\n\n        this._constructorOrSubWindowLayoutConfig = parameters.constructorOrSubWindowLayoutConfig;\n\n        I18nStrings.checkInitialise();\n        ConfigMinifier.checkInitialise();\n\n        if (parameters.containerElement !== undefined) {\n            this._containerElement = parameters.containerElement;\n        }\n    }\n\n    /**\n     * Destroys the LayoutManager instance itself as well as every ContentItem\n     * within it. After this is called nothing should be left of the LayoutManager.\n     */\n    destroy(): void {\n        if (this._isInitialised) {\n            if (this.layoutConfig.settings.closePopoutsOnUnload === true) {\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    this._openPopouts[i].close();\n                }\n            }\n\n            this._resizeObserver.disconnect();\n            this.checkClearResizeTimeout();\n            globalThis.removeEventListener('unload', this._windowUnloadListener);\n            globalThis.removeEventListener('beforeunload', this._windowUnloadListener);\n\n            if (this._groundItem !== undefined) {\n                this._groundItem.destroy();\n            }\n            this._tabDropPlaceholder.remove();\n            if (this._dropTargetIndicator !== null) {\n                this._dropTargetIndicator.destroy();\n            }\n            if (this._transitionIndicator !== null) {\n                this._transitionIndicator.destroy();\n            }\n            this._eventHub.destroy();\n\n            for (const dragSource of this._dragSources) {\n                dragSource.destroy();\n            }\n            this._dragSources = [];\n\n            this._isInitialised = false;\n        }\n    }\n\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter codes\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).minifyConfig} instead\n     */\n    minifyConfig(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ResolvedLayoutConfig.minifyConfig(config);\n    }\n\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).unminifyConfig} instead\n     */\n    unminifyConfig(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ResolvedLayoutConfig.unminifyConfig(config);\n    }\n\n    /** @internal */\n    abstract bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent;\n    /** @internal */\n    abstract unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void;\n\n    /**\n     * Called from GoldenLayout class. Finishes of init\n     * @internal\n     */\n    init(): void {\n        this.setContainer();\n        this._dropTargetIndicator = new DropTargetIndicator(/*this.container*/);\n        this._transitionIndicator = new TransitionIndicator();\n        this.updateSizeFromContainer();\n\n        let subWindowRootConfig: ComponentItemConfig | undefined;\n        if (this.isSubWindow) {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                // SubWindow LayoutConfig should have been generated by constructor\n                throw new UnexpectedUndefinedError('LMIU07155');\n            } else {\n                if (ItemConfig.isComponent(this._constructorOrSubWindowLayoutConfig.root)) {\n                    subWindowRootConfig = this._constructorOrSubWindowLayoutConfig.root;\n                } else {\n                    // SubWindow LayoutConfig must have Component as Root\n                    throw new AssertError('LMIC07155');\n                }\n                const resolvedLayoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                // remove root from layoutConfig\n                this.layoutConfig = {\n                    ...resolvedLayoutConfig,\n                    root: undefined,\n                }\n            }\n        } else {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                this.layoutConfig = ResolvedLayoutConfig.createDefault(); // will overwritten be loaded via loadLayout\n            } else {\n                // backwards compatibility\n                this.layoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n            }\n        }\n        const layoutConfig = this.layoutConfig;\n        this._groundItem = new GroundItem(this, layoutConfig.root, this._containerElement);\n        this._groundItem.init();\n\n        this.checkLoadedLayoutMaximiseItem();\n\n        this.bindEvents();\n        this._isInitialised = true;\n        this.adjustColumnsResponsive();\n        this.emit('initialised');\n\n        if (subWindowRootConfig !== undefined) {\n            // must be SubWindow\n            this.loadComponentAsRoot(subWindowRootConfig);\n        }\n    }\n\n    /**\n     * Loads a new layout\n     * @param layoutConfig - New layout to be loaded\n     */\n    loadLayout(layoutConfig: LayoutConfig): void {\n        if (!this.isInitialised) {\n            // In case application not correctly using legacy constructor\n            throw new Error('GoldenLayout: Need to call init() if LayoutConfig with defined root passed to constructor')\n        } else {\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMLL11119');\n            } else {\n                this.createSubWindows(); // still needs to be tested\n\n                this.layoutConfig = LayoutConfig.resolve(layoutConfig);\n                this._groundItem.loadRoot(this.layoutConfig.root);\n                this.checkLoadedLayoutMaximiseItem();\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n\n    /**\n     * Creates a layout configuration object based on the the current state\n     *\n     * @public\n     * @returns GoldenLayout configuration\n     */\n    saveLayout(): ResolvedLayoutConfig {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        } else {\n\n            // if (root !== undefined && !(root instanceof ContentItem)) {\n            //     throw new Error('Root must be a ContentItem');\n            // }\n\n            /*\n            * Content\n            */\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMTC18244');\n            } else {\n                const groundContent = this._groundItem.calculateConfigContent();\n\n                let rootItemConfig: ResolvedRootItemConfig | undefined;\n                if (groundContent.length !== 1) {\n                    rootItemConfig = undefined;\n                } else {\n                    rootItemConfig = groundContent[0];\n                }\n\n                /*\n                * Retrieve config for subwindows\n                */\n                this.reconcilePopoutWindows();\n                const openPopouts: ResolvedPopoutLayoutConfig[] = [];\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    openPopouts.push(this._openPopouts[i].toConfig());\n                }\n\n                const config: ResolvedLayoutConfig = {\n                    root: rootItemConfig,\n                    openPopouts,\n                    settings:  ResolvedLayoutConfig.Settings.createCopy(this.layoutConfig.settings),\n                    dimensions: ResolvedLayoutConfig.Dimensions.createCopy(this.layoutConfig.dimensions),\n                    header: ResolvedLayoutConfig.Header.createCopy(this.layoutConfig.header),\n                    resolved: true,\n                }\n\n                return config;\n            }\n        }\n    }\n\n    /**\n     * Removes any existing layout. Effectively, an empty layout will be loaded.\n     */\n\n    clear(): void {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCL11129');\n        } else {\n            this._groundItem.clearRoot();\n        }\n    }\n\n    /**\n     * @deprecated Use {@link (LayoutManager:class).saveLayout}\n     */\n    toConfig(): ResolvedLayoutConfig {\n        return this.saveLayout();\n    }\n\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns New ComponentItem created.\n     */\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string): ComponentItem {\n        const componentItem = this.newComponentAtLocation(componentType, componentState, title);\n        if (componentItem === undefined) {\n            throw new AssertError('LMNC65588');\n        } else {\n            return componentItem;\n        }\n    }\n\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find location in layout where component\n     * will be added. First location in array which is valid will be used. If locationSelectors is undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used\n     * @returns New ComponentItem created or undefined if no valid location selector was in array.\n     */\n    newComponentAtLocation(componentType: JsonValue, componentState?: JsonValue, title?: string,\n        locationSelectors?: LayoutManager.LocationSelector[]\n    ): ComponentItem | undefined{\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            const location = this.addComponentAtLocation(componentType, componentState, title, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                if (!ContentItem.isComponentItem(createdItem)) {\n                    throw new AssertError('LMNC992877533');\n                } else {\n                    return createdItem;\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns Location of new ComponentItem created.\n     */\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string): LayoutManager.Location {\n        const location = this.addComponentAtLocation(componentType, componentState, title);\n        if (location === undefined) {\n            throw new AssertError('LMAC99943');\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where component\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ComponentItem created or undefined if no valid location selector was in array.\n     */\n    addComponentAtLocation(componentType: JsonValue, componentState?: JsonValue, title?: string,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): LayoutManager.Location | undefined {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n\n        return this.addItemAtLocation(itemConfig, locationSelectors);\n    }\n\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns New ContentItem created.\n    */\n    newItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig): ContentItem {\n        const contentItem = this.newItemAtLocation(itemConfig);\n        if (contentItem === undefined) {\n            throw new AssertError('LMNC65588');\n        } else {\n            return contentItem;\n        }\n    }\n\n    /**\n     * Adds a new child ContentItem under the root ContentItem.  If a root does not exist, then create root ContentItem instead\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns New ContentItem created or undefined if no valid location selector was in array. */\n    newItemAtLocation(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            const location = this.addItemAtLocation(itemConfig, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                return createdItem;\n            }\n        }\n    }\n\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns Location of new ContentItem created. */\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig): LayoutManager.Location {\n        const location = this.addItemAtLocation(itemConfig);\n        if (location === undefined) {\n            throw new AssertError('LMAI99943');\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Adds a ContentItem at the first valid selector location.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ContentItem created or undefined if no valid location selector was in array. */\n    addItemAtLocation(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): LayoutManager.Location | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            if (locationSelectors === undefined) {\n                // defaultLocationSelectors should always find a location\n                locationSelectors = LayoutManager.defaultLocationSelectors;\n            }\n\n            const location = this.findFirstLocation(locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                let parentItem = location.parentItem;\n                let addIdx: number;\n                switch (parentItem.type) {\n                    case ItemType.ground: {\n                        const groundItem = parentItem as GroundItem;\n                        addIdx = groundItem.addItem(itemConfig, location.index);\n                        if (addIdx >= 0) {\n                            parentItem = this._groundItem.contentItems[0]; // was added to rootItem\n                        } else {\n                            addIdx = 0; // was added as rootItem (which is the first and only ContentItem in GroundItem)\n                        }\n                        break;\n                    }\n                    case ItemType.row:\n                    case ItemType.column: {\n                        const rowOrColumn = parentItem as RowOrColumn;\n                        addIdx = rowOrColumn.addItem(itemConfig, location.index);\n                        break;\n                    }\n                    case ItemType.stack: {\n                        if (!ItemConfig.isComponent(itemConfig)) {\n                            throw Error(i18nStrings[I18nStringId.ItemConfigIsNotTypeComponent]);\n                        } else {\n                            const stack = parentItem as Stack;\n                            addIdx = stack.addItem(itemConfig, location.index);\n                            break;\n                        }\n                    }\n                    case ItemType.component: {\n                        throw new AssertError('LMAIALC87444602');\n                    }\n                    default:\n                        throw new UnreachableCaseError('LMAIALU98881733', parentItem.type);\n                }\n\n                if (ItemConfig.isComponent(itemConfig)) {\n                    // see if stack was inserted\n                    const item = parentItem.contentItems[addIdx];\n                    if (ContentItem.isStack(item)) {\n                        parentItem = item;\n                        addIdx = 0;\n                    }\n                }\n\n                location.parentItem = parentItem;\n                location.index = addIdx;\n\n                return location;\n            }\n        }\n    }\n\n    /** Loads the specified component ResolvedItemConfig as root.\n     * This can be used to display a Component all by itself.  The layout cannot be changed other than having another new layout loaded.\n     * Note that, if this layout is saved and reloaded, it will reload with the Component as a child of a Stack.\n    */\n    loadComponentAsRoot(itemConfig: ComponentItemConfig): void {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add item before init');\n        } else {\n            this._groundItem.loadComponentAsRoot(itemConfig);\n        }\n    }\n\n    /** @deprecated Use {@link (LayoutManager:class).setSize} */\n    updateSize(width: number, height: number): void {\n        this.setSize(width, height);\n    }\n\n    /**\n     * Updates the layout managers size\n     *\n     * @param width - Width in pixels\n     * @param height - Height in pixels\n     */\n    setSize(width: number, height: number): void {\n        this._width = width;\n        this._height = height;\n\n        if (this._isInitialised === true) {\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMUS18881');\n            } else {\n                this._groundItem.setSize(this._width, this._height);\n\n                if (this._maximisedStack) {\n                    const { width, height } = getElementWidthAndHeight(this._containerElement);\n                    setElementWidth(this._maximisedStack.element, width);\n                    setElementHeight(this._maximisedStack.element, height);\n                    this._maximisedStack.updateSize(false);\n                }\n\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n\n    /** @internal */\n    beginSizeInvalidation(): void {\n        this._sizeInvalidationBeginCount++;\n    }\n\n    /** @internal */\n    endSizeInvalidation(): void {\n        if (--this._sizeInvalidationBeginCount === 0) {\n            this.updateSizeFromContainer();\n        }\n    }\n\n    /** @internal */\n    updateSizeFromContainer(): void {\n        const { width, height } = getElementWidthAndHeight(this._containerElement);\n        this.setSize(width, height);\n    }\n\n    /**\n     * Update the size of the root ContentItem.  This will update the size of all contentItems in the tree\n     * @param force - In some cases the size is not updated if it has not changed. In this case, events\n     * (such as ComponentContainer.virtualRectingRequiredEvent) are not fired. Setting force to true, ensures the size is updated regardless, and\n     * the respective events are fired. This is sometimes necessary when a component's size has not changed but it has become visible, and the\n     * relevant events need to be fired.\n     */\n    updateRootSize(force = false): void {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMURS28881');\n        } else {\n            this._groundItem.updateSize(force);\n        }\n    }\n\n    /** @public */\n    createAndInitContentItem(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        const newItem = this.createContentItem(config, parent);\n        newItem.init();\n        return newItem;\n    }\n\n    /**\n     * Recursively creates new item tree structures based on a provided\n     * ItemConfiguration object\n     *\n     * @param config - ResolvedItemConfig\n     * @param parent - The item the newly created item should be a child of\n     * @internal\n     */\n    createContentItem(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        if (typeof config.type !== 'string') {\n            throw new ConfigurationError('Missing parameter \\'type\\'', JSON.stringify(config));\n        }\n\n        /**\n         * We add an additional stack around every component that's not within a stack anyways.\n         */\n        if (\n            // If this is a component\n            ResolvedItemConfig.isComponentItem(config) &&\n\n            // and it's not already within a stack\n            !(parent instanceof Stack) &&\n\n            // and we have a parent\n            !!parent &&\n\n            // and it's not the topmost item in a new window\n            !(this.isSubWindow === true && parent instanceof GroundItem)\n        ) {\n            const stackConfig: ResolvedStackItemConfig = {\n                type: ItemType.stack,\n                content: [config],\n                width: config.width,\n                minWidth: config.minWidth,\n                height: config.height,\n                minHeight: config.minHeight,\n                id: config.id,\n                maximised: config.maximised,\n                isClosable: config.isClosable,\n                activeItemIndex: 0,\n                header: undefined,\n            };\n\n            config = stackConfig;\n        }\n\n        const contentItem = this.createContentItemFromConfig(config, parent);\n        return contentItem;\n    }\n\n    findFirstComponentItemById(id: string): ComponentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFFCIBI82446');\n        } else {\n            return this.findFirstContentItemTypeByIdRecursive(ItemType.component, id, this._groundItem) as ComponentItem;\n        }\n    }\n\n    /**\n     * Creates a popout window with the specified content at the specified position\n     *\n     * @param itemConfigOrContentItem - The content of the popout window's layout manager derived from either\n     * a {@link (ContentItem:class)} or {@link (ItemConfig:interface)} or ResolvedItemConfig content (array of {@link (ItemConfig:interface)})\n     * @param positionAndSize - The width, height, left and top of Popout window\n     * @param parentId -The id of the element this item will be appended to when popIn is called\n     * @param indexInParent - The position of this item within its parent element\n     */\n\n    createPopout(itemConfigOrContentItem: ContentItem | ResolvedRootItemConfig,\n        positionAndSize: ResolvedPopoutLayoutConfig.Window,\n        parentId: string | null,\n        indexInParent: number | null\n    ): BrowserPopout {\n        if (itemConfigOrContentItem instanceof ContentItem) {\n            return this.createPopoutFromContentItem(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        } else {\n            return this.createPopoutFromItemConfig(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n    }\n\n    /** @internal */\n    createPopoutFromContentItem(item: ContentItem,\n        window: ResolvedPopoutLayoutConfig.Window | undefined,\n        parentId: string | null,\n        indexInParent: number | null | undefined,\n    ): BrowserPopout {\n        /**\n         * If the item is the only component within a stack or for some\n         * other reason the only child of its parent the parent will be destroyed\n         * when the child is removed.\n         *\n         * In order to support this we move up the tree until we find something\n         * that will remain after the item is being popped out\n         */\n        let parent = item.parent;\n        let child = item;\n        while (parent !== null && parent.contentItems.length === 1 && !parent.isGround) {\n            child = parent;\n            parent = parent.parent;\n        }\n\n        if (parent === null) {\n            throw new UnexpectedNullError('LMCPFCI00834');\n        } else {\n            if (indexInParent === undefined) {\n                indexInParent = parent.contentItems.indexOf(child);\n            }\n\n            if (parentId !== null) {\n                parent.addPopInParentId(parentId);\n            }\n\n            if (window === undefined) {\n                const windowLeft = globalThis.screenX || globalThis.screenLeft;\n                const windowTop = globalThis.screenY || globalThis.screenTop;\n                const offsetLeft = item.element.offsetLeft;\n                const offsetTop = item.element.offsetTop\n                // const { left: offsetLeft, top: offsetTop } = getJQueryLeftAndTop(item.element);\n                const { width, height } = getElementWidthAndHeight(item.element);\n\n                window = {\n                    left: windowLeft + offsetLeft,\n                    top: windowTop + offsetTop,\n                    width,\n                    height,\n                };\n            }\n\n            const itemConfig = item.toConfig();\n            item.remove();\n\n            if (!ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                throw new Error(`${i18nStrings[I18nStringId.PopoutCannotBeCreatedWithGroundItemConfig]}`);\n            } else {\n                return this.createPopoutFromItemConfig(itemConfig, window, parentId, indexInParent);\n            }\n        }\n    }\n\n    /** @internal */\n    beginVirtualSizedContainerAdding(): void {\n        if (++this._virtualSizedContainerAddingBeginCount === 0) {\n            this._virtualSizedContainers.length = 0;\n        }\n    }\n\n    /** @internal */\n    addVirtualSizedContainer(container: ComponentContainer): void {\n        this._virtualSizedContainers.push(container);\n    }\n\n    /** @internal */\n    endVirtualSizedContainerAdding(): void {\n        if (--this._virtualSizedContainerAddingBeginCount === 0) {\n            const count = this._virtualSizedContainers.length;\n            if (count > 0) {\n                this.fireBeforeVirtualRectingEvent(count);\n                for (let i = 0; i < count; i++) {\n                    const container = this._virtualSizedContainers[i];\n                    container.notifyVirtualRectingRequired();\n                }\n                this.fireAfterVirtualRectingEvent();\n                this._virtualSizedContainers.length = 0;\n            }\n        }\n    }\n\n    /** @internal */\n    fireBeforeVirtualRectingEvent(count: number): void {\n        if (this.beforeVirtualRectingEvent !== undefined) {\n            this.beforeVirtualRectingEvent(count);\n        }\n    }\n\n    /** @internal */\n    fireAfterVirtualRectingEvent(): void {\n        if (this.afterVirtualRectingEvent !== undefined) {\n            this.afterVirtualRectingEvent();\n        }\n    }\n\n    /** @internal */\n    private createPopoutFromItemConfig(rootItemConfig: ResolvedRootItemConfig,\n        window: ResolvedPopoutLayoutConfig.Window,\n        parentId: string | null,\n        indexInParent: number | null\n    ) {\n        const layoutConfig = this.toConfig();\n\n        const popoutLayoutConfig: ResolvedPopoutLayoutConfig = {\n            root: rootItemConfig,\n            openPopouts: [],\n            settings: layoutConfig.settings,\n            dimensions: layoutConfig.dimensions,\n            header: layoutConfig.header,\n            window,\n            parentId,\n            indexInParent,\n            resolved: true,\n        }\n\n        return this.createPopoutFromPopoutLayoutConfig(popoutLayoutConfig);\n    }\n\n    /** @internal */\n    createPopoutFromPopoutLayoutConfig(config: ResolvedPopoutLayoutConfig): BrowserPopout {\n        const configWindow = config.window;\n        const initialWindow: Rect = {\n            left: configWindow.left ?? (globalThis.screenX || globalThis.screenLeft + 20),\n            top: configWindow.top ?? (globalThis.screenY || globalThis.screenTop + 20),\n            width: configWindow.width ?? 500,\n            height: configWindow.height ?? 309,\n        };\n\n\n        const browserPopout = new BrowserPopout(config, initialWindow, this);\n\n        browserPopout.on('initialised', () => this.emit('windowOpened', browserPopout));\n        browserPopout.on('closed', () => this.reconcilePopoutWindows());\n\n        this._openPopouts.push(browserPopout);\n\n        return browserPopout;\n    }\n\n    /**\n     * Attaches DragListener to any given DOM element\n     * and turns it into a way of creating new ComponentItems\n     * by 'dragging' the DOM element into the layout\n     *\n     * @param element - The HTML element which will be listened to for commencement of drag.\n     * @param componentTypeOrItemConfigCallback - Type of component to be created, or a callback which will provide the ItemConfig\n     * to be used to create the component.\n     * @param componentState - Optional initial state of component.  This will be ignored if componentTypeOrFtn is a function.\n     *\n     * @returns an opaque object that identifies the DOM element\n\t *          and the attached itemConfig. This can be used in\n\t *          removeDragSource() later to get rid of the drag listeners.\n     */\n    newDragSource(element: HTMLElement, itemConfigCallback: () => DragSource.ComponentItemConfig): DragSource;\n    newDragSource(element: HTMLElement, componentType: JsonValue, componentState?: JsonValue, title?: JsonValue): DragSource;\n    newDragSource(element: HTMLElement,\n        componentTypeOrItemConfigCallback: JsonValue | (() => DragSource.ComponentItemConfig),\n        componentState?: JsonValue,\n        title?: string,\n    ): DragSource {\n        const dragSource = new DragSource(this, element, [], componentTypeOrItemConfigCallback, componentState, title);\n        this._dragSources.push(dragSource);\n\n        return dragSource;\n    }\n\n    /**\n\t * Removes a DragListener added by createDragSource() so the corresponding\n\t * DOM element is not a drag source any more.\n\t */\n\tremoveDragSource(dragSource: DragSource): void {\n\t\tremoveFromArray(dragSource, this._dragSources );\n\t\tdragSource.destroy();\n    }\n\n    /** @internal */\n    startComponentDrag(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem, stack: Stack): void {\n        new DragProxy(\n            x,\n            y,\n            dragListener,\n            this,\n            componentItem,\n            stack\n        );\n    }\n\n    /**\n     * Programmatically focuses an item. This focuses the specified component item\n     * and the item emits a focus event\n     *\n     * @param item - The component item to be focused\n     * @param suppressEvent - Whether to emit focus event\n     */\n    focusComponent(item: ComponentItem, suppressEvent = false): void {\n        item.focus(suppressEvent);\n    }\n\n    /**\n     * Programmatically blurs (defocuses) the currently focused component.\n     * If a component item is focused, then it is blurred and and the item emits a blur event\n     *\n     * @param item - The component item to be blurred\n     * @param suppressEvent - Whether to emit blur event\n     */\n    clearComponentFocus(suppressEvent = false): void {\n        this.setFocusedComponentItem(undefined, suppressEvent);\n    }\n\n    /**\n     * Programmatically focuses a component item or removes focus (blurs) from an existing focused component item.\n     *\n     * @param item - If defined, specifies the component item to be given focus.  If undefined, clear component focus.\n     * @param suppressEvents - Whether to emit focus and blur events\n     * @internal\n     */\n    setFocusedComponentItem(item: ComponentItem | undefined, suppressEvents = false): void {\n        if (item !== this._focusedComponentItem) {\n\n            let newFocusedParentItem: ComponentParentableItem | undefined;\n            if (item === undefined) {\n                newFocusedParentItem === undefined;\n            } else {\n                newFocusedParentItem = item.parentItem;\n            }\n\n            if (this._focusedComponentItem !== undefined) {\n                const oldFocusedItem = this._focusedComponentItem;\n                this._focusedComponentItem = undefined;\n                oldFocusedItem.setBlurred(suppressEvents);\n                const oldFocusedParentItem = oldFocusedItem.parentItem;\n                if (newFocusedParentItem === oldFocusedParentItem) {\n                    newFocusedParentItem = undefined;\n                } else {\n                    oldFocusedParentItem.setFocusedValue(false);\n                }\n            }\n\n            if (item !== undefined) {\n                this._focusedComponentItem = item;\n                item.setFocused(suppressEvents);\n                if (newFocusedParentItem !== undefined) {\n                    newFocusedParentItem.setFocusedValue(true);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private createContentItemFromConfig(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        switch (config.type) {\n            case ItemType.ground: throw new AssertError('LMCCIFC68871');\n            case ItemType.row: return new RowOrColumn(false, this, config as ResolvedRowOrColumnItemConfig, parent);\n            case ItemType.column: return new RowOrColumn(true, this, config as ResolvedRowOrColumnItemConfig, parent);\n            case ItemType.stack: return new Stack(this, config as ResolvedStackItemConfig, parent);\n            case ItemType.component:\n                return new ComponentItem(this, config as ResolvedComponentItemConfig, parent as Stack);\n            default:\n                throw new UnreachableCaseError('CCC913564', config.type, 'Invalid Config Item type specified');\n        }\n    }\n\n    /**\n     * This should only be called from stack component.\n     * Stack will look after docking processing associated with maximise/minimise\n     * @internal\n     **/\n    setMaximisedStack(stack: Stack | undefined): void {\n        if (stack === undefined) {\n            if (this._maximisedStack !== undefined) {\n                this.processMinimiseMaximisedStack();\n            }\n        } else {\n            if (stack !== this._maximisedStack) {\n                if (this._maximisedStack !== undefined) {\n                    this.processMinimiseMaximisedStack();\n                }\n\n                this.processMaximiseStack(stack);\n            }\n        }\n    }\n\n    checkMinimiseMaximisedStack(): void {\n        if (this._maximisedStack !== undefined) {\n            this._maximisedStack.minimise();\n        }\n    }\n\n    // showAllActiveContentItems() was called from ContentItem.show().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n\n    // /** @internal */\n    // showAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIS22298');\n    //             } else {\n    //                 activeContentItem.container.show();\n    //             }\n    //         }\n    //     }\n    // }\n\n    // hideAllActiveContentItems() was called from ContentItem.hide().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n\n    // /** @internal */\n    // hideAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIH22298');\n    //             } else {\n    //                 activeContentItem.container.hide();\n    //             }\n    //         }\n    //     }\n    // }\n\n    /** @internal */\n    private cleanupBeforeMaximisedStackDestroyed(event: EventEmitter.BubblingEvent) {\n\t\tif (this._maximisedStack !== null && this._maximisedStack === event.target) {\n\t\t\tthis._maximisedStack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n\t\t\tthis._maximisedStack = undefined;\n\t\t}\n    }\n\n    /**\n     * This method is used to get around sandboxed iframe restrictions.\n     * If 'allow-top-navigation' is not specified in the iframe's 'sandbox' attribute\n     * (as is the case with codepens) the parent window is forbidden from calling certain\n     * methods on the child, such as window.close() or setting document.location.href.\n     *\n     * This prevented GoldenLayout popouts from popping in in codepens. The fix is to call\n     * _$closeWindow on the child window's gl instance which (after a timeout to disconnect\n     * the invoking method from the close call) closes itself.\n     *\n     * @internal\n     */\n    closeWindow(): void {\n        globalThis.setTimeout(() => globalThis.close(), 1);\n    }\n\n    /** @internal */\n    getArea(x: number, y: number): ContentItem.Area | null {\n        let matchingArea = null;\n        let smallestSurface = Infinity;\n\n        for (let i = 0; i < this._itemAreas.length; i++) {\n            const area = this._itemAreas[i];\n\n            if (\n                x > area.x1 &&\n                x < area.x2 &&\n                y > area.y1 &&\n                y < area.y2 &&\n                smallestSurface > area.surface\n            ) {\n                smallestSurface = area.surface;\n                matchingArea = area;\n            }\n        }\n\n        return matchingArea;\n    }\n\n    /** @internal */\n    calculateItemAreas(): void {\n        const allContentItems = this.getAllContentItems();\n        /**\n         * If the last item is dragged out, highlight the entire container size to\n         * allow to re-drop it. this.ground.contentiItems.length === 0 at this point\n         *\n         * Don't include ground into the possible drop areas though otherwise since it\n         * will used for every gap in the layout, e.g. splitters\n         */\n        const groundItem = this._groundItem;\n        if (groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCIAR44365');\n        } else {\n            if (allContentItems.length === 1) {\n                // No root ContentItem (just Ground ContentItem)\n                const groundArea = groundItem.getElementArea();\n                if (groundArea === null) {\n                    throw new UnexpectedNullError('LMCIARA44365')\n                } else {\n                    this._itemAreas = [groundArea];\n                }\n                return;\n            } else {\n                if (groundItem.contentItems[0].isStack) {\n                    // if root is Stack, then split stack and sides of Layout are same, so skip sides\n                    this._itemAreas = [];\n                } else {\n                    // sides of layout\n                    this._itemAreas = groundItem.createSideAreas();\n                }\n\n                for (let i = 0; i < allContentItems.length; i++) {\n                    const stack = allContentItems[i];\n                    if (ContentItem.isStack(stack)) {\n                        const area = stack.getArea();\n\n                        if (area === null) {\n                            continue;\n                        } else {\n                            this._itemAreas.push(area);\n                            const stackContentAreaDimensions = stack.contentAreaDimensions;\n                            if (stackContentAreaDimensions === undefined) {\n                                throw new UnexpectedUndefinedError('LMCIASC45599');\n                            } else {\n                                const highlightArea = stackContentAreaDimensions.header.highlightArea\n                                const surface = (highlightArea.x2 - highlightArea.x1) * (highlightArea.y2 - highlightArea.y1);\n\n                                const header: ContentItem.Area = {\n                                    x1: highlightArea.x1,\n                                    x2: highlightArea.x2,\n                                    y1: highlightArea.y1,\n                                    y2: highlightArea.y2,\n                                    contentItem: stack,\n                                    surface,\n                                };\n                                this._itemAreas.push(header);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Called as part of loading a new layout (including initial init()).\n     * Checks to see layout has a maximised item. If so, it maximises that item.\n     * @internal\n     */\n    private checkLoadedLayoutMaximiseItem() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCLLMI43432');\n        } else {\n            const configMaximisedItems = this._groundItem.getConfigMaximisedItems();\n\n            if (configMaximisedItems.length > 0) {\n                let item = configMaximisedItems[0];\n                if (ContentItem.isComponentItem(item)) {\n                    const stack = item.parent;\n                    if (stack === null) {\n                        throw new UnexpectedNullError('LMXLLMI69999');\n                    } else {\n                        item = stack;\n                    }\n                }\n                if (!ContentItem.isStack(item)) {\n                    throw new AssertError('LMCLLMI19993');\n                } else {\n                    item.maximise();\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private processMaximiseStack(stack: Stack): void {\n        this._maximisedStack = stack;\n        stack.on('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n        stack.element.classList.add(DomConstants.ClassName.Maximised);\n        stack.element.insertAdjacentElement('afterend', this._maximisePlaceholder);\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMMXI19993');\n        } else {\n            this._groundItem.element.prepend(stack.element);\n            const { width, height } = getElementWidthAndHeight(this._containerElement);\n            setElementWidth(stack.element, width);\n            setElementHeight(stack.element, height);\n            stack.updateSize(true);\n            stack.focusActiveContentItem();\n            this._maximisedStack.emit('maximised');\n            this.emit('stateChanged');\n        }\n    }\n\n    /** @internal */\n    private processMinimiseMaximisedStack(): void {\n        if (this._maximisedStack === undefined) {\n            throw new AssertError('LMMMS74422');\n        } else {\n            const stack = this._maximisedStack;\n            if (stack.parent === null) {\n                throw new UnexpectedNullError('LMMI13668');\n            } else {\n                stack.element.classList.remove(DomConstants.ClassName.Maximised);\n                this._maximisePlaceholder.insertAdjacentElement('afterend', stack.element);\n                this._maximisePlaceholder.remove();\n                this.updateRootSize(true);\n                this._maximisedStack = undefined;\n                stack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n                stack.emit('minimised');\n                this.emit('stateChanged');\n            }\n        }\n    }\n\n    /**\n     * Iterates through the array of open popout windows and removes the ones\n     * that are effectively closed. This is necessary due to the lack of reliably\n     * listening for window.close / unload events in a cross browser compatible fashion.\n     * @internal\n     */\n    private reconcilePopoutWindows() {\n        const openPopouts: BrowserPopout[] = [];\n\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            if (this._openPopouts[i].getWindow().closed === false) {\n                openPopouts.push(this._openPopouts[i]);\n            } else {\n                this.emit('windowClosed', this._openPopouts[i]);\n            }\n        }\n\n        if (this._openPopouts.length !== openPopouts.length) {\n            this._openPopouts = openPopouts;\n            this.emit('stateChanged');\n        }\n\n    }\n\n    /**\n     * Returns a flattened array of all content items,\n     * regardles of level or type\n     * @internal\n     */\n    private getAllContentItems() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMGACI13130');\n        } else {\n            return this._groundItem.getAllContentItems();\n        }\n    }\n\n    /**\n     * Binds to DOM/BOM events on init\n     * @internal\n     */\n    private bindEvents() {\n        this._resizeObserver.observe(this._containerElement);\n        globalThis.addEventListener('unload', this._windowUnloadListener, { passive: true });\n        globalThis.addEventListener('beforeunload', this._windowUnloadListener, { passive: true });\n    }\n\n    /**\n     * Creates Subwindows (if there are any). Throws an error\n     * if popouts are blocked.\n     * @internal\n     */\n    private createSubWindows() {\n        for (let i = 0; i < this.layoutConfig.openPopouts.length; i++) {\n            const popoutConfig = this.layoutConfig.openPopouts[i];\n            this.createPopoutFromPopoutLayoutConfig(popoutConfig);\n        }\n    }\n\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    private handleContainerResize(): void {\n        if (this.resizeWithContainerAutomatically) {\n            this.processResizeWithDebounce();\n        }\n    }\n\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    private processResizeWithDebounce(): void {\n        if (this.resizeDebounceExtendedWhenPossible) {\n            this.checkClearResizeTimeout();\n        }\n\n        if (this._resizeTimeoutId === undefined) {\n            this._resizeTimeoutId = setTimeout(\n                () => {\n                    this._resizeTimeoutId = undefined;\n                    this.beginSizeInvalidation();\n                    this.endSizeInvalidation();\n                },\n                this.resizeDebounceInterval,\n            );\n        }\n    }\n\n    private checkClearResizeTimeout() {\n        if (this._resizeTimeoutId !== undefined) {\n            clearTimeout(this._resizeTimeoutId);\n            this._resizeTimeoutId = undefined;\n        }\n    }\n\n    /**\n     * Determines what element the layout will be created in\n     * @internal\n     */\n    private setContainer() {\n        const bodyElement = document.body;\n        const containerElement = this._containerElement ?? bodyElement;\n\n        if (containerElement === bodyElement) {\n            this.resizeWithContainerAutomatically = true;\n\n            const documentElement = document.documentElement;\n            documentElement.style.height = '100%';\n            documentElement.style.margin = '0';\n            documentElement.style.padding = '0';\n            documentElement.style.overflow = 'clip';\n            bodyElement.style.height = '100%';\n            bodyElement.style.margin = '0';\n            bodyElement.style.padding = '0';\n            bodyElement.style.overflow = 'clip';\n        }\n\n        this._containerElement = containerElement;\n    }\n\n    /**\n     * Called when the window is closed or the user navigates away\n     * from the page\n     * @internal\n     */\n    private onUnload(): void {\n        this.destroy();\n    }\n\n    /**\n     * Adjusts the number of columns to be lower to fit the screen and still maintain minItemWidth.\n     * @internal\n     */\n    private adjustColumnsResponsive() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMACR20883');\n        } else {\n            this._firstLoad = false;\n            // If there is no min width set, or not content items, do nothing.\n            if (this.useResponsiveLayout() &&\n                !this._updatingColumnsResponsive &&\n                this._groundItem.contentItems.length > 0 &&\n                this._groundItem.contentItems[0].isRow)\n            {\n                if (this._groundItem === undefined || this._width === null) {\n                    throw new UnexpectedUndefinedError('LMACR77412');\n                } else {\n                    // If there is only one column, do nothing.\n                    const columnCount = this._groundItem.contentItems[0].contentItems.length;\n                    if (columnCount <= 1) {\n                        return;\n                    } else {\n                        // If they all still fit, do nothing.\n                        const minItemWidth = this.layoutConfig.dimensions.minItemWidth;\n                        const totalMinWidth = columnCount * minItemWidth;\n                        if (totalMinWidth <= this._width) {\n                            return;\n                        } else {\n                            // Prevent updates while it is already happening.\n                            this._updatingColumnsResponsive = true;\n\n                            // Figure out how many columns to stack, and put them all in the first stack container.\n                            const finalColumnCount = Math.max(Math.floor(this._width / minItemWidth), 1);\n                            const stackColumnCount = columnCount - finalColumnCount;\n\n                            const rootContentItem = this._groundItem.contentItems[0];\n                            const allStacks = this.getAllStacks();\n                            if (allStacks.length === 0) {\n                                throw new AssertError('LMACRS77413')\n                            } else {\n                                const firstStackContainer = allStacks[0];\n                                for (let i = 0; i < stackColumnCount; i++) {\n                                    // Stack from right.\n                                    const column = rootContentItem.contentItems[rootContentItem.contentItems.length - 1];\n                                    this.addChildContentItemsToContainer(firstStackContainer, column);\n                                }\n\n                                this._updatingColumnsResponsive = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines if responsive layout should be used.\n     *\n     * @returns True if responsive layout should be used; otherwise false.\n     * @internal\n     */\n    private useResponsiveLayout() {\n        const settings = this.layoutConfig.settings;\n        const alwaysResponsiveMode = settings.responsiveMode === ResponsiveMode.always;\n        const onLoadResponsiveModeAndFirst = settings.responsiveMode === ResponsiveMode.onload && this._firstLoad;\n        return alwaysResponsiveMode || onLoadResponsiveModeAndFirst;\n    }\n\n    /**\n     * Adds all children of a node to another container recursively.\n     * @param container - Container to add child content items to.\n     * @param node - Node to search for content items.\n     * @internal\n     */\n    private addChildContentItemsToContainer(container: ContentItem, node: ContentItem) {\n        const contentItems = node.contentItems;\n        if (node instanceof Stack) {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                node.removeChild(item, true);\n                container.addChild(item);\n            }\n        } else {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                this.addChildContentItemsToContainer(container, item);\n            }\n        }\n    }\n\n    /**\n     * Finds all the stacks.\n     * @returns The found stack containers.\n     * @internal\n     */\n    private getAllStacks() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFASC52778');\n        } else {\n            const stacks: Stack[] = [];\n            this.findAllStacksRecursive(stacks, this._groundItem);\n\n            return stacks;\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemType(type: ItemType): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFFCIT82446');\n        } else {\n            return this.findFirstContentItemTypeRecursive(type, this._groundItem);\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemTypeRecursive(type: ItemType, node: ContentItem): ContentItem | undefined {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        } else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type) {\n                    return contentItem;\n                }\n            }\n\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeRecursive(type, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n\n            return undefined;\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemTypeByIdRecursive(type: ItemType, id: string, node: ContentItem): ContentItem | undefined {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        } else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type && contentItem.id === id) {\n                    return contentItem;\n                }\n            }\n\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeByIdRecursive(type, id, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n\n            return undefined;\n        }\n    }\n\n    /**\n     * Finds all the stack containers.\n     *\n     * @param stacks - Set of containers to populate.\n     * @param node - Current node to process.\n     * @internal\n     */\n    private findAllStacksRecursive(stacks: Stack[], node: ContentItem) {\n        const contentItems = node.contentItems;\n        for (let i = 0; i < contentItems.length; i++) {\n            const item = contentItems[i];\n            if (item instanceof Stack) {\n                stacks.push(item);\n            } else {\n                if (!item.isComponent) {\n                    this.findAllStacksRecursive(stacks, item);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private findFirstLocation(selectors: readonly LayoutManager.LocationSelector[]): LayoutManager.Location | undefined {\n        const count = selectors.length;\n        for (let i = 0; i < count; i++) {\n            const selector = selectors[i];\n            const location = this.findLocation(selector);\n            if (location !== undefined) {\n                return location;\n            }\n        }\n        return undefined;\n    }\n\n    /** @internal */\n    private findLocation(selector: LayoutManager.LocationSelector): LayoutManager.Location | undefined {\n        const selectorIndex = selector.index;\n        switch (selector.typeId) {\n            case LayoutManager.LocationSelector.TypeId.FocusedItem: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined\n                } else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    const parentContentItems = parentItem.contentItems;\n                    const parentContentItemCount = parentContentItems.length;\n                    if (selectorIndex === undefined) {\n                        return { parentItem, index: parentContentItemCount };\n                    } else {\n                        const focusedIndex = parentContentItems.indexOf(this._focusedComponentItem);\n                        const index = focusedIndex + selectorIndex;\n                        if (index < 0 || index > parentContentItemCount) {\n                            return undefined;\n                        } else {\n                            return { parentItem, index };\n                        }\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FocusedStack: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined\n                } else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstStack: {\n                const parentItem = this.findFirstContentItemType(ItemType.stack);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstRowOrColumn: {\n                let parentItem = this.findFirstContentItemType(ItemType.row);\n                if (parentItem !== undefined) {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                } else {\n                    parentItem = this.findFirstContentItemType(ItemType.column);\n                    if (parentItem !== undefined) {\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    } else {\n                        return undefined;\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstRow: {\n                const parentItem = this.findFirstContentItemType(ItemType.row);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstColumn: {\n                const parentItem = this.findFirstContentItemType(ItemType.column);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.Empty: {\n                if (this._groundItem === undefined) {\n                    throw new UnexpectedUndefinedError('LMFLRIF18244');\n                } else {\n                    if (this.rootItem !== undefined) {\n                        return undefined;\n                    } else {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.Root: {\n                if (this._groundItem === undefined) {\n                    throw new UnexpectedUndefinedError('LMFLF18244');\n                } else {\n                    const groundContentItems = this._groundItem.contentItems;\n                    if (groundContentItems.length === 0) {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    } else {\n                        const parentItem = groundContentItems[0];\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private tryCreateLocationFromParentItem(parentItem: ContentItem,\n        selectorIndex: number | undefined\n    ): LayoutManager.Location | undefined {\n        const parentContentItems = parentItem.contentItems;\n        const parentContentItemCount = parentContentItems.length;\n        if (selectorIndex === undefined) {\n            return { parentItem, index: parentContentItemCount };\n        } else {\n            if (selectorIndex < 0 || selectorIndex > parentContentItemCount) {\n                return undefined;\n            } else {\n                return { parentItem, index: selectorIndex };\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace LayoutManager {\n    export type BeforeVirtualRectingEvent = (this: void, count: number) => void;\n    export type AfterVirtualRectingEvent = (this: void) => void;\n\n    /** @internal */\n    export interface ConstructorParameters {\n        constructorOrSubWindowLayoutConfig: LayoutConfig | undefined;\n        isSubWindow: boolean;\n        containerElement: HTMLElement | undefined;\n    }\n\n    /** @internal */\n    export function createMaximisePlaceElement(document: Document): HTMLElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.MaximisePlace);\n        return element;\n    }\n\n    /** @internal */\n    export function createTabDropPlaceholderElement(document: Document): HTMLElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.DropTabPlaceholder);\n        return element;\n    }\n\n    /**\n     * Specifies a location of a ContentItem without referencing the content item.\n     * Used to specify where a new item is to be added\n     * @public\n     */\n    export interface Location {\n        parentItem: ContentItem;\n        index: number;\n    }\n\n    /**\n     * A selector used to specify a unique location in the layout\n     * @public\n     */\n    export interface LocationSelector {\n        /** Specifies selector algorithm */\n        typeId: LocationSelector.TypeId;\n        /** Used by algorithm to determine index in found ContentItem */\n        index?: number;\n    }\n\n    /** @public */\n    export namespace LocationSelector {\n        export const enum TypeId {\n            /** Stack with focused Item. Index specifies offset from index of focused item (eg 1 is the position after focused item) */\n            FocusedItem,\n            /** Stack with focused Item. Index specfies ContentItems index */\n            FocusedStack,\n            /** First stack found in layout */\n            FirstStack,\n            /** First Row or Column found in layout (rows are searched first) */\n            FirstRowOrColumn,\n            /** First Row in layout */\n            FirstRow,\n            /** First Column in layout */\n            FirstColumn,\n            /** Finds a location if layout is empty. The found location will be the root ContentItem. */\n            Empty,\n            /** Finds root if layout is empty, otherwise a child under root */\n            Root,\n        }\n    }\n\n    /**\n     * Default LocationSelectors array used if none is specified.  Will always find a location.\n     * @public\n     */\n    export const defaultLocationSelectors: readonly LocationSelector[] = [\n        { typeId: LocationSelector.TypeId.FocusedStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstRowOrColumn, index: undefined },\n        { typeId: LocationSelector.TypeId.Root, index: undefined },\n    ];\n\n    /**\n     * LocationSelectors to try to get location next to existing focused item\n     * @public\n     */\n    export const afterFocusedItemIfPossibleLocationSelectors: readonly LocationSelector[] = [\n        { typeId: LocationSelector.TypeId.FocusedItem, index: 1 },\n        { typeId: LocationSelector.TypeId.FirstStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstRowOrColumn, index: undefined },\n        { typeId: LocationSelector.TypeId.Root, index: undefined },\n    ];\n}\n","import { LayoutConfig } from './config/config';\nimport { ResolvedComponentItemConfig, ResolvedLayoutConfig, ResolvedPopoutLayoutConfig } from './config/resolved-config';\nimport { ComponentContainer } from './container/component-container';\nimport { BindError } from './errors/external-error';\nimport { UnexpectedUndefinedError } from './errors/internal-error';\nimport { LayoutManager } from './layout-manager';\nimport { DomConstants } from './utils/dom-constants';\nimport { I18nStringId, i18nStrings } from './utils/i18n-strings';\n\n/** @public */\nexport class VirtualLayout extends LayoutManager {\n    /**\n     * @deprecated Use {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} with virtual components\n     */\n    getComponentEvent: VirtualLayout.GetComponentEventHandler | undefined;\n    /**\n     * @deprecated Use {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} with virtual components\n     */\n    releaseComponentEvent: VirtualLayout.ReleaseComponentEventHandler | undefined;\n\n    bindComponentEvent: VirtualLayout.BindComponentEventHandler | undefined;\n    unbindComponentEvent: VirtualLayout.UnbindComponentEventHandler | undefined;\n\n    /** @internal @deprecated use while constructor is not determinate */\n    private _bindComponentEventHanlderPassedInConstructor = false; // remove when constructor is determinate\n    /** @internal  @deprecated use while constructor is not determinate */\n    private _creationTimeoutPassed = false; // remove when constructor is determinate\n\n    /**\n     * @param container - A Dom HTML element. Defaults to body\n     * @param bindComponentEventHandler - Event handler to bind components\n     * @param bindComponentEventHandler - Event handler to unbind components\n     * If bindComponentEventHandler is defined, then constructor will be determinate. It will always call the init()\n     * function and the init() function will always complete. This means that the bindComponentEventHandler will be called\n     * if constructor is for a popout window. Make sure bindComponentEventHandler is ready for events.\n     */\n    constructor(\n        container?: HTMLElement,\n        bindComponentEventHandler?: VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    );\n    /** @deprecated specify layoutConfig in {@link (LayoutManager:class).loadLayout} */\n    constructor(config: LayoutConfig, container?: HTMLElement);\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler: HTMLElement | VirtualLayout.BindComponentEventHandler | undefined,\n        unbindComponentEventHandler: VirtualLayout.UnbindComponentEventHandler | undefined,\n        skipInit: true,\n    );\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement | VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n        skipInit?: true,\n    ) {\n        super(VirtualLayout.createLayoutManagerConstructorParameters(configOrOptionalContainer, containerOrBindComponentEventHandler));\n\n        if (containerOrBindComponentEventHandler !== undefined) {\n            if (typeof containerOrBindComponentEventHandler === 'function') {\n                this.bindComponentEvent = containerOrBindComponentEventHandler;\n                this._bindComponentEventHanlderPassedInConstructor = true;\n\n                if (unbindComponentEventHandler !== undefined) {\n                    this.unbindComponentEvent = unbindComponentEventHandler;\n                }\n            }\n        }\n\n        if (!this._bindComponentEventHanlderPassedInConstructor) {\n            // backward compatibility\n\n            if (this.isSubWindow) {\n                // document.body.style.visibility = 'hidden';\n                // Set up layoutConfig since constructor is not determinate and may exit early. Other functions may need\n                // this.layoutConfig. this.layoutConfig is again calculated in the same way when init() completes.\n                // Remove this when constructor is determinate.\n                if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                    throw new UnexpectedUndefinedError('VLC98823');\n                } else {\n                    const resolvedLayoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                    // remove root from layoutConfig\n                    this.layoutConfig = {\n                        ...resolvedLayoutConfig,\n                        root: undefined,\n                    }\n                }\n            }\n        }\n\n        if (skipInit !== true) {\n            if (!this.deprecatedConstructor) {\n                this.init();\n            }\n        }\n    }\n\n    override destroy(): void {\n        this.bindComponentEvent = undefined;\n        this.unbindComponentEvent = undefined;\n\n        super.destroy();\n    }\n\n\n    /**\n     * Creates the actual layout. Must be called after all initial components\n     * are registered. Recurses through the configuration and sets up\n     * the item tree.\n     *\n     * If called before the document is ready it adds itself as a listener\n     * to the document.ready event\n     * @deprecated LayoutConfig should not be loaded in {@link (LayoutManager:class)} constructor, but rather in a\n     * {@link (LayoutManager:class).loadLayout} call.  If LayoutConfig is not specified in {@link (LayoutManager:class)} constructor,\n     * then init() will be automatically called internally and should not be called externally.\n     */\n    override init(): void {\n\n        /**\n         * If the document isn't ready yet, wait for it.\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && (document.readyState === 'loading' || document.body === null)) {\n            document.addEventListener('DOMContentLoaded', () => this.init(), { passive: true });\n            return;\n        }\n\n        /**\n         * If this is a subwindow, wait a few milliseconds for the original\n         * page's js calls to be executed, then replace the bodies content\n         * with GoldenLayout\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && this.isSubWindow === true && !this._creationTimeoutPassed) {\n            setTimeout(() => this.init(), 7);\n            this._creationTimeoutPassed = true;\n            return;\n        }\n\n        if (this.isSubWindow === true) {\n            if (!this._bindComponentEventHanlderPassedInConstructor) {\n                this.clearHtmlAndAdjustStylesForSubWindow();\n            }\n\n            // Expose this instance on the window object to allow the opening window to interact with it\n            window.__glInstance = this;\n        }\n\n        super.init();\n    }\n\n    /**\n     * Clears existing HTML and adjusts style to make window suitable to be a popout sub window\n     * Curently is automatically called when window is a subWindow and bindComponentEvent is not passed in the constructor\n     * If bindComponentEvent is not passed in the constructor, the application must either call this function explicitly or\n     * (preferably) make the window suitable as a subwindow.\n     * In the future, it is planned that this function is NOT automatically called in any circumstances.  Applications will\n     * need to determine whether a window is a Golden Layout popout window and either call this function explicitly or\n     * hide HTML not relevant to the popout.\n     * See apitest for an example of how HTML is hidden when popout windows are displayed\n     */\n    clearHtmlAndAdjustStylesForSubWindow(): void {\n        const headElement = document.head;\n\n        const appendNodeLists = new Array<NodeListOf<Element>>(4);\n        appendNodeLists[0] = document.querySelectorAll('body link');\n        appendNodeLists[1] = document.querySelectorAll('body style');\n        appendNodeLists[2] = document.querySelectorAll('template');\n        appendNodeLists[3] = document.querySelectorAll('.gl_keep');\n\n        for (let listIdx = 0; listIdx < appendNodeLists.length; listIdx++) {\n            const appendNodeList = appendNodeLists[listIdx];\n            for (let nodeIdx = 0; nodeIdx < appendNodeList.length; nodeIdx++) {\n                const node = appendNodeList[nodeIdx];\n                headElement.appendChild(node);\n            }\n        }\n\n        const bodyElement = document.body;\n        bodyElement.innerHTML = '';\n        bodyElement.style.visibility = 'visible';\n        this.checkAddDefaultPopinButton();\n\n        /*\n        * This seems a bit pointless, but actually causes a reflow/re-evaluation getting around\n        * slickgrid's \"Cannot find stylesheet.\" bug in chrome\n        */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const x = document.body.offsetHeight;\n    }\n    /**\n     * Will add button if not popinOnClose specified in settings\n     * @returns true if added otherwise false\n     */\n    checkAddDefaultPopinButton(): boolean {\n        if (this.layoutConfig.settings.popInOnClose) {\n            return false;\n        } else {\n            const popInButtonElement = document.createElement('div');\n            popInButtonElement.classList.add(DomConstants.ClassName.Popin);\n            popInButtonElement.setAttribute('title', this.layoutConfig.header.dock);\n            const iconElement = document.createElement('div');\n            iconElement.classList.add(DomConstants.ClassName.Icon);\n            const bgElement = document.createElement('div');\n            bgElement.classList.add(DomConstants.ClassName.Bg);\n            popInButtonElement.appendChild(iconElement);\n            popInButtonElement.appendChild(bgElement);\n            popInButtonElement.addEventListener('click', () => this.emit('popIn'));\n            document.body.appendChild(popInButtonElement);\n            return true;\n        }\n    }\n\n    /** @internal */\n    override bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent {\n        if (this.bindComponentEvent !== undefined) {\n            const bindableComponent = this.bindComponentEvent(container, itemConfig);\n            return bindableComponent;\n        } else {\n            if (this.getComponentEvent !== undefined) {\n                return {\n                    virtual: false,\n                    component: this.getComponentEvent(container, itemConfig),\n                }\n            } else {\n                // There is no component registered for this type, and we don't have a getComponentEvent defined.\n                // This might happen when the user pops out a dialog and the component types are not registered upfront.\n                const text = i18nStrings[I18nStringId.ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned];\n                const message = `${text}: ${JSON.stringify(itemConfig)}`\n                throw new BindError(message);\n            }\n        }\n    }\n\n    /** @internal */\n    override unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void {\n        if (this.unbindComponentEvent !== undefined) {\n            this.unbindComponentEvent(container);\n        } else {\n            if (!virtual && this.releaseComponentEvent !== undefined) {\n                if (component === undefined) {\n                    throw new UnexpectedUndefinedError('VCUCRCU333998');\n                } else {\n                    this.releaseComponentEvent(container, component);\n                }\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace VirtualLayout {\n    /**\n     * @deprecated Use virtual components with {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} events.\n     */\n    export type GetComponentEventHandler =\n        (this: void, container: ComponentContainer, itemConfig: ResolvedComponentItemConfig) => ComponentContainer.Component;\n    /**\n     * @deprecated Use virtual components with {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} events.\n     */\n    export type ReleaseComponentEventHandler =\n        (this: void, container: ComponentContainer, component: ComponentContainer.Component) => void;\n\n    export type BindComponentEventHandler =\n        (this: void, container: ComponentContainer, itemConfig: ResolvedComponentItemConfig) => ComponentContainer.BindableComponent;\n    export type UnbindComponentEventHandler =\n        (this: void, container: ComponentContainer) => void;\n\n    export type BeforeVirtualRectingEvent = (this: void) => void;\n\n    /** @internal\n     * Veriable to hold the state whether we already checked if we are running in a sub window.\n     * Fixes popout and creation of nested golden-layouts.\n     */\n    let subWindowChecked = false;\n\n    /** @internal */\n    export function createLayoutManagerConstructorParameters(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement |  VirtualLayout.BindComponentEventHandler):\n        LayoutManager.ConstructorParameters\n    {\n        const windowConfigKey = subWindowChecked ? null : new URL(document.location.href).searchParams.get('gl-window');\n        subWindowChecked = true;\n        const isSubWindow = windowConfigKey !== null;\n\n        let containerElement: HTMLElement | undefined;\n        let config: LayoutConfig | undefined;\n        if (windowConfigKey !== null) {\n            const windowConfigStr = localStorage.getItem(windowConfigKey);\n            if (windowConfigStr === null) {\n                throw new Error('Null gl-window Config');\n            }\n            localStorage.removeItem(windowConfigKey);\n            const minifiedWindowConfig = JSON.parse(windowConfigStr) as ResolvedPopoutLayoutConfig;\n            const resolvedConfig = ResolvedLayoutConfig.unminifyConfig(minifiedWindowConfig);\n            config = LayoutConfig.fromResolved(resolvedConfig)\n\n            if (configOrOptionalContainer instanceof HTMLElement) {\n                containerElement = configOrOptionalContainer;\n            }\n        } else {\n            if (configOrOptionalContainer === undefined) {\n                config = undefined;\n            } else {\n                if (configOrOptionalContainer instanceof HTMLElement) {\n                    config = undefined;\n                    containerElement = configOrOptionalContainer;\n                } else {\n                    // backwards compatibility\n                    config = configOrOptionalContainer;\n                }\n            }\n\n            if (containerElement === undefined) {\n                if (containerOrBindComponentEventHandler instanceof HTMLElement) {\n                    containerElement = containerOrBindComponentEventHandler;\n                }\n            }\n        }\n\n        return {\n            constructorOrSubWindowLayoutConfig: config,\n            isSubWindow,\n            containerElement,\n        };\n    }\n}\n","/* eslint indent: [\"error\", 2] */\n\nimport { GoldenLayout } from \"golden-layout\";\n\nconst config = {\n  settings: {\n    showPopoutIcon: false,\n    showCloseIcon: false,\n  },\n  dimensions: {\n    minItemHeight: 40,\n  },\n  content: [{\n    type: 'row',\n    content: [{\n      type: 'column',\n      width: 40,\n      content: [{\n        type: 'component',\n        isClosable: false,\n        componentName: 'template',\n        title: 'Game',\n        componentState: { id: 'client_wrapper' },\n      }],\n    },\n    {\n      type: 'column',\n      content: [{\n        type: 'row',\n        height: 65,\n        content: [{\n          type: 'stack',\n          content: [{\n            type: 'component',\n            isClosable: false,\n            title: 'Main',\n            componentName: 'template',\n            componentState: { id: 'mainmenu' },\n          },\n          {\n            type: 'component',\n            isClosable: false,\n            title: 'Log',\n            componentName: 'template',\n            componentState: { id: 'log' },\n          }],\n        },\n        {\n          type: 'component',\n          title: 'Music',\n          width: 30,\n          componentName: 'template',\n          componentState: { id: 'music' },\n        }],\n      },\n      {\n        type: 'row',\n        content: [{\n          type: 'component',\n          title: 'Server chat',\n          componentName: 'template',\n          componentState: { id: 'ooc' },\n        }],\n      }],\n    }],\n  }],\n};\n\nconst golden = new GoldenLayout();\ngolden.registerComponentFactoryFunction('template', (container, componentState) => {\n  const template = document.querySelector(`#${componentState.id}`);\n  container.element.innerHTML = template.innerHTML;\n  // TODO: support multiple locales\n  // container.setTitle(document.querySelector(`#${componentState.id} meta[name='frame-title']`).getAttribute(\"content\"));\n});\ngolden.loadLayout(config)\n\n","import { LayoutConfig } from './config/config';\nimport { ResolvedComponentItemConfig } from './config/resolved-config';\nimport { ComponentContainer } from './container/component-container';\nimport { ApiError, BindError } from './errors/external-error';\nimport { AssertError, UnexpectedUndefinedError } from './errors/internal-error';\nimport { I18nStringId, i18nStrings } from './utils/i18n-strings';\nimport { JsonValue, LogicalZIndex } from './utils/types';\nimport { deepExtendValue, ensureElementPositionAbsolute, numberToPixels, setElementDisplayVisibility, setElementHeight, setElementWidth } from './utils/utils';\nimport { VirtualLayout } from './virtual-layout';\n\n/** @public */\nexport class GoldenLayout extends VirtualLayout {\n    /** @internal */\n    private _componentTypesMap = new Map<string, GoldenLayout.ComponentInstantiator>();\n    /** @internal */\n    private _getComponentConstructorFtn: GoldenLayout.GetComponentConstructorCallback;\n\n    /** @internal */\n    private _registeredComponentMap = new Map<ComponentContainer, ComponentContainer.Component>();\n    /** @internal */\n    private _virtuableComponentMap = new Map<ComponentContainer, GoldenLayout.VirtuableComponent>();\n    /** @internal */\n    private _goldenLayoutBoundingClientRect: DOMRect;\n\n    /** @internal */\n    private _containerVirtualRectingRequiredEventListener =\n        (container: ComponentContainer, width: number, height: number) => this.handleContainerVirtualRectingRequiredEvent(container, width, height);\n    /** @internal */\n    private _containerVirtualVisibilityChangeRequiredEventListener =\n        (container: ComponentContainer, visible: boolean) => this.handleContainerVirtualVisibilityChangeRequiredEvent(container, visible);\n    /** @internal */\n    private _containerVirtualZIndexChangeRequiredEventListener =\n        (container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) =>\n            this.handleContainerVirtualZIndexChangeRequiredEvent(container, logicalZIndex, defaultZIndex);\n\n    /**\n     * @param container - A Dom HTML element. Defaults to body\n     * @param bindComponentEventHandler - Event handler to bind components\n     * @param bindComponentEventHandler - Event handler to unbind components\n     * If bindComponentEventHandler is defined, then constructor will be determinate. It will always call the init()\n     * function and the init() function will always complete. This means that the bindComponentEventHandler will be called\n     * if constructor is for a popout window. Make sure bindComponentEventHandler is ready for events.\n     */\n    constructor(\n        container?: HTMLElement,\n        bindComponentEventHandler?: VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    );\n    /** @deprecated specify layoutConfig in {@link (LayoutManager:class).loadLayout} */\n    constructor(config: LayoutConfig, container?: HTMLElement);\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement | VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    ) {\n        super(configOrOptionalContainer, containerOrBindComponentEventHandler, unbindComponentEventHandler, true);\n        // we told VirtualLayout to not call init() (skipInit set to true) so that Golden Layout can initialise its properties before init is called\n        if (!this.deprecatedConstructor) {\n            this.init();\n        }\n    }\n\n    /**\n     * Register a new component type with the layout manager.\n     *\n     * @deprecated See {@link https://stackoverflow.com/questions/40922531/how-to-check-if-a-javascript-function-is-a-constructor}\n     * instead use {@link (GoldenLayout:class).registerComponentConstructor}\n     * or {@link (GoldenLayout:class).registerComponentFactoryFunction}\n     */\n    registerComponent(name: string,\n        componentConstructorOrFactoryFtn: GoldenLayout.ComponentConstructor | GoldenLayout.ComponentFactoryFunction,\n        virtual = false\n    ): void {\n        if (typeof componentConstructorOrFactoryFtn !== 'function') {\n            throw new ApiError('registerComponent() componentConstructorOrFactoryFtn parameter is not a function')\n        } else {\n            if (componentConstructorOrFactoryFtn.hasOwnProperty('prototype')) {\n                const componentConstructor = componentConstructorOrFactoryFtn as GoldenLayout.ComponentConstructor;\n                this.registerComponentConstructor(name, componentConstructor, virtual);\n            } else {\n                const componentFactoryFtn = componentConstructorOrFactoryFtn as GoldenLayout.ComponentFactoryFunction;\n                this.registerComponentFactoryFunction(name, componentFactoryFtn, virtual);\n            }\n        }\n    }\n\n    /**\n     * Register a new component type with the layout manager.\n     */\n    registerComponentConstructor(typeName: string, componentConstructor: GoldenLayout.ComponentConstructor, virtual = false): void {\n        if (typeof componentConstructor !== 'function') {\n            throw new Error(i18nStrings[I18nStringId.PleaseRegisterAConstructorFunction]);\n        }\n\n        const existingComponentType = this._componentTypesMap.get(typeName);\n\n        if (existingComponentType !== undefined) {\n            throw new BindError(`${i18nStrings[I18nStringId.ComponentIsAlreadyRegistered]}: ${typeName}`);\n        }\n\n        this._componentTypesMap.set(typeName, {\n                constructor: componentConstructor,\n                factoryFunction: undefined,\n                virtual,\n            }\n        );\n    }\n\n    /**\n     * Register a new component with the layout manager.\n     */\n    registerComponentFactoryFunction(typeName: string, componentFactoryFunction: GoldenLayout.ComponentFactoryFunction, virtual = false): void {\n        if (typeof componentFactoryFunction !== 'function') {\n            throw new BindError('Please register a constructor function');\n        }\n\n        const existingComponentType = this._componentTypesMap.get(typeName);\n\n        if (existingComponentType !== undefined) {\n            throw new BindError(`${i18nStrings[I18nStringId.ComponentIsAlreadyRegistered]}: ${typeName}`);\n        }\n\n        this._componentTypesMap.set(typeName, {\n                constructor: undefined,\n                factoryFunction: componentFactoryFunction,\n                virtual,\n            }\n        );\n    }\n\n    /**\n     * Register a component function with the layout manager. This function should\n     * return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     * @deprecated use {@link (GoldenLayout:class).registerGetComponentConstructorCallback}\n     */\n    registerComponentFunction(callback: GoldenLayout.GetComponentConstructorCallback): void {\n        this.registerGetComponentConstructorCallback(callback);\n    }\n\n    /**\n     * Register a callback closure with the layout manager which supplies a Component Constructor.\n     * This callback should return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     */\n    registerGetComponentConstructorCallback(callback: GoldenLayout.GetComponentConstructorCallback): void {\n        if (typeof callback !== 'function') {\n            throw new Error('Please register a callback function');\n        }\n\n        if (this._getComponentConstructorFtn !== undefined) {\n            console.warn('Multiple component functions are being registered.  Only the final registered function will be used.')\n        }\n\n        this._getComponentConstructorFtn = callback;\n    }\n\n    getRegisteredComponentTypeNames(): string[] {\n        const typeNamesIterableIterator = this._componentTypesMap.keys();\n        return Array.from(typeNamesIterableIterator);\n    }\n\n    /**\n     * Returns a previously registered component instantiator.  Attempts to utilize registered\n     * component type by first, then falls back to the component constructor callback function (if registered).\n     * If neither gets an instantiator, then returns `undefined`.\n     * Note that `undefined` will return if config.componentType is not a string\n     *\n     * @param config - The item config\n     * @public\n     */\n    getComponentInstantiator(config: ResolvedComponentItemConfig): GoldenLayout.ComponentInstantiator | undefined {\n        let instantiator: GoldenLayout.ComponentInstantiator | undefined;\n\n        const typeName = ResolvedComponentItemConfig.resolveComponentTypeName(config)\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(config),\n                    factoryFunction: undefined,\n                    virtual: false,\n                }\n            }\n        }\n\n        return instantiator;\n    }\n\n    /** @internal */\n    override bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent {\n        let instantiator: GoldenLayout.ComponentInstantiator | undefined;\n\n        const typeName = ResolvedComponentItemConfig.resolveComponentTypeName(itemConfig);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(itemConfig),\n                    factoryFunction: undefined,\n                    virtual: false,\n                }\n            }\n        }\n\n        let result: ComponentContainer.BindableComponent;\n        if (instantiator !== undefined) {\n            const virtual = instantiator.virtual;\n            // handle case where component is obtained by name or component constructor callback\n            let componentState: JsonValue | undefined;\n            if (itemConfig.componentState === undefined) {\n                componentState = undefined;\n            } else {\n                // make copy\n                componentState = deepExtendValue({}, itemConfig.componentState) as JsonValue;\n            }\n\n            let component: ComponentContainer.Component | undefined;\n            const componentConstructor = instantiator.constructor;\n            if (componentConstructor !== undefined) {\n                component = new componentConstructor(container, componentState, virtual);\n            } else {\n                const factoryFunction = instantiator.factoryFunction;\n                if (factoryFunction !== undefined) {\n                    component = factoryFunction(container, componentState, virtual);\n                } else {\n                    throw new AssertError('LMBCFFU10008');\n                }\n            }\n\n            if (virtual) {\n                if (component === undefined) {\n                    throw new UnexpectedUndefinedError('GLBCVCU988774');\n                } else {\n                    const virtuableComponent = component as GoldenLayout.VirtuableComponent;\n                    const componentRootElement = virtuableComponent.rootHtmlElement;\n                    if (componentRootElement === undefined) {\n                        throw new BindError(`${i18nStrings[I18nStringId.VirtualComponentDoesNotHaveRootHtmlElement]}: ${typeName}`);\n                    } else {\n                        ensureElementPositionAbsolute(componentRootElement);\n                        this.container.appendChild(componentRootElement);\n                        this._virtuableComponentMap.set(container, virtuableComponent);\n                        container.virtualRectingRequiredEvent = this._containerVirtualRectingRequiredEventListener;\n                        container.virtualVisibilityChangeRequiredEvent = this._containerVirtualVisibilityChangeRequiredEventListener;\n                        container.virtualZIndexChangeRequiredEvent = this._containerVirtualZIndexChangeRequiredEventListener;\n                    }\n                }\n            }\n\n            this._registeredComponentMap.set(container, component);\n\n            result = {\n                virtual: instantiator.virtual,\n                component,\n            };\n\n        } else {\n            // Use getComponentEvent\n            result = super.bindComponent(container, itemConfig);\n        }\n\n        return result;\n    }\n\n    /** @internal */\n    override unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void {\n        const registeredComponent = this._registeredComponentMap.get(container);\n        if (registeredComponent === undefined) {\n            super.unbindComponent(container, virtual, component); // was not created from registration so use virtual unbind events\n        } else {\n            const virtuableComponent = this._virtuableComponentMap.get(container);\n            if (virtuableComponent !== undefined) {\n                const componentRootElement = virtuableComponent.rootHtmlElement;\n                if (componentRootElement === undefined) {\n                    throw new AssertError('GLUC77743', container.title);\n                } else {\n                    this.container.removeChild(componentRootElement);\n                    this._virtuableComponentMap.delete(container);\n                }\n            }\n        }\n    }\n\n    override fireBeforeVirtualRectingEvent(count: number): void {\n        this._goldenLayoutBoundingClientRect = this.container.getBoundingClientRect();\n        super.fireBeforeVirtualRectingEvent(count);\n    }\n\n\n    /** @internal */\n    private handleContainerVirtualRectingRequiredEvent(container: ComponentContainer, width: number, height: number): void {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCSCE55933');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                const containerBoundingClientRect = container.element.getBoundingClientRect();\n                const left = containerBoundingClientRect.left - this._goldenLayoutBoundingClientRect.left;\n                rootElement.style.left = numberToPixels(left);\n                const top = containerBoundingClientRect.top - this._goldenLayoutBoundingClientRect.top;\n                rootElement.style.top = numberToPixels(top);\n                setElementWidth(rootElement, width);\n                setElementHeight(rootElement, height);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleContainerVirtualVisibilityChangeRequiredEvent(container: ComponentContainer, visible: boolean): void {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCVVCRE55934');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                setElementDisplayVisibility(rootElement, visible);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleContainerVirtualZIndexChangeRequiredEvent(container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCVZICRE55935');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                rootElement.style.zIndex = defaultZIndex;\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace GoldenLayout {\n    export interface VirtuableComponent {\n        rootHtmlElement: HTMLElement;\n    }\n\n    export type ComponentConstructor = new(container: ComponentContainer, state: JsonValue | undefined, virtual: boolean) => ComponentContainer.Component;\n    export type ComponentFactoryFunction = (container: ComponentContainer, state: JsonValue | undefined, virtual: boolean) => ComponentContainer.Component | undefined;\n    export type GetComponentConstructorCallback = (this: void, config: ResolvedComponentItemConfig) => ComponentConstructor;\n\n    export interface ComponentInstantiator {\n        constructor: ComponentConstructor | undefined;\n        factoryFunction: ComponentFactoryFunction | undefined;\n        virtual: boolean;\n    }\n}\n"],"names":["InternalError","Error","constructor","type","code","message","super","undefined","AssertError","UnreachableCaseError","variableValue","UnexpectedNullError","UnexpectedUndefinedError","ConfigMinifier","StyleConstants","WidthOrHeightPropertyName","Side","LogicalZIndex","keys","values","translateObject","from","minify","to","key","hasOwnProperty","translatedKey","minifyKey","unminifyKey","fromValue","translateValue","Array","isArray","length","i","translateArray","value","index","indexOfValue","toString","minifyValue","parseInt","substr","indexOfKey","checkInitialise","defaultComponentBaseZIndex","defaultComponentDragZIndex","defaultComponentStackMaximisedZIndex","width","height","top","left","right","bottom","base","drag","stackMaximised","LogicalZIndexToDefaultMap","JsonValue","ItemType","ResponsiveMode","ResolvedItemConfig","ResolvedHeaderedItemConfig","ResolvedStackItemConfig","ResolvedComponentItemConfig","ResolvedRowOrColumnItemConfig","ResolvedRootItemConfig","ResolvedGroundItemConfig","ResolvedLayoutConfig","ResolvedPopoutLayoutConfig","I18nStrings","numberToPixels","numberStr","replace","parseFloat","getElementWidth","element","offsetWidth","setElementWidth","widthAsPixels","style","getElementHeight","offsetHeight","setElementHeight","heightAsPixels","getElementWidthAndHeight","setElementDisplayVisibility","visible","display","deepExtend","target","obj","existingTarget","deepExtendValue","targetArray","valueObj","getUniqueId","Math","random","isJsonObject","isJson","ground","row","column","stack","component","none","always","onload","defaults","content","minWidth","minHeight","id","isClosable","createCopy","original","createDefault","isComponentItem","itemConfig","isStackItem","isGroundItem","Header","defaultMaximised","show","popout","close","maximise","minimise","tabDropdown","copyContent","count","result","defaultActiveItemIndex","maximised","activeItemIndex","header","defaultReorderEnabled","resolveComponentTypeName","componentType","reorderEnabled","title","componentState","copyComponentType","isChildItemConfig","config","isRootItemConfig","create","rootItemConfig","Settings","Dimensions","isPopout","constrainDragToContainer","popoutWholeStack","blockedPopoutsThrowError","closePopoutsOnUnload","responsiveMode","tabOverlapAllowance","reorderOnTabMenuClick","tabControlOffset","popInOnClose","borderWidth","borderGrabWidth","minItemHeight","minItemWidth","headerHeight","dragProxyWidth","dragProxyHeight","dock","root","openPopouts","dimensions","settings","resolved","copyOpenPopouts","minifyConfig","layoutConfig","unminifyConfig","minifiedConfig","Window","parentId","indexInParent","window","ExternalError","ConfigurationError","node","PopoutBlockedError","ApiError","BindError","initialised","infosObject","PopoutCannotBeCreatedWithGroundItemConfig","default","PleaseRegisterAConstructorFunction","ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned","ComponentIsAlreadyRegistered","ComponentIsNotVirtuable","VirtualComponentDoesNotHaveRootHtmlElement","ItemConfigIsNotTypeComponent","idCount","Object","infos","info","i18nStrings","ItemConfig","HeaderedItemConfig","StackItemConfig","ComponentItemConfig","RowOrColumnItemConfig","RootItemConfig","LayoutConfig","PopoutLayoutConfig","resolve","JSON","stringify","resolveContent","resolveId","isGround","isRow","isColumn","isStack","isComponent","hasHeaders","resolveIdAndMaximised","legacyId","legacyMaximised","idx","findIndex","splice","childItemConfig","componentName","componentTypeToTitle","resolvedChildItemConfig","labels","showPopoutIcon","popin","showMaximiseIcon","showCloseIcon","resolveOpenPopouts","fromResolved","copiedConfig","isResolved","configOrResolvedConfig","popoutConfigs","popoutConfig","EventEmitter","_allEventSubscriptions","_subscriptionsMap","Map","unbind","this","removeEventListener","trigger","emit","tryBubbleEvent","name","args","eventName","subcriptions","get","slice","subscription","emitAllEvent","emitUnknown","subs","emitBaseBubblingEvent","event","BubblingEvent","emitUnknownBubblingEvent","callback","unknownCallback","removeUnknownEventListener","off","addEventListener","addUnknownEventListener","on","ALL_EVENT","push","subscriptions","set","removeSubscription","indexOf","allEventSubscriptionsCount","unknownArgs","unshift","allEventSubcriptions","headerClickEventName","headerTouchStartEventName","_name","_target","_isPropagationStopped","origin","isPropagationStopped","stopPropagation","ClickBubblingEvent","_mouseEvent","mouseEvent","TouchStartBubblingEvent","_touchEvent","touchEvent","BrowserPopout","_config","_initialWindowSize","_layoutManager","_isInitialised","_popoutWindow","createWindow","toConfig","glInstanceConfig","getGlInstance","saveLayout","screenX","screenLeft","screenY","screenTop","__glInstance","getWindow","closeWindow","e","popIn","parentItem","copiedRoot","groundItem","getItemsByPopInParentId","contentItems","newContentItem","createAndInitContentItem","addChild","_onClose","url","createUrl","floor","features","serializeWindowFeatures","innerWidth","innerHeight","menubar","toolbar","location","personalbar","resizable","scrollbars","status","globalThis","open","positionWindow","passive","_checkReadyInterval","setInterval","checkReady","isInitialised","onInitialised","clearInterval","windowOptions","windowOptionsString","join","storageKey","localStorage","setItem","URL","href","searchParams","moveTo","focus","setTimeout","HeaderButton","_header","label","cssClass","_pushEvent","_clickEventListener","ev","onClick","_touchStartEventListener","onTouchStart","_element","document","createElement","classList","add","destroy","controlsContainerElement","appendChild","parentNode","removeChild","DragListener","_eElement","extraAllowableChildTargets","_pointerTracking","_pointerDownEventListener","onPointerDown","_pointerMoveEventListener","onPointerMove","_pointerUpEventListener","onPointerUp","_timeout","_allowableTargets","_oDocument","_eBody","body","_nDelay","_nDistance","_nX","_nY","_nOriginalX","_nOriginalY","_dragging","checkRemovePointerTrackingEventListeners","cancelDrag","processDragStop","oEvent","includes","isPrimary","coordinates","getPointerCoordinates","processPointerDown","x","y","startDrag","err","console","error","processDragMove","preventDefault","dragEvent","pageX","pageY","abs","clearTimeout","remove","querySelector","setProperty","Tab","_componentItem","_closeEvent","_focusEvent","_dragStartEvent","_isActive","_tabClickListener","onTabClickDown","_tabTouchStartListener","onTabTouchStart","_closeClickListener","onCloseClick","_closeTouchStartListener","onCloseTouchStart","_dragStartListener","onDragStart","_contentItemDestroyListener","onContentItemDestroy","_tabTitleChangedListener","setTitle","_titleElement","_closeElement","enableReorder","setTab","isActive","componentItem","contentItem","titleElement","closeElement","_dragListener","disableReorder","innerText","setActive","setBlurred","setFocused","button","notifyFocus","notifyClose","TabsContainer","_componentRemoveEvent","_componentFocusEvent","_componentDragStartEvent","_dropdownActiveChangedEvent","_tabs","_lastVisibleTabIndex","_dropdownActive","_dropdownElement","tabs","tabCount","lastVisibleTabIndex","dropdownElement","dropdownActive","createTab","tab","item","handleTabCloseEvent","handleTabFocusEvent","dragListener","handleTabDragStartEvent","insertAdjacentElement","removeTab","processActiveComponentChanged","newActiveComponentItem","activeIndex","activeTab","j","updateTabSizes","availableWidth","activeComponentItem","dropDownActive","tryUpdateTabSizes","cumulativeTabWidth","tabOverlapAllowanceExceeded","tabElement","parentElement","tabMarginRight","getComputedStyle","marginRight","visibleTabWidth","activeTabMarginRight","zIndex","marginLeft","overlap","showAdditionalTabsDropdown","hideAdditionalTabsDropdown","_parent","_configClosable","_getActiveComponentItemEvent","closeEvent","_popoutEvent","_maximiseToggleEvent","_clickEvent","_touchStartEvent","_clickListener","_touchStartListener","_rowColumnClosable","_closeButton","_popoutButton","_tabsContainer","handleTabInitiatedComponentRemoveEvent","handleTabInitiatedComponentFocusEvent","handleTabInitiatedDragStartEvent","processTabDropdownActiveChanged","_show","_popoutEnabled","popoutEnabled","_popoutLabel","popoutLabel","_maximiseEnabled","maximiseEnabled","_maximiseLabel","maximiseLabel","_minimiseEnabled","minimiseEnabled","_minimiseLabel","minimiseLabel","_closeEnabled","closeEnabled","_closeLabel","closeLabel","_tabDropdownEnabled","tabDropdownEnabled","_tabDropdownLabel","tabDropdownLabel","setSide","side","_canRemoveComponent","_controlsContainerElement","_documentMouseUpListener","_tabControlOffset","_tabDropdownButton","handleButtonPopoutEvent","_maximiseButton","handleButtonMaximiseToggleEvent","_side","leftRightSided","_leftRightSided","layoutManager","parent","tabsContainerElement","setRowColumnClosable","updateClosability","len","applyFocusedValue","processMaximised","setAttribute","processMinimised","notifyClick","notifyTouchStart","getJQueryOffset","rect","getBoundingClientRect","scrollTop","scrollLeft","ComponentContainer","_updateItemConfigEvent","_showEvent","_hideEvent","_blurEvent","_stackMaximised","_width","_height","_visible","_isShownWithZeroDimensions","_componentType","_isClosable","_initialState","_state","_boundComponent","bindComponent","updateElementPositionPropertyFromBoundComponent","virtual","_tab","isHidden","state","initialState","releaseComponent","stateRequestEvent","getElement","hide","suppressEvent","blur","setSize","ancestorItem","ancestorChildItem","direction","currentSize","percentage","delta","updateSize","replaceComponent","virtualVisibilityChangeRequiredEvent","virtualRectingRequiredEvent","fireBeforeVirtualRectingEvent","fireAfterVirtualRectingEvent","setBaseLogicalZIndex","getState","extendState","extendedState","setState","setVisibility","setSizeToNodeSize","emitShow","emitHide","setLogicalZIndex","logicalZIndex","_logicalZIndex","notifyVirtualZIndexChangeRequired","enterDragMode","exitDragMode","enterStackMaximised","exitStackMaximised","force","addVirtualSizedContainerToLayoutManager","checkShownFromZeroDimensions","notifyVirtualRectingRequired","virtualZIndexChangeRequiredEvent","defaultZIndex","position","beginVirtualSizedContainerAdding","addVirtualSizedContainer","endVirtualSizedContainerAdding","unbindComponent","ContentItem","_popInParentIds","_type","_id","_pendingEventPropagations","_throttledEvents","_contentItems","createContentItems","popInParentIds","static","keepChild","suspendResize","setParent","init","replaceChild","oldChild","newChild","destroyOldChild","browserPopout","createPopoutFromContentItem","calculateConfigContent","highlightDropZone","area","dropTargetIndicator","highlightArea","onDrop","beginSizeInvalidation","endSizeInvalidation","getElementArea","offset","x1","y1","x2","y2","surface","addPopInParentId","initContentItems","updateContentItemsSize","createContentItem","propagateEvent","scheduleEventPropagationToLayoutManager","requestAnimationFrame","propagateEventToLayoutManager","ComponentItem","_parentItem","_focused","_reorderEnabled","applyUpdatableConfig","_initialWantMaximise","containerElement","_container","handleUpdateItemConfigEvent","initialWantMaximise","container","headerConfig","_headerConfig","_title","focused","updateNodeSize","setActiveComponentItem","setFocusedComponentItem","ComponentParentableItem","setFocusedValue","Stack","_headerSideChanged","_resizeListener","handleResize","_maximisedListener","handleMaximised","_minimisedListener","handleMinimised","layoutHeaderConfig","configContent","componentHeaderConfig","_initialActiveItemIndex","_maximisedEnabled","headerSettings","getActiveComponentItem","handlePopoutEvent","toggleMaximise","handleHeaderClickEvent","handleHeaderTouchStartEvent","handleHeaderComponentRemoveEvent","handleHeaderComponentFocusEvent","handleHeaderComponentStartDragEvent","_childElementContainer","setupHeaderPosition","childElementContainer","headerShow","headerSide","headerLeftRightSided","contentAreaDimensions","_contentAreaDimensions","isMaximised","maximisedStack","stackParent","contentItemCount","setActiveContentItem","suppressFocusEvent","_activeComponentItem","emitStateChangedEvent","getActiveContentItem","focusActiveContentItem","newComponent","newItem","addComponent","addItem","checkMinimiseMaximisedStack","resolvedItemConfig","stackWillBeDeleted","newActiveComponentIdx","setMaximisedStack","createHeaderConfig","_dropSegment","resetHeaderDropZone","_dropIndex","isVertical","isHorizontal","insertBefore","hasCorrectParent","dimension","rowOrColumn","segment","hoverArea","highlightHeaderDropZone","highlightBodyDropZone","getArea","headerArea","contentArea","contentWidth","contentHeight","positionHeader","tabsLength","headerOffset","elementHeight","tabTop","tabLeft","tabWidth","tabIndex","isAboveTab","tabDropPlaceholder","min","tabDropPlaceholderOffset","tabDropPlaceholderWidth","placeHolderTop","clientHeight","placeHolderLeft","bubblingEvent","startComponentDrag","DragProxy","_originalParent","_area","_lastValidArea","offsetX","offsetY","onDrag","createDragProxyElements","_componentItemFocused","setDimensions","determineMinMaxXY","constrainedPosition","getXYWithinMinMax","calculateItemAreas","setDropPosition","initialX","initialY","headerElement","tabsElement","_proxyContainerElement","_sided","insertAdjacentText","_minX","_minY","containerWidth","containerHeight","_maxX","_maxY","ceil","droppedComponentItem","Splitter","_isVertical","_size","grabSize","_grabSize","dragHandleElement","handleExcessSize","handleExcessPos","RowOrColumn","_rowOrColumnParent","_splitter","_splitterSize","_splitterGrabSize","_isColumn","_dimension","_splitterPosition","_splitterMinPosition","_splitterMaxPosition","_configType","createdItem","splitterElement","createSplitter","max","newItemSize","itemSize","splitterIndex","childItem","size","calculateRelativeSizes","setAbsoluteSizes","sizeData","calculateAbsoluteSizes","additionalPixel","itemSizes","totalWidth","totalHeight","totalSplitterSize","totalAssigned","total","itemsWithoutSetDimension","round","respectMinItemWidth","totalOverMin","totalUnderMin","entriesOverMin","allEntries","entry","reducePercent","remainingWidth","reducedWidth","splitter","onSplitterDrag","onSplitterDragStop","onSplitterDragStart","getItemsForSplitter","before","after","getMinimumDimensions","arr","horizontal","vertical","items","minSize","beforeMinDim","beforeMinSize","afterMinDim","afterMinSize","offsetPixels","sizeBefore","sizeAfter","splitterPositionInRange","totalRelativeSize","getElementDimensionSize","setElementDimensionSize","GroundItem","_containerElement","prev","previousSibling","lastChild","Element","contains","loadRoot","clearRoot","rootContentItem","loadComponentAsRoot","createSideAreas","oppositeSides","Area","sibling","validateDocking","getAllContentItems","deepGetAllContentItems","getConfigMaximisedItems","deepFilterContentItems","popInParentId","checkAcceptFtn","DragSource","_extraAllowableChildTargets","_componentTypeOrFtn","_componentState","_dummyGroundContainer","dummyRootItemConfig","_dummyGroundContentItem","createDragListener","removeDragListener","onDragStop","dragSourceItemConfig","dragProxy","transitionIndicator","transitionElements","DropTargetIndicator","innerElement","TransitionIndicator","_toElement","_fromDimensions","_totalAnimationDuration","_animationStartTime","fromElement","toElement","nextAnimationFrame","measure","EventHub","_childEventListener","childEvent","onEventFromChild","ChildEventName","emitUserBroadcast","handleUserBroadcastEvent","isSubWindow","propagateToParent","propagateToThisAndSubtree","detail","eventInit","bubbles","cancelable","CustomEvent","opener","dispatchEvent","childGl","eventHub","LayoutManager","parameters","resizeWithContainerAutomatically","resizeDebounceInterval","resizeDebounceExtendedWhenPossible","_groundItem","_openPopouts","_dropTargetIndicator","_transitionIndicator","_itemAreas","_maximisePlaceholder","createMaximisePlaceElement","_tabDropPlaceholder","createTabDropPlaceholderElement","_dragSources","_updatingColumnsResponsive","_firstLoad","_eventHub","_virtualSizedContainers","_virtualSizedContainerAddingBeginCount","_sizeInvalidationBeginCount","_resizeObserver","ResizeObserver","handleContainerResize","_windowUnloadListener","onUnload","_maximisedStackBeforeDestroyedListener","cleanupBeforeMaximisedStackDestroyed","_constructorOrSubWindowLayoutConfig","constructorOrSubWindowLayoutConfig","rootItem","focusedComponentItem","_focusedComponentItem","_maximisedStack","deprecatedConstructor","disconnect","checkClearResizeTimeout","dragSource","subWindowRootConfig","setContainer","updateSizeFromContainer","resolvedLayoutConfig","checkLoadedLayoutMaximiseItem","bindEvents","adjustColumnsResponsive","loadLayout","createSubWindows","groundContent","reconcilePopoutWindows","clear","newComponentAtLocation","locationSelectors","addComponentAtLocation","addItemAtLocation","newItemAtLocation","defaultLocationSelectors","findFirstLocation","addIdx","updateRootSize","createContentItemFromConfig","findFirstComponentItemById","findFirstContentItemTypeByIdRecursive","createPopout","itemConfigOrContentItem","positionAndSize","createPopoutFromItemConfig","child","windowLeft","windowTop","offsetLeft","offsetTop","beforeVirtualRectingEvent","afterVirtualRectingEvent","popoutLayoutConfig","createPopoutFromPopoutLayoutConfig","configWindow","initialWindow","newDragSource","componentTypeOrItemConfigCallback","removeDragSource","array","removeFromArray","focusComponent","clearComponentFocus","suppressEvents","newFocusedParentItem","oldFocusedItem","oldFocusedParentItem","processMinimiseMaximisedStack","processMaximiseStack","matchingArea","smallestSurface","Infinity","allContentItems","stackContentAreaDimensions","groundArea","configMaximisedItems","prepend","closed","observe","processResizeWithDebounce","_resizeTimeoutId","bodyElement","documentElement","margin","padding","overflow","useResponsiveLayout","columnCount","stackColumnCount","allStacks","getAllStacks","firstStackContainer","addChildContentItemsToContainer","alwaysResponsiveMode","onLoadResponsiveModeAndFirst","stacks","findAllStacksRecursive","findFirstContentItemType","findFirstContentItemTypeRecursive","foundContentItem","selectors","selector","findLocation","selectorIndex","typeId","parentContentItems","parentContentItemCount","tryCreateLocationFromParentItem","groundContentItems","afterFocusedItemIfPossibleLocationSelectors","VirtualLayout","configOrOptionalContainer","containerOrBindComponentEventHandler","unbindComponentEventHandler","skipInit","createLayoutManagerConstructorParameters","_bindComponentEventHanlderPassedInConstructor","_creationTimeoutPassed","bindComponentEvent","unbindComponentEvent","readyState","clearHtmlAndAdjustStylesForSubWindow","headElement","head","appendNodeLists","querySelectorAll","listIdx","appendNodeList","nodeIdx","innerHTML","visibility","checkAddDefaultPopinButton","popInButtonElement","iconElement","bgElement","getComponentEvent","releaseComponentEvent","subWindowChecked","windowConfigKey","windowConfigStr","getItem","removeItem","minifiedWindowConfig","parse","resolvedConfig","HTMLElement","golden","_componentTypesMap","_registeredComponentMap","_virtuableComponentMap","_containerVirtualRectingRequiredEventListener","handleContainerVirtualRectingRequiredEvent","_containerVirtualVisibilityChangeRequiredEventListener","handleContainerVirtualVisibilityChangeRequiredEvent","_containerVirtualZIndexChangeRequiredEventListener","handleContainerVirtualZIndexChangeRequiredEvent","registerComponent","componentConstructorOrFactoryFtn","componentConstructor","registerComponentConstructor","componentFactoryFtn","registerComponentFactoryFunction","typeName","factoryFunction","componentFactoryFunction","registerComponentFunction","registerGetComponentConstructorCallback","_getComponentConstructorFtn","warn","getRegisteredComponentTypeNames","typeNamesIterableIterator","getComponentInstantiator","instantiator","virtuableComponent","componentRootElement","rootHtmlElement","absolutePosition","ensureElementPositionAbsolute","delete","_goldenLayoutBoundingClientRect","rootElement","containerBoundingClientRect","template"],"sourceRoot":""}